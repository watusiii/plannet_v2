<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no" />
<title>Meritocracy</title>


<div class="loader-container" id="loaderContainer">
  <div>
      <div class="spinner"></div>
      <div class="loader">
          <div class="progress" id="progressBar"></div>
      </div>
      <div class="percentage" id="percentageText">0%</div>
  </div>
</div>

<script
  data-hcs-config=""
  data-hcs-cdn-url="https://kiloscribe.com/api/inscription-cdn/"
  data-hcs-network="mainnet"
  data-hcs-debug="true"
  data-hcs-retry-attempts="5"
  data-hcs-retry-backoff="500"
  data-hcs-show-loading-indicator="true"
  data-hcs-loading-callback-name="setLoadingIndicator"
  type="e5a3c1b79eab779120034ec1-text/javascript"
></script>

<link data-src="hcs://1/0.0.8287094"data-script-id="map css"/>

<script data-src="hcs://1/0.0.8269272" data-script-id="maplibre"></script>

<script data-src="hcs://1/0.0.8269285" data-script-id="supercluster"></script>

<script data-src="hcs://1/0.0.8355670" data-script-id="threejs 137 + GLTFLoader"></script>

<script data-src="hcs://1/0.0.9740486" data-script-id="walletconnect"></script>

<script data-src="hcs://1/0.0.9678314" data-script-id="DRACOLoader"></script>

<script data-src="hcs://1/0.0.9705945" data-script-id="dracoBase64"></script>

<script data-src="hcs://1/0.0.9872320" data-script-id="ipfs-core"></script>

<script data-src="hcs://1/0.0.9961904" data-script-id="helia@5.5.1"></script>

<script data-src="hcs://1/0.0.9961944" data-script-id="unixfs@5.1.0"></script>

<script data-src="hcs://1/0.0.9966383" data-script-id="libp2p.bundle"></script>

<script data-src="hcs://1/0.0.10013779" data-script-id="multiformats@13.4.1"></script>

<script data-src="hcs://1/0.0.10013806" data-script-id="delegated-peer-routing@4.0.14"></script>

<script data-src="hcs://1/0.0.10013810" data-script-id="kubo-rpc-client@latest"></script>

<script data-src="hcs://1/0.0.10013813" data-script-id="libp2p-noise@17.0.0"></script>

<script data-src="hcs://1/0.0.10014184" data-script-id="libp2ppeer-id"></script>

<script data-src="hcs://1/0.0.10015601" data-script-id="helia-verified-fetch@3.2.3"></script>

<script data-src="hcs://1/0.0.10017359" data-script-id="blockstore-idb@3.0.1"></script>

<script data-src="hcs://1/0.0.10017498" data-script-id="helia-bitswap@3.0.3"></script>

<script data-src="hcs://1/0.0.10017540" data-script-id="libp2p/logger@6.0.5"></script>

<script data-src="hcs://1/0.0.10021978" data-script-id="chainsafe-libp2p-yamux@8.0.0"></script>

<script data-src="hcs://1/0.0.10022000" data-script-id="helia-routers@3.1.3"></script>

<script data-src="hcs://1/0.0.10022010" data-script-id="libp2p-autonat@3.0.5"></script>

<script data-src="hcs://1/0.0.10022013" data-script-id="libp2p-circuit-relay-v2@4.0.5"></script>

<script data-src="hcs://1/0.0.10022017" data-script-id="libp2p-dcutr@3.0.5"></script>

<script data-src="hcs://1/0.0.10022020" data-script-id="ibp2p-identify@4.0.5"></script>

<script data-src="hcs://1/0.0.10022025" data-script-id="libp2p-keychain@6.0.5"></script>

<script data-src="hcs://1/0.0.10022034" data-script-id="libp2p-mplex@12.0.6"></script>

<script data-src="hcs://1/0.0.10022054" data-script-id="libp2p-webrtc@6.0.6"></script>

<script data-src="hcs://1/0.0.10022056" data-script-id="helia-delegated-routing-v1-http-api-client@4.2.5"></script>

<script data-src="hcs://1/0.0.10022058" data-script-id="helia-http@2.2.1"></script>

<script data-src="hcs://1/0.0.10022060" data-script-id="ipns@10.1.2"></script>

<script data-src="hcs://1/0.0.10022637" data-script-id="multiformats-multiaddr@12.2.3"></script>

<style>

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: fixed;
}

.maplibregl-canvas {
  background-color: rgb(0, 0, 0) !important;
}

#map {
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  width: 100%;
  height: 100%;
}

#three-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.options-and-topic {
  background-color: #007bff;
  color: white;
  border: none;
  padding: 0.8vh 1vw;
  border-radius: 0.8vh;
  cursor: pointer;
  font-size: 1.5vh;
}

.rotation-controls {
  position: fixed;
  display: flex;
  flex-direction: column;
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding-top: 1vh;
  padding-bottom: 0.5vh;
  padding-left: 1vw;
  padding-right: 1vw;
  border-radius: 1vh;
  z-index: 1001;
  justify-content: space-around;
  width: 98vw;
  top: 10vh;
  left: 0;
  transform: none;
  display: none;
  animation: slideIn 0.5s ease-in-out;
}

.menu_buttons {
  position: fixed;
  left: 0;
  z-index: 1006;
  background-color: #007bff;
  color: white;
  border: none;
  padding: 0.8vh 1vw;
  border-radius: 0.8vh;
  cursor: pointer;
  font-size: 1.5vh;
  display: none;
  margin-left: 0.3vh;
}

.copy-coordinates {
  position: fixed;
  right: 0;
  top: 0;
  z-index: 1001; /* Ensure the button is above the input field */
  background-color: transparent; /* Make the button invisible */
  border: none;
  cursor: pointer;
  font-size: 1.5vh;
}

.yourfovcontainer {
  background-color: rgba(0, 0, 0, 0);
  color: white;
  border-radius: 4px;
  box-sizing: border-box;
  border-radius: 1vh;
  overflow-y: auto; /* Enable vertical scrolling */
  max-height: 80vh; /* Limit the height to 80% of the viewport */
  touch-action: auto; /* Enable touch interactions */
  resize: none; /* Prevent manual resizing */
  width: 100vw;
  padding-top: 1vh;
  padding-bottom: 0.5vh;
  padding-left: 1vw;
  padding-right: 1vw;
  animation: slideIn 0.5s ease-in-out;
}

.chat-topic-chat-container {
  background-color: rgba(0, 0, 0, 0);
  color: white;
  box-sizing: border-box;
  border-radius: 1vh;
  animation: slideIn 0.5s ease-in-out;
}

.toolbar {
  position: fixed;
  display: flex;
  flex-direction: column;
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  border-radius: 1vh;
  z-index: 1001;
  justify-content: space-around;
  top: 10vh;
  left: 0;
  transform: none;
  width: 98vw;
  padding-top: 1vh;
  padding-bottom: 0.5vh;
  padding-left: 1vw;
  padding-right: 1vw;
  animation: slideIn 0.5s ease-in-out;
}

.toolbar-containers {
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  border-radius: 4px;
  box-sizing: border-box;
  border-radius: 1vh;
  overflow-y: auto; /* Enable vertical scrolling */
  max-height: 80vh; /* Limit the height to 80% of the viewport */
  touch-action: auto; /* Enable touch interactions */
  resize: none; /* Prevent manual resizing */
  width: 100vw;
  padding-top: 1vh;
  padding-bottom: 0.5vh;
  padding-left: 1vw;
  padding-right: 1vw;
  animation: slideIn 0.5s ease-in-out;
}

@keyframes slideIn {
    from {
      opacity: 0;
      transform: translateX(-200px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

.toolbar-group {
  width: 100%;
  color: white;
  padding-top: 1vh;
  padding-bottom: 0.5vh !important;
  padding-left: 1vw;
  padding-right: 1vw;
  border: 0.1vh solid white;
  border-radius: 1vh;
  box-sizing: border-box;
  margin-bottom: 1vh;
  border: 0.1vh solid #ffc107;
  overflow: hidden; /* Hide scrollbars */
  resize: none; /* Prevent manual resizing */
  background-color: transparent;
  touch-action: auto; /* Enable touch interactions */
}

.toolbar-column-btns {
  display: block;
  width: 100%;
  color: white;
  border: 0.1vh solid white;
  border-radius: 1vh;
  font-size: 2vh;
  box-sizing: border-box;
  margin-bottom: 0.5vh;
  height: 5vh;
  background-color: transparent;
  border: 0.1vh solid rgb(0, 123, 255);
}

.toolbar-column-btns:hover,
.toolbar-column-btns:active {
  background-color: rgb(0, 123, 255);
  color: white;
}

.toolbar-column:hover,
.toolbar-column.active {
  background-color: rgba(255, 255, 255, 0.2);
}

.toolbar-column {
  display: block;
  width: 100%;
  color: white;
  padding-left: 1vw;
  border: 0.1vh solid white;
  border-radius: 1vh;
  font-size: 2vh;
  box-sizing: border-box;
  margin-bottom: 0.5vh;
  height: 5vh;
  border: 0.1vh solid rgb(0, 123, 255);
  overflow: hidden; /* Hide scrollbars */
  resize: none; /* Prevent manual resizing */
  background-color: transparent;
  touch-action: auto; /* Enable touch interactions */
}

.topic-chat-container {
  background-color: rgba(0, 0, 0, 0.9);
  color: white;
  border-radius: 4px;
  box-sizing: border-box;
  border-radius: 1vh;
  overflow-y: auto; /* Enable vertical scrolling */
  max-height: 80vh; /* Limit the height to 80% of the viewport */
  touch-action: auto; /* Enable touch interactions */
  resize: none; /* Prevent manual resizing */
  padding-top: 1vh;
  padding-bottom: 0.5vh;
  padding-left: 1vw;
  padding-right: 1vw;
  width: 100%;
}

.chat-container {
  display: block;
  width: 100% !important;
  color: white;
  padding-left: 1vw;
  border-radius: 1vh;
  font-size: 2vh;
  box-sizing: border-box;
  margin-bottom: 0.5vh;
  border: 0.1vh solid rgb(0, 123, 255);
  overflow: hidden; /* Hide scrollbars */
  resize: none; /* Prevent manual resizing */
  background-color: transparent;
  touch-action: auto; /* Enable touch interactions */
  max-height: 50vh; /* Set maximum height */
  overflow-y: scroll; /* Explicitly enable vertical scrolling */
  user-select: text; /* Allow text selection */
  -webkit-overflow-scrolling: touch; /* Enable momentum scrolling on iOS */
  scrollbar-width: none; /* Firefox */
}

.model_sliders {
  display: block;
  width: 100% !important;
  padding-left: 1vw;
  border-radius: 1vh;
  font-size: 2vh;
  box-sizing: border-box;
  margin-bottom: 0.5vh;
  height: 5vh;
  overflow: hidden; /* Hide scrollbars */
  resize: none; /* Prevent manual resizing */
  background-color: transparent;
  touch-action: auto; /* Enable touch interactions */
  text-align: center; /* Center-align the text */
  text-shadow: 0 0 0.5vh black;
}

#speed-slider {
  position: absolute;
  top: 3vh;
  right: 0;
  z-index: 1005;
  width: 32.5vw;
  height: 3vh;
  writing-mode: bt-lr;
  transform: rotate(0deg);
}

.yourfov {
  display: block;
  width: 100% !important;
  color: white;
  padding-left: 1vw;
  border: 0.1vh solid white;
  border-radius: 1vh;
  font-size: 2vh;
  box-sizing: border-box;
  margin-bottom: 0.5vh;
  height: 5vh;
  border: 0.1vh solid rgb(0, 123, 255);
  overflow: hidden; /* Hide scrollbars */
  resize: none; /* Prevent manual resizing */
  background-color: transparent;
  touch-action: auto; /* Enable touch interactions */
  background-color: transparent;
  text-align: left; /* Center-align the text */
  text-shadow: 0 0 0.5vh black;
}

.flex-container {
  display: flex;
  align-items: center;
  margin-bottom: 1.33vh;
  position: relative;
  z-index: 003;
}

#wallet-section {
  position: fixed;
  top: 0;
  left: 0;
  display: flex;
  flex-direction: column; /* Stack items vertically */
  align-items: flex-start;
  font-size: 1.6vw;
  border-radius: 1.07vw;
  background-color: rgba(51, 51, 51, 0.0);
  z-index: 5003;
  backdrop-filter: blur(5px);
}

#connect-wallet-btn {
  background-color: #007bff;
  color: white;
  border: none;
  padding: 0.8vh 1vw;
  border-radius: 0.8vh;
  cursor: pointer;
  font-size: 1.5vh;
  text-shadow: 0 0 0.5vh black;
  margin-top: 0.3vh;
  margin-left: 0.3vh;
}

#disconnect-wallet-btn {
  display: none;
  background-color: #ffc107;
  color: white;
  border: none;
  padding: 0.8vh 1vw;
  border-radius: 0.8vh;
  cursor: pointer;
  font-size: 1.5vh;
  text-shadow: 0 0 0.5vh black;
  margin-top: 0.3vh;
  margin-left: 0.3vh;
}

.account-info {
  display: flex;
  flex-direction: column;
  font-family: Arial, sans-serif;
  color: white;
  padding-top: 0.5vh;
  border: none;
  border-radius: 0.8vh;
  cursor: pointer;
  font-size: 1.5vh;
}

#account-id {
  color: white;
}

#coordinates-display {
  position: fixed;
  right: 0;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 5px 10px;
  border-radius: 4px;
  font-family: Arial, sans-serif;
  z-index: 1000;
  top: 0;
  font-size: 2vh;
  border: none;
  width: auto;
  pointer-events: none; /* Allow clicks to pass through */
}

.touch-button {
  background-color: rgba(0, 0, 0, 0.2);
  color: white;
  border: 2px solid white;
  padding: 0.5vh;
  margin: 0.3vh;
  border-radius: 1vh;
  cursor: pointer;
  font-size: 2vh;
  width: 6vh;
  height: 6vh;
  display: none;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(2px);
}

.touch-button:hover {
  background-color: rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.8);
}

.button-container {
  display: grid;
  position: fixed;
  bottom: 5vh;
  z-index: 1004;
  grid-template-columns: repeat(3, 6vh);
  grid-template-rows: repeat(3, 6vh);
  gap: 0.3vh;
  justify-items: center;
  align-items: center;
}

#left-dpad {
  left: 0.5vw;
  display: none;
}

#right-dpad {
  right: 0.5vw;
  display: none;
}

/* Explicitly position and show defined buttons */
#left-up, #right-up {
  grid-column: 2 / 3;
  grid-row: 1 / 2;
  display: flex;
}

#left-left, #right-left {
  grid-column: 1 / 2;
  grid-row: 2 / 3;
  display: flex;
}

#left-right, #right-right {
  grid-column: 3 / 4;
  grid-row: 2 / 3;
  display: flex;
}

#left-down, #right-down {
  grid-column: 2 / 3;
  grid-row: 3 / 4;
  display: flex;
}


#zoom-controls {
  position: fixed;
  bottom: 40vh;
  right: 0.5vw;
  z-index: 1005;
  display: none;
  flex-direction: column;
  gap: 0.5vh;
}

.zoom-button {
  background-color: rgba(0, 0, 0, 0.2);
  color: white;
  border: 2px solid white;
  width: 8vh;
  height: 8vh;
  margin: 0.3vh;
  border-radius: 50%;
  cursor: pointer;
  font-size: 2.5vh;
  display: flex;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(2px);
}

.zoom-button:hover {
  background-color: rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.8);
}

#toggle-controls-btn {
  position: fixed;
  top: 6.5vh;
  left: 0;
  z-index: 1006;
  background-color: #007bff;
  color: white;
  border: none;
  padding: 0.8vh 1vw;
  border-radius: 0.8vh;
  cursor: pointer;
  font-size: 1.5vh;
  display: none;
}

.maplibregl-ctrl.maplibregl-ctrl-group {
    background: #fff; /* White background, matches default */
    border-radius: 4px; /* Rounded corners */
    box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    margin: 6vh 10px 10px 10px; /* 5vh top margin, 10px others */
    border-radius: 50%;
    display: none;
}

.maplibregl-ctrl.maplibregl-ctrl-group button.maplibregl-ctrl-zoom-in,
.maplibregl-ctrl.maplibregl-ctrl-group button.maplibregl-ctrl-zoom-out {
    display: none;
}

.maplibregl-ctrl.maplibregl-ctrl-group button.maplibregl-ctrl-compass {
    width: 2vh; /* Standard button size */
    height: 2vh; /* Square button */
    background-color: #fff; /* White background */
    border: none; /* No border */
    cursor: pointer; /* Pointer cursor */
    display: flex; /* Center icon */
    align-items: center;
    justify-content: center;
    background-size: 18px 18px; /* Icon size */
    background-position: center;
    background-repeat: no-repeat;
    transition: background-color 0.2s; /* Smooth hover transition */
    border-radius: 50%; /* Circular button */
}


.maplibregl-popup {
  position: fixed !important; /* Viewport-based positioning */
  top: 50% !important; /* Center vertically */
  left: 50% !important; /* Center horizontally */
  transform: translate(-50%, -50%) !important; /* Center both horizontally and vertically */
  max-width: 80vw !important;
  width: max-content !important; /* Allow content to dictate width up to max-width */
  box-sizing: border-box; /* Ensure padding/borders donâ€™t increase width */
  font: 2vh/3vh 'Helvetica Neue', Arial, Helvetica, sans-serif;
  text-align: left;
  z-index: 1000 !important; /* Above map elements */
  border: 0.3vh solid;
  border-color: #ffffff;
  border-radius: 1vh;
  animation: slideIn 0.5s ease-in-out;
}

.maplibregl-popup-content {
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 1vh;
  border-radius: 0.8vh;
  font-size: 2vh;
  box-shadow: 0 1vh 2vh rgba(0, 0, 0, 0.3);
  text-align: left;
  word-wrap: break-word;
  white-space: normal;
  user-select: text !important;
  -webkit-user-select: text !important;
  -moz-user-select: text !important;
  -ms-user-select: text !important;
  overflow-y: auto; /* Scroll if content exceeds max-height */
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.5) rgba(0, 0, 0, 0.8);
  overflow-x: auto; /* Allow horizontal scrolling for wide content */
}

.maplibregl-popup-content::-webkit-scrollbar {
  width: 0.8vh;
}

.maplibregl-popup-content::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.8);
}

.maplibregl-popup-content::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.5);
  border-radius: 0.4vh;
}

.maplibregl-popup-content * {
  user-select: text !important;
  -webkit-user-select: text !important;
  -moz-user-select: text !important;
  -ms-user-select: text !important;
}

#topic-chat-container * {
  user-select: text !important;
  -webkit-user-select: text !important;
  -moz-user-select: text !important;
  -ms-user-select: text !important;
}

.maplibregl-popup-close-button {
  color: white;
  font-size: 3vh;
  border: none;
  background: none;
  box-shadow: none;
  padding: 0;
  margin: 0;
  outline: none;
  position: absolute;
  top: -1vh;
  right: 0;
}

.maplibregl-popup-tip {
  display: none !important; /* Hide anchor triangle */
}


* {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  touch-action: none;
}

input, textarea {
  -webkit-user-select: text;
  -khtml-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
  touch-action: manipulation;
}

button[type="submit"],
  #toolbar-load,
  #submit-button-Create_Marker,
  #submit-button-Create_Polygon,
  #submit-button-Create_New_Topic,
  #submit-button-Change_Memo,
  #submit-button-Set_Rules,
  #add-topic-id,
  #remove-topic-id {
  height: 5vh; /* Adjust the height as needed */
  font-size: 2vh; /* Adjust the font size for better readability */
  border-radius: 1vh; /* Add this line to make the buttons round */
}

#crosshair {
  display: none; /* Add this line to hide by default */
  position: fixed;
  top: 50%;
  left: 50%;
  width: 2px;
  height: 2px;
  background-color: white;
  transform: translate(-50%, -50%);
  z-index: 1007;
}

#crosshair::before {
  content: '';
  position: absolute;
  background-color: var(--crosshair-color, rgb(0, 0, 0)); /* Default color if variable is not set */
  width: var(--crosshair-before-width, 20px); /* Width of the crosshair line */
  height: var(--crosshair-before-height, 2px); /* Default thickness */
  top: 50%; /* Center vertically */
  left: 50%; /* Center horizontally */
  transform: translate(-50%, -50%); /* Adjust to center */
}

#crosshair::after {
  content: '';
  position: absolute;
  background-color: var(--crosshair-color, rgb(0, 0, 0)); /* Default color if variable is not set */
  width: var(--crosshair-after-width, 2px); /* Width of the crosshair line */
  height: var(--crosshair-after-height, 20px); /* Height of the crosshair line */
  top: 50%; /* Center vertically */
  left: 50%; /* Center horizontally */
  transform: translate(-50%, -50%); /* Adjust to center */
}

.loader-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background-color: #f0f0f0;
}

.loader {
  width: 300px;
  height: 20px;
  background-color: #e0e0e0;
  border-radius: 10px;
  overflow: hidden;
}

.progress {
  height: 100%;
  background-color: #4caf50;
  border-radius: 10px;
  transition: width 0.5s ease-in-out;
}

.percentage {
  margin-top: 10px;
  font-size: 1.5em;
  font-family: Arial, sans-serif;
  color: #333;
}

.hidden {
  display: none;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 5px solid #ccc;
  border-top: 5px solid #4caf50;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 20px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

</style>
</head>
 
<body>

<div id="map"></div>

<div id="three-container"></div>

<input id="coordinates-display" value="Coordinates:"/>

<button id="copy-coordinates" class="copy-coordinates"></button>

<div id="crosshair"></div>

<div style="display: flex; position: fixed; top: 6.5vh; left: 0; z-index: 1006;">
  <button id="main-toggle-btn" class="options-and-topic" style="margin-left: 0.3vh;">OPTIONS
  </button>
  <button id="topic-chat-btn" class="options-and-topic" style="margin-left: 1vw;">TOPIC CHAT
  </button>
</div>

<button id="toggle-controls-btn" class="menu_buttons" style="top: 6.5vh;">CONTROLS
</button>

<button id="toggle-your-fov-btn" class="menu_buttons" style="top: 11vh;">YOUR POV
</button>

<button id="toggle-visibility-controls-btn" class="menu_buttons" style="top: 15.5vh;">VISIBILITY
</button>

<button id="toggle-toolbar-btn" class="menu_buttons" style="top: 20vh;">TOOLBAR
</button>

<div id="toolbar" class="toolbar" style="display: none; flex-direction: column;">
  <div class="toolbar-column" id="Edit_Profile">Edit
  </div>
  <div class="toolbar-column" id="Load_Everything">Load
  </div>
  <div class="toolbar-column" id="Upload_To_IPFS">Upload
  </div>
  <div class="toolbar-column" id="Create_New_Topic">Create
  </div>
  <div class="toolbar-column" id="Create_Marker">Marker
  </div>
  <div class="toolbar-column" id="Create_Polygon">Polygon
  </div>
  <div class="toolbar-column" id="Set_Rules">Set Rules
  </div>
  <div class="toolbar-column" id="NFT-utility">NFT Utility
  </div>
  <div class="toolbar-column" id="Change_Memo">Update Topic
  </div>
  <div class="toolbar-column" id="Stack_topic_IDs">Stack topic IDs
  </div>
</div>

<div id="Edit_Profile-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
  <div id="Edit_Profile-column-container" class="toolbar-containers" onclick="event.stopPropagation();">

    <textarea type="text" id="toolbar-input" placeholder="URL/name/domain"
    class="toolbar-column" onclick="event.stopPropagation();"
    oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>

    <div style="display: flex; flex-direction: row; width: 100%;">
      <button class="toolbar-column-btns" id="button1" style="display: block;">Picture
      </button>
      <button class="toolbar-column-btns" id="button2" style="display: block; margin-left: 1vw;">Username
      </button>
      <button class="toolbar-column-btns" id="button_for_click_url" style="display: block; margin-left: 1vw;">CLICK2LINK
      </button>
    </div>

    <textarea type="text" id="Edit_Profile-topic-id" placeholder="Topic ID"
    class="toolbar-column" onclick="event.stopPropagation();"
    oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>

    <div style="display: flex; flex-direction: row; width: 100%;">
      <button class="toolbar-column-btns" id="button3">TopicID name
      </button>
      <button class="toolbar-column-btns" id="button_for_topic2pic" style="margin-left: 1vw;">TOPIC2PIC
      </button>
    </div>

    <textarea type="text" id="domain-time-left" placeholder="Domain time left"
    class="toolbar-column" onclick="event.stopPropagation();" readonly>
    </textarea>

    <button class="toolbar-column-btns" id="button4">Check domain availability
    </button>

    <label for="domain-time-left" style="font-size: 2vh;">1 USDC
    (<span style="cursor: pointer; color: rgb(255, 255, 255); text-decoration: underline;"
    onclick="navigator.clipboard.writeText('0.0.456858')
    .then(() => alert('Copied to clipboard: 0.0.456858'))
    .catch(err => console.error('Failed to copy: ', err));">0.0.456858</span>):
    </label>
    <button class="toolbar-column-btns" id="button5" style="margin-top: 0.5vh;">Add 28 days to domain
    </button>

  </div>
</div>

<div id="load-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
  <div id="load-column-container" class="toolbar-containers" onclick="event.stopPropagation();">

    <textarea class="toolbar-column" type="text" id="input-field" placeholder="Domain/Topic ID" onclick="event.stopPropagation();"
    oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>

    <button id="toolbar-load" class="toolbar-column-btns">Load Data
    </button>

    <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topics with names not domains:
    </label>

    <textarea class="toolbar-column" type="text" id="loaded-topics" placeholder="Loaded Topics" onclick="event.stopPropagation();" readonly
    ></textarea>

    <textarea class="toolbar-column" type="text" id="load-msgs-from-ids" placeholder="user ID or IDs separated by comma"
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>

    <button id="load-msgs-from-ids-button" class="toolbar-column-btns">Load Messages From
    </button>

  </div>
</div>

<div id="upload-to-ipfs-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
  <div id="upload-to-ipfs-column-container" class="toolbar-containers" onclick="event.stopPropagation();">

    <input type="file" class="toolbar-column" id="fileInput" />
    <button id="upload-to-ipfs-button" class="toolbar-column-btns">Upload to IPFS</button>
    <textarea class="toolbar-column" id="cid-output" placeholder="CID" readonly></textarea>

    <textarea class="toolbar-column" id="cid-input" type="text" placeholder="Enter CID"
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
    
    <!-- ADD THIS: Content type selector for fetch -->
    <select class="toolbar-column" id="content-type">
      <option value="image">Image/GIF</option>
      <option value="video">Video</option>
    </select>
    
    <button class="toolbar-column-btns" id="fetch-from-ipfs-button">Fetch from IPFS</button>
    <div id="cid-output"></div> <!-- Note: You have two #cid-output elements; consider consolidating to one -->
    <div id="image-container"></div>

    <button class="toolbar-column-btns" id="copy-share-link" style="display: none;">Copy Share Link</button>

  </div>
</div> <!-- Close the div properly -->

<div id="create-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
  <div id="create-column-container" class="toolbar-containers" onclick="event.stopPropagation();">
    <div class="toolbar-group">
      <textarea class="toolbar-column" type="text" id="input-field-5-1" placeholder="Admins 0.0.1,0.0.2.."
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>

      <textarea class="toolbar-column" type="text" id="input-field-5-2" placeholder="Use Private Key here"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>

      <label for="public-key-label"style="font-size: 2vh; padding: 0px; user-select: text;">If it doesnt load go to hashscan.io or app.dragonglass.me and input your acc id:
      </label>

      <input class="toolbar-column" type="text" id="input-field-5" placeholder="Generated Topic ID"
      onclick="event.stopPropagation();"readonly/>

      <!-- <label for="public-key-label"style="font-size: 2vh; padding: 0px;">Set fee for each message:</label>
      <textarea
      class="toolbar-column"
      type="text"
      id="input-field-5-3"
      placeholder="Set amount of fee"
      style="
        background-color: transparent;
        overflow: hidden; /* Hide scrollbars */
        resize: none; /* Prevent manual resizing */
      "
      onclick="event.stopPropagation();"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea
      class="toolbar-column"
      type="text"
      id="input-field-5-4"
      placeholder="Set token id of fee"
      style="
        background-color: transparent;
        overflow: hidden; /* Hide scrollbars */
        resize: none; /* Prevent manual resizing */
      "
      onclick="event.stopPropagation();"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea
      class="toolbar-column"
      type="text"
      id="input-field-5-5"
      placeholder="Set royalty account"
      style="
        background-color: transparent;
        overflow: hidden; /* Hide scrollbars */
        resize: none; /* Prevent manual resizing */
      "
      onclick="event.stopPropagation();"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea> -->

      <button id="submit-button-Create_New_Topic" class="toolbar-column-btns" style="display: block;">Create
      </button>
    </div>
    <!--
    <div class="toolbar-group">
      <label for="public-key-label"style="font-size: 2vh; padding: 0px;">Public Key:</label>
      <textarea
      class="toolbar-column"
      id="generated-public-key"
      placeholder="Generated Public Key"
      style="
      background-color: transparent;
      overflow: hidden; /* Hide scrollbars */
      resize: none; /* Prevent manual resizing */
    "
      readonly
      onclick="event.stopPropagation();"
    ></textarea>
    -->

    <label for="private-key-label"style="font-size: 2vh; padding: 0px;">Private Key:
    </label>

    <textarea class="toolbar-column" id="generated-private-key" placeholder="Generated Private Key"
    onclick="event.stopPropagation();" readonly
    ></textarea>

    <button id="generate-private-and-public-key" class="toolbar-column-btns" style="display: block;">Generate
    </button>

  </div>
</div>


<div id="marker-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
  <div id="marker-column-container" class="toolbar-containers" onclick="event.stopPropagation();">
    <div class="toolbar-group">
      <textarea class="toolbar-column" type="text" id="input-field-2-0" placeholder="Domain/Topic ID"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-number-of-marker" placeholder="Number of marker"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-2-3" placeholder="Coordinates long,lat"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';" onclick="event.stopPropagation();"
      ></textarea>
    </div>

    <textarea class="toolbar-column" type="text" id="input-field-coverimage-marker" placeholder="Cover Image URL"
    oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';" onclick="event.stopPropagation();"
    ></textarea>
    <textarea class="toolbar-column" type="text" id="input-field-2-1" placeholder="Title"
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
    <textarea class="toolbar-column" type="text" id="input-field-image-marker" placeholder="Image URL"
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>

    <div style="position: relative;">
      <textarea class="toolbar-column" type="text" id="input-field-2-2" placeholder="Message" maxlength="256"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';
      document.getElementById('char-counter-marker').textContent = this.value.length + '/256';"
      ></textarea>
      <div id="char-counter-marker" style="position: absolute; bottom: 5px; right: 10px; font-size: 2vh; color: #666;">0/256
      </div>
    </div>

    <button id="submit-button-Create_Marker" class="toolbar-column-btns">
    Submit
    </button>

    <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topic Rules:</label>
    
    <textarea class="toolbar-column" type="text" id="loaded-topic-rules-for-marker" placeholder="Loaded Topic Rules"
    onclick="event.stopPropagation();" readonly oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
    <button id="load-topic-rules-for-marker" class="toolbar-column-btns">
    Load Topic Rules
    </button>

    <div style="display: flex; flex-direction: row; width: 100%;">
      <textarea class="toolbar-column" type="text" id="input-field-delete-marker-number" placeholder="Number of marker"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <button id="delete-marker-number" class="toolbar-column-btns">
      Delete marker number
      </button>
    </div>

  </div>
</div>

<div id="polygon-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
  <div id="polygon-column-container" class="toolbar-containers" onclick="event.stopPropagation();">
    <div class="toolbar-group">
      <textarea class="toolbar-column" type="text" id="input-field-3-0" placeholder="Domain/Topic ID"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-number-of-polygon" placeholder="Number of polygon"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-3-3" placeholder="TOP LEFT long,lat"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-3-5" placeholder="BOTTOM RIGHT long,lat"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
    </div>
    
    <textarea class="toolbar-column" type="text" id="input-field-coverimage-polygon" placeholder="Cover Image URL"
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
    <textarea class="toolbar-column" type="text" id="input-field-3-1" placeholder="Title" 
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
    <textarea class="toolbar-column" type="text" id="input-field-image-polygon" placeholder="Image URL"
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>

    <div style="position: relative;">
      <textarea class="toolbar-column" id="input-field-3-2" placeholder="Message" maxlength="256"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';
      document.getElementById('char-counter-polygon').textContent = this.value.length + '/256';"
      ></textarea>
      <div id="char-counte-polygon" style="position: absolute; bottom: 5px; right: 10px; font-size: 2vh; color: #666;">0/256
      </div>
    </div>


    <button id="submit-button-Create_Polygon" class="toolbar-column-btns" style="display: block;">Submit
    </button>
    <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topic Rules:</label>
    <textarea class="toolbar-column" type="text" id="loaded-topic-rules-for-polygon" placeholder="Loaded Topic Rules"
    onclick="event.stopPropagation();" readonly
    ></textarea>
    <button id="load-topic-rules-for-polygon" class="toolbar-column-btns">Load Topic Rules
    </button>

    <div style="display: flex; flex-direction: row; width: 100%;">
      <textarea class="toolbar-column" type="text" id="input-field-delete-polygon-number" placeholder="Number of polygon"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <button id="delete-polygon-number" class="toolbar-column-btns">
      Delete polygon number
      </button>
    </div>
      
  </div>
</div>

<div id="rules-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
  <div id="rules-column-container" class="toolbar-containers" onclick="event.stopPropagation();">

    <textarea class="toolbar-column" type="text" id="input-field-topic-id-for-rules" placeholder="Domain/Topic ID"
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
    <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topic Rules:
    </label>
    <textarea class="toolbar-column" type="text" id="loaded-topic-rules-for-topic" placeholder="Loaded Topic Rules"
    onclick="event.stopPropagation();" readonly></textarea>
    <button id="load-topic-rules-for-topic" class="toolbar-column-btns">Load Topic Rules
    </button>
    <label for="input-field-rules-for-polygons"style="font-size: 2vh; padding: 0px;">These come in pair and they overwrite last set:
    </label>

    <div class="toolbar-group">
      <div style="margin-bottom: 0px;">
        <label for="input-field-rules-for-polygons"style="font-size: 2vh; padding: 0px;">For polygons:
        </label>
        <textarea class="toolbar-column" type="text" id="input-field-topic-id-for-polygons" placeholder="NFT ID (set to zero to allow all)"
        onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
        ></textarea>
      </div>

      <textarea class="toolbar-column" type="text" id="input-field-messages-per-nft-for-polygons" placeholder="how many polygons per NFT"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>

      <textarea class="toolbar-column" type="text" id="input-field-messages-size-for-polygons" placeholder="max size = (360,180) / (number)"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>

      <div style="margin-bottom: 10px;">
        <label for="input-field-add-rules" style=" font-size: 2vh;padding: 0px;">For markers:
        </label>
        <textarea class="toolbar-column" type="text" id="input-field-topic-id-for-markers" placeholder="NFT ID (set to zero to allow all)"
        onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
        ></textarea>
      </div>

      <textarea class="toolbar-column" type="text" id="input-field-messages-per-nft-for-markers" placeholder="how many markers per NFT"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <button id="submit-button-Set_Rules" class="toolbar-column-btns" style="display: block;">Submit
      </button>
      <div style="margin-bottom: 10px;"></div>
    </div>

  </div>
</div>

<div id="utility-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
  <div id="utility-column-container" class="toolbar-containers" onclick="event.stopPropagation();">
    
    <textarea class="toolbar-column" type="text" id="input-field-topic-id-for-utility" placeholder="Domain/Topic ID"
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
    <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topic Logic:
    </label>
    <textarea class="toolbar-column" type="text" id="loaded-topic-rules-for-utility" placeholder="Loaded Topic Rules"
    onclick="event.stopPropagation();" readonly></textarea>
    <button id="load-topic-rules-for-utility" class="toolbar-column-btns">Load Topic Rules
    </button>

    <label for="input-field-add-remove-NFT-for-model" style=" font-size: 2vh;padding: 0px;"> Model sharing:
    </label>
    <textarea class="toolbar-column" type="text" id="input-field-add-remove-NFT-for-model" placeholder="NFT ID (or IDs seperated by commas)"
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';" 
    ></textarea>

    <div class="button-group" style="display: flex; flex-direction: row; align-items: center;">
      <button id="submit-button-add-NFT-for-model" class="toolbar-column-btns">Add
      </button>
      <button id="submit-button-remove-NFT-for-model" class="toolbar-column-btns" style="margin-left: 8vw;">Remove
      </button>
    </div>

    <label for="input-field-add-remove-scale-for-model" style=" font-size: 2vh;padding: 0px;">Model scale factor:
    </label>
    <textarea class="toolbar-column" type="text" id="input-field-add-remove-scale-for-model" placeholder="scale (only one NFT at a time)"
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>

    <div class="button-group" style="display: flex; flex-direction: row; align-items: center;">
      <button id="submit-button-add-scale-for-model" class="toolbar-column-btns">Add
      </button>
      <button id="submit-button-remove-scale-for-model" class="toolbar-column-btns" style="margin-left: 8vw;">Remove
      </button>
    </div>


    <label for="input-field-add-remove-topic-chat" style=" font-size: 2vh;padding: 0px;">Topic Chat:
    </label>
    <textarea class="toolbar-column" type="text" id="input-field-add-remove-topic-chat" placeholder="NFT ID (or IDs seperated by commas)"
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>

    <div class="button-group" style="display: flex; flex-direction: row; align-items: center;">
      <button id="submit-button-add-topic-chat" class="toolbar-column-btns">Add
      </button>
      <button id="submit-button-remove-topic-chat" class="toolbar-column-btns" style="margin-left: 8vw;">Remove
      </button>
    </div>

  </div>
</div>

<div id="memo-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
  <div id="memo-column-container" class="toolbar-containers" onclick="event.stopPropagation();">

    <div class="toolbar-group">
      <textarea class="toolbar-column" type="text" id="input-field-topic-id" placeholder="Domain/Topic ID"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-admin-key" placeholder="public key"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-memo" placeholder="Admins 0.0.1,0.0.2.."
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
    </div>

    <label for="public-key-label"style="font-size: 2vh; padding: 0px;">Optional fee for each message:
    </label>

    <div class="toolbar-group">
      <textarea class="toolbar-column" type="text" id="input-field-fee" placeholder="Set amount of fee"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-fee-token" placeholder="Set token id of fee"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-royal-acc" placeholder="Set royalty account"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
    </div>

    <button id="submit-button-Change_Memo" class="toolbar-column-btns" style="display: block;">Submit
    </button>

  </div>
</div>

<div id="stack-topic-ids" style="display: none; position: absolute; z-index: 1002; top:10vh;">
  <div id="stack-topic-ids-container" class="toolbar-containers" onclick="event.stopPropagation();">

    <textarea class="toolbar-column" type="text" id="stack-topic-ids-topic" placeholder="Domain/Topic ID"
    click="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
    <textarea class="toolbar-column" type="text" id="stack-topic-add-topic" placeholder="0.0.1,0.0.2.."
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
    <button id="add-topic-id" class="toolbar-column-btns" style="display: block;">Stack
    </button>
    <textarea class="toolbar-column" type="text" id="stack-topic-remove-topic" placeholder="0.0.1,0.0.2.."
    onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
    <button id="remove-topic-id" class="toolbar-column-btns" style="display: block;">Remove
    </button>

  </div>
</div>

<div class="flex-container">
  <div id="wallet-section">
    <button id="connect-wallet-btn">Connect Wallet
    </button>
    <button id="disconnect-wallet-btn">Disconnect
    </button>
    <div class="account-info">
    <div id="account-id" style="margin-left: 0.3vh;"></div>
    </div>
  </div>
</div>

<div id="left-dpad" class="button-container">
  <button class="touch-button"></button>
  <button id="left-up" class="touch-button"></button>
  <button class="touch-button"></button>
  <button id="left-left" class="touch-button"></button>
  <button class="touch-button"></button>
  <button id="left-right" class="touch-button"></button>
  <button class="touch-button"></button>
  <button id="left-down" class="touch-button"></button>
  <button class="touch-button"></button>
</div>

<div id="right-dpad" class="button-container">
  <button class="touch-button"></button>
  <button id="right-up" class="touch-button"></button>
  <button class="touch-button"></button>
  <button id="right-left" class="touch-button"></button>
  <button class="touch-button"></button>
  <button id="right-right" class="touch-button"></button>
  <button class="touch-button"></button>
  <button id="right-down" class="touch-button"></button>
  <button class="touch-button"></button>
</div>

<div id="zoom-controls">
  <button id="zoom-in" class="zoom-button">+</button>
  <button id="zoom-out" class="zoom-button">-</button>
</div>

<input type="range" id="speed-slider" min="0.1" max="5" step="0.01" value="1" style="display: none;" />


<div id="topic-chat-container" class="topic-chat-container" style="display: none; position: absolute; z-index: 1002; top: 10vh;">
  <div class="chat-topic-chat-container"  onclick="event.stopPropagation();">

    <div style="display: flex; align-items: center; margin-bottom: 1vh;">
      <textarea class="toolbar-column" type="text" id="topic-chat-topic-id" placeholder="Domain/Topic ID"
      onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <button id="load-msgs-from" class="toolbar-column-btns" style="margin-left: 1vw;">Use
      </button>
    </div>

    <div style="display: flex; align-items: center; margin-bottom: 1vh;">
      <input type="number" id="from-mmddyyyy" class="toolbar-column" step="1" placeholder="MMDDYYYY" />
      <input type="number" id="to-mmddyyyy" class="toolbar-column" step="1" placeholder="MMDDYYYY" style="margin-left: 1vw;" />
      <button id="topic-msgs-filter" class="toolbar-column-btns" style="width: 50vw; margin-left: 1vw;">Filter
      </button>
    </div>

    <div style="display: flex; align-items: center; margin-bottom: 1vh;">
      <input type="number" id="from-hhmmss" class="toolbar-column" step="1" placeholder="HHMMSS" />
      <input type="number" id="to-hhmmss" class="toolbar-column" step="1" placeholder="HHMMSS" style="margin-left: 1vw;" />
      <button id="topic-msgs-filter-time" class="toolbar-column-btns" style="width: 50vw; margin-left: 1vw;">Filter
      </button>
    </div>

    <div class="chat-container" id="messages-from-topic-chat" onclick="event.stopPropagation();">
      <textarea
      style="
      width: 100%;
      height: 100px;
      resize: none; /* Prevent manual resizing */
      overflow: auto; /* Enable scrolling */
      background-color: transparent;
      border: none;
      "
      onfocus="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
    </div>

    <div style="position: relative;">
      <textarea
      class="toolbar-column"
      type="text"
      id="user-write-message"
      placeholder="Write a message (max 256 characters)"
      style="
      max-height: 50vh;
      overflow: auto;
      margin-top: 2vh;
      "
      onclick="event.stopPropagation();"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px'; document.getElementById('char-counter').textContent = this.value.length + '/256';"
      maxlength="256"
      ></textarea>
      <div id="char-counter" style="position: absolute; bottom: 5px; right: 10px; font-size: 2vh; color: #666;">0/256
      </div>
    </div>

    <div style="display: flex; align-items: center; margin-top: 1.5vh;">
      <button id="go-to-top-msgs" class="toolbar-column-btns">Go to the top
      </button>
      <button id="post-msg" class="toolbar-column-btns" style="margin-left: 1vw ">Submit Message
      </button>
    </div>

  </div>
</div>




<div id="rotation-controls" class='rotation-controls' onclick="event.stopPropagation();">
  <div class="toolbar-column" id="change-model-settings">Change model settings
  </div>
  <div class="toolbar-column" id="change-crosshair-settings">Change crosshair settings
  </div>
  <div class="toolbar-column" id="change-popup-settings">Change popup settings
  </div>
  <div class="toolbar-column" id="change-color-of-main-buttons">Change color of main buttons
  </div>
  <div class="toolbar-column" id="change-marker-options">Change marker options
  </div>
  <div class="toolbar-column" id="change-button-input-settings">Change button/input settings
  </div>
  <div class="toolbar-column" id="change-container-settings">Change container settings
  </div>
  <div class="toolbar-column" id="change-topic-chat-options">Change topic chat options
  </div>
</div>




<div id="visibility-controls" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
  <div class="chat-topic-chat-container" onclick="event.stopPropagation();">

    <div style="display: flex; align-items: center; margin-bottom: 1vh;">
      <label for="time-input" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">Enter a time of update in milliseconds:
      </label>
    </div>

    <div style="display: flex; align-items: center; margin-bottom: 1vh;">
      <input type="number" id="time-input" class="toolbar-column-btns" />
      <button id="update-loop" class="toolbar-column-btns" style="width: 50vw;  margin-left: 1vw; color: white; text-shadow: 0 0 0.5vh black;">Update time
      </button>
    </div>

    <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
      <label for="raster-opacity-slider" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">Polygon transparency:
      </label>
      <input type="range" id="raster-opacity-slider" class="model_sliders" min="0" max="1" step="0.01" value="1">
    </div>

    <div style="display: flex; align-items: center; margin-bottom: 1vh;">
      <button id="toggle-polygon-visibility" class="toolbar-column-btns" style="color: white; text-shadow: 0 0 0.5vh black;">Show polygons:
      </button>
      <span id="polygon-visibility-value" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
      </span>
    </div>

    <div style="display: flex; align-items: center; margin-bottom: 1vh;">
      <button id="toggle-marker-visibility" class="toolbar-column-btns" style="color: white; text-shadow: 0 0 0.5vh black;">Show markers
      </button>
      <span id="marker-visibility-value" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
      </span>
    </div>

    <div style="display: flex; align-items: center; margin-bottom: 1vh;">
      <button id="toggle-3d-model-visibility" class="toolbar-column-btns" style="color: white; text-shadow: 0 0 0.5vh black;">Show 3D models
      </button>
      <span id="3d-model-visibility-value" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
      </span>
    </div>

    <div style="display: flex; align-items: center; margin-bottom: 1vh;">
      <button id="toggle-updates" class="toolbar-column-btns" style="color: white; text-shadow: 0 0 0.5vh black;">model updates
      </button>
      <span id="updates-value" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
      </span>
    </div>

    <div style="display: flex; align-items: center; margin-bottom: 1vh;">
      <button id="update-map-layer-btn" class="toolbar-column-btns" style="color: white; text-shadow: 0 0 0.5vh black;">Update Map
      </button>
    </div>

  </div>
</div>

<div id="model-column" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
  <div id="model-column-container" class="yourfovcontainer" onclick="event.stopPropagation();" >

    <input type="text" class="toolbar-column" id="object-input" placeholder="Enter URL" style="text-align: center;" onclick="event.stopPropagation();" />
    <button id="buttonforobject" class="toolbar-column-btns" style="text-shadow: 0 0 0.5vh black; margin-top: 1vh;">Change object
    </button>

    <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh; padding-top: 1vh;">
      <label for="rotation-x"class="toolbar-column">Rotation X:
      </label>
      <input type="range" class="model_sliders" id="rotation-x" min="0" max="360" value="0"/>
      <input type="number" class="toolbar-column" style="text-align: center;" id="rotation-x-value" value="0"
      onchange="document.getElementById('rotation-x').value = this.value;" />
    </div>

    <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
      <label for="rotation-y" class="toolbar-column">Rotation Y:
      </label>
      <input type="range" class="model_sliders" id="rotation-y" min="0" max="360" value="0"/>
      <input type="number" class="toolbar-column" style="text-align: center;" id="rotation-y-value" value="0"
      onchange="document.getElementById('rotation-y').value = this.value;" />
    </div>

    <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
      <label for="rotation-z" class="toolbar-column">Rotation Z:
      </label>
      <input type="range" class="model_sliders" id="rotation-z" min="0" max="360" value="0"/>
      <input type="number" class="toolbar-column" style="text-align: center;" id="rotation-z-value" value="0"
      onchange="document.getElementById('rotation-z').value = this.value;" />
    </div>

    <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
      <label for="position-x" class="toolbar-column">Position X:
      </label>
      <input type="range" class="model_sliders" id="position-x" min="-100" max="100" step="0.1" value="0"/>
      <input type="number" class="toolbar-column" style="text-align: center;" id="position-x-value" value="0"
      onchange="document.getElementById('position-x').value = this.value;" />
    </div>

    <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
      <label for="position-y"    class="toolbar-column">Position Y:
      </label>
      <input type="range" class="model_sliders" id="position-y" min="-100" max="100" step="0.1" value="0"/>
      <input type="number" class="toolbar-column" style="text-align: center;" id="position-y-value" value="0"
      onchange="document.getElementById('position-y').value = this.value;" />
    </div>

    <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
      <label for="position-z"   class="toolbar-column">Position Z:
      </label>
      <input type="range" class="model_sliders" id="position-z" min="-100" max="100" step="0.1" value="0"/>
      <input type="number" class="toolbar-column" style="text-align: center;" id="position-z-value" value="0"
      onchange="document.getElementById('position-z').value = this.value;" />
    </div>

    <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
      <label for="scale-factor" class="toolbar-column">Scale Factor:
      </label>
      <input type="range" class="model_sliders" id="scale-factor" step="0.000001" value="1"/>
      <input type="number" class="toolbar-column" style="text-align: center;" id="scale-factor-value" value="1"
      onchange="document.getElementById('scale-factor').value = this.value;" />
    </div>

    <button id="savesettings" class="toolbar-column-btns" style="text-shadow: 0 0 0.5vh black;">Save settings
    </button>

  </div>
</div>


<div id="crosshair-column" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
  <div id="crosshair-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-red" class="yourfov">Red:
      </label>
      <input type="range" class="model_sliders" id="color-red" min="0" max="255" value="0"/>
      <input type="number" id="color-red-value"   class="yourfov" value="0"
      onchange="document.getElementById('color-red').value = this.value;" />
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Green:
      </label>
      <input type="range" class="model_sliders" id="color-green" min="0" max="255" value="0"/>
      <input type="number" id="color-green-value" class="yourfov" value="0"
      onchange="document.getElementById('color-green').value = this.value;" />
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-blue" class="yourfov">Blue:
      </label>
      <input type="range" class="model_sliders" id="color-blue" min="0" max="255" value="0"/>
      <input type="number" id="color-blue-value" class="yourfov" value="0"
      onchange="document.getElementById('color-blue').value = this.value;" />
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="crosshair-before-after" class="yourfov">Length:
      </label>
      <input type="range" class="model_sliders" id="crosshair-before-after" min="0" max="100" value="20"/>
      <input type="number" id="crosshair-before-after-value" class="yourfov" value="20"
      onchange="document.getElementById('crosshair-before-after').value = this.value;" />
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="crosshair-after-before" class="yourfov">Thickness:
      </label>
      <input type="range" class="model_sliders" id="crosshair-after-before" min="0" max="10" value="2"/>
      <input type="number" id="crosshair-after-before-value" class="yourfov" value="2"
      onchange="document.getElementById('crosshair-after-before').value = this.value;" />
    </div>

    <div id="savecrosshair" class="toolbar-column-btns" style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save crosshair
    </div>

  </div>
</div>

<div id="popup-column" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
  <div id="popup-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Border:
      </label>
      <input type="number" id="color-red-border" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-border" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-border" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Number:
      </label>
      <input type="number" id="color-red-number" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-number" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-number" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Close:
      </label>
      <input type="number" id="color-red-close" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-close" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-close" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">AccID:
      </label>
      <input type="number" id="color-red-accid" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-accid" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-accid" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Username:
      </label>
      <input type="number" id="color-red-username" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-username" class="yourfov" style="  margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-username" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Title:
      </label>
      <input type="number" id="color-red-titles" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-titles" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-titles" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Text:
      </label>
      <input type="number" id="color-red-text" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-text" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-text" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Font Size:
      </label>
      <input type="number" id="popup-font-size" class="yourfov" style="margin-left: 1vw;" value='2' max="255" placeholder="Default Size = 2"/>
    </div>

    <div id="savepopup" class="toolbar-column-btns" style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save popup
    </div>

  </div>
</div>

<div id="main-button-column" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
  <div id="main-button-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Disconnect:
      </label>
      <input type="number" id="color-red-disconnect-button" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-disconnect-button" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-disconnect-button" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Main Buttons:
      </label>
      <input type="number" id="color-red-main-button" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-main-button" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-main-button" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div id="save-main-button" class="toolbar-column-btns" style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save settings
    </div>

  </div>
</div>

<div id="marker-options-column" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
  <div id="marker-options-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Size:
      </label>
      <input type="number" id="Marker-Size" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Default Size = 5"/>
    </div>

    <div id="save-marker-settings" class="toolbar-column-btns" style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save Marker Settings
    </div>

  </div>
</div>

<div id="button-input-column" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
  <div id="button-input-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Input Border:
      </label>
      <input type="number" id="color-red-border-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-border-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-border-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Input Font Color:
      </label>
      <input type="number" id="color-red-font-color-input-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-font-color-input-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-font-color-input-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Button Border:
      </label>
      <input type="number" id="color-red-button-border-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-button-border-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-button-border-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Button Font Color:
      </label>
      <input type="number" id="color-red-font-color-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-font-color-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-font-color-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">OnHover:
      </label>
      <input type="number" id="color-red-onhover-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-onhover-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-onhover-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Font Size:
      </label>
      <input type="number" id="font-for-button-input" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Size"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Transparency:
      </label>
      <input type="number" id="color-red-transparency-button-input" class="yourfov" style="margin-left: 1vw;" min='0.5' step="0.01" max="1" placeholder="Opacity"/>
    </div>

    <div id="save-button-button-input" class="toolbar-column-btns" style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save Button/Input Settings
    </div>

  </div>
</div>

<div id="container-column" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
  <div id="container-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Border:
      </label>
      <input type="number" id="color-red-border-container" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-border-container" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-border-container" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Transparency:
      </label>
      <input type="number" id="color-red-transparency-container" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Opacity"/>
    </div>

    <div id="save-container-settings" class="toolbar-column-btns" style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save Container Settings
    </div>

  </div>
</div>

<div id="topic-chat-column" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
  <div id="topic-chat-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">AccID:
      </label>
      <input type="number" id="color-red-accid-topic-chat" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-accid-topic-chat" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-accid-topic-chat" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Username:
      </label>
      <input type="number" id="color-red-username-topic-chat" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-username-topic-chat" class="yourfov" style="  margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-username-topic-chat" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Text:
      </label>
      <input type="number" id="color-red-text-topic-chat" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-text-topic-chat" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-text-topic-chat" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
      <label for="color-green" class="yourfov">Text Container Color:
      </label>
      <input type="number" id="color-red-text-container-topic-chat" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Red"/>
      <input type="number" id="color-green-text-container-topic-chat" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Green"/>
      <input type="number" id="color-blue-text-container-topic-chat" class="yourfov" style="margin-left: 1vw;" max="255" placeholder="Blue"/>
    </div>

    <div id="save-topic-chat-settings" class="toolbar-column-btns" style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save Settings
    </div>

  </div>
</div>

  </body>

    <script>


      const APP_METADATA = {
        name: "PlanNet",
        description: "A Hashinals application using WalletConnect via Kiloscribe",
        url: "https://kiloscribe.com/",
        icons: ["https://kiloscribe.com/api/inscription-cdn/0.0.4819119"],
      };

      const PROJECT_ID = "fdd65bec25e85908fecf7561fe42b41f";

      let globalAccountId; // Declare an external variable to hold the accountId

      class Loader {
            constructor(totalCheckpoints) {
                this.totalCheckpoints = totalCheckpoints;
                this.currentCheckpoint = 0;
                this.progressBar = document.getElementById('progressBar');
                this.percentageText = document.getElementById('percentageText');
                this.loaderContainer = document.getElementById('loaderContainer');
                this.mainContent = document.getElementById('mainContent');
            }

            updateProgress() {
                this.currentCheckpoint++;
                const progress = Math.round((this.currentCheckpoint / this.totalCheckpoints) * 100);
                this.progressBar.style.width = progress + '%';
                this.percentageText.textContent = progress + '%';

                if (this.currentCheckpoint >= this.totalCheckpoints) {
                    setTimeout(() => {
                        this.loaderContainer.classList.add('hidden');
                    }, 500); // Small delay for smooth transition
                }
            }
        }

                // Initialize loader with number of checkpoints
                const loader = new Loader(10); // Set to number of checkpoints you want


                        // Simulate your code with checkpoints
        window.onload = () => {
          loader.updateProgress();





      window.HCSReady = async function () {

        const sdk = window.HashinalsWalletConnectSDK;
        const maplibregl = window.maplibregl;
        const Supercluster = window.Supercluster;
        const THREE = window.THREE;
        const scene = new THREE.Scene();


        async function ensureDracoLoaderReady() {
          for (let attempt = 1; attempt <= 5; attempt++) {
            if (typeof THREE !== 'undefined' && typeof THREE.DRACOLoader !== 'undefined') {
              try {
                new THREE.DRACOLoader();
                return true;
              } catch (e) {
              }
            }
            await new Promise(resolve => setTimeout(resolve, 200));
          }
        }

        await ensureDracoLoaderReady();

// Global variables
let initialTopicId = ''; // Will be set by extractTopicId
const defaultTopicId = '0.0.9609912';

// Async function to extract topic ID from URL
async function extractTopicId() {
  const path = window.location.pathname;
  const userInput = path && path !== '/' ? path.slice(1) : '';
  
  let topicId;
  if (userInput.startsWith('0.0.')) {
    topicId = userInput; // Use the URL path directly if it starts with '0.0.'
  } else {
    // Search for userInput in loadedDomains
    let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
    if (domainEntry && domainEntry.lastMessage) {
      topicId = domainEntry.lastMessage.topic; // Use topic from lastMessage
    } else {
      topicId = defaultTopicId; // Fallback to defaultTopicId if no match
    }
  }

  const loadColumn = document.getElementById("load-column");
    loadColumn.style.display = "block";
    const inputarea = document.getElementById("input-field");
    inputarea.value = '';
    inputarea.value = topicId;
    adjustTextareaHeight(inputarea);

  initialTopicId = topicId; // Set global variable
  console.log('Topic ID:', initialTopicId);
  return initialTopicId; // Return for use in async flows
}


        // Define SelfContainedDRACOLoader inside HCSReady with explicit prototype binding
        function SelfContainedDRACOLoader() {


          // Create a base instance and extend it
          const baseLoader = Object.create(THREE.DRACOLoader.prototype);
          THREE.DRACOLoader.call(baseLoader);

          for (let prop in baseLoader) {
            if (baseLoader.hasOwnProperty(prop)) {
              this[prop] = baseLoader[prop];
              console.log(`Copied property ${prop} to this:`, this[prop]);
            }
          }

          this.decoderType = 'wasm';
          this.wasmBinary = null;
          this.jsWrapperBlob = null;
          this.jsWrapperUrl = null;
          this.jsDecoderBlob = null;
          this.jsDecoderUrl = null;

          this.initBlobs();
        }

        // Ensure prototype is correctly set
        if (!THREE.DRACOLoader.prototype) {
          throw new Error('THREE.DRACOLoader prototype is undefined.');
        }

        SelfContainedDRACOLoader.prototype = Object.create(THREE.DRACOLoader.prototype);
        SelfContainedDRACOLoader.prototype.constructor = SelfContainedDRACOLoader;

        SelfContainedDRACOLoader.prototype.initBlobs = function () {
          console.log('initBlobs method called on:', this);

          if (window.DRACO_WASM_BASE64) {
            const binaryString = atob(window.DRACO_WASM_BASE64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
            this.wasmBinary = bytes.buffer;
            console.log('WASM binary set, length:', bytes.length);
          }

          if (window.DRACO_JS_BASE64) {
            const jsText = atob(window.DRACO_JS_BASE64.split(',')[1]);
            this.jsWrapperBlob = new Blob([jsText], { type: 'application/javascript' });
            this.jsWrapperUrl = URL.createObjectURL(this.jsWrapperBlob);
            this.jsDecoderBlob = this.jsWrapperBlob;
            this.jsDecoderUrl = this.jsWrapperUrl;
            console.log('JS wrapper URL created:', this.jsWrapperUrl);
          } else {
            this.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
          }
        };

        SelfContainedDRACOLoader.prototype.setDecoderPath = function (path) {
          console.log('setDecoderPath called with path:', path);
          this.decoderPath = path;
        };

        SelfContainedDRACOLoader.prototype.getDecoderModule = function () {
          console.log('getDecoderModule called on:', this);
          if (this.decoderModule) {
            console.log('Returning cached decoder module');
            return Promise.resolve(this.decoderModule);
          }

          return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = this.decoderType === 'wasm' ? this.jsWrapperUrl : this.jsDecoderUrl || `${this.decoderPath}draco_wasm_wrapper.js`;
            console.log('Loading decoder script from:', script.src);
            script.onload = () => {
              console.log('Decoder script loaded');
              if (typeof DracoDecoderModule !== 'undefined') {
                const moduleConfig = this.decoderType === 'wasm' ? { wasmBinary: this.wasmBinary } : {};
                DracoDecoderModule(moduleConfig).then((module) => {
                  this.decoderModule = module;
                  console.log('Decoder module initialized:', module);
                  resolve(module);
                }).catch(reject);
              } else {
                console.error('DracoDecoderModule not exposed');
                reject(new Error('DracoDecoderModule not exposed'));
              }
            };
            script.onerror = (e) => {
              console.error('Failed to load decoder script:', e);
              reject(e);
            };
            document.head.appendChild(script);
          });
        };

        SelfContainedDRACOLoader.prototype.dispose = function () {
          console.log('dispose called on:', this);
          if (typeof THREE.DRACOLoader.prototype.dispose === 'function') {
            THREE.DRACOLoader.prototype.dispose.call(this);
            console.log('Base dispose called');
          }
          if (this.jsWrapperUrl) {
            URL.revokeObjectURL(this.jsWrapperUrl);
            console.log('Revoked jsWrapperUrl');
          }
          if (this.jsDecoderUrl && this.jsDecoderUrl !== this.jsWrapperUrl) {
            URL.revokeObjectURL(this.jsDecoderUrl);
            console.log('Revoked jsDecoderUrl');
          }
        };

        // Expose globally, but only if not already defined
        if (!window.SelfContainedDRACOLoader) {
          window.SelfContainedDRACOLoader = SelfContainedDRACOLoader;
        }

        let dracoLoader;
        try {
          dracoLoader = new SelfContainedDRACOLoader();
        } catch (e) {
          dracoLoader = new THREE.DRACOLoader();
          dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
        }

const ufoLoader = new THREE.GLTFLoader();
ufoLoader.setDRACOLoader(dracoLoader);
let currentUfoModel = null;
let timeoutForToolbarLoad = true;

async function updateAccountInfo(accountId, balance) {
if (!accountId) {
isLoggedIn = false;
  document.getElementById("connect-wallet-btn").style.display ="block";
  document.getElementById("disconnect-wallet-btn").style.display ="none";
  document.getElementById("account-id").textContent = ``;
  document.getElementById("crosshair").style.display = "block";
  document.getElementById("connect-wallet-btn").addEventListener("click", () => {
    document.getElementById("crosshair").style.display = "none";
    setTimeout(() => {
        document.getElementById("crosshair").style.display = "block";
    }, 15000);
  });
  if (isLoggedIn === false) {
  extractTopicId();
  handleAllMessages();
  connectWallet();
  }
  document.getElementById("toolbar-load").addEventListener("click", debounce(async () => {
  if (isLoggedIn === false) {
    if (timeoutForToolbarLoad === true) {
      timeoutForToolbarLoad = false;
      await handleAllMessages();
    }}
    setTimeout(() => {
      timeoutForToolbarLoad = true;
    }, 2000);
  }, 500));
  return;
}

isLoggedIn = true;
  document.getElementById("account-id").textContent = `Acc: ${accountId}`;
  document.getElementById("connect-wallet-btn").style.display = "none";
  document.getElementById("disconnect-wallet-btn").style.display ="block";
  document.getElementById("crosshair").style.display = "block";
  globalAccountId = accountId;
  const profileObjectUrl = await loadProfileObject();
  const profileObjectCrosshair = await loadProfileCrosshair();
  const profileObjectSettings = await loadProfileSettings();
  const profileObjectPopup = await loadProfilePopup();
  const profileMainButton = await loadMainButtonSettings();
  const profileMarker = await loadMarkerSettings();
  const profileButtonInput = await loadButtonInputSettings();
  const profileContainer = await loadContainerSettings();
  const profileTopicChat = await loadTopicChatSettings();
  const modelUrl = profileObjectSettings.length > 0 && profileObjectSettings[0].urls && profileObjectSettings[0].urls.length > 0
    ? profileObjectSettings[0].urls[0]
    : defaultModelUrl;
  if (isLoggedIn === true) {
    debounce(async () => {
  extractTopicId();
  await loadUfoModel(modelUrl); // Load the model using the determined URL
  confirmNFTFunction(accountId);
  }, 1000);
  }
  document.getElementById("toolbar-load").addEventListener("click", debounce(async () => {
    if (isLoggedIn === true) {
    if (timeoutForToolbarLoad === true) {
      timeoutForToolbarLoad = false;
      await confirmNFTFunction(accountId);
    }}
    setTimeout(() => {
      timeoutForToolbarLoad = true;
    }, 2000);
  }, 500));
  await extractAccountId();
}

loader.updateProgress();

document.getElementById('upload-to-ipfs-button').disabled = true;

let helia = null;
let fs = null;

async function initHelia() {

  try {

    const bootstrapList = [
      '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN',
      '/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',
      '/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ',
      '/dns4/nyc-1.bootstrap.libp2p.io/tcp/443/wss/p2p/QmSoLMeWqB7YGVLJN3pNLQpmmEk35vGrvXL8kT3uNoHbeG',
      '/dns4/ams-1.bootstrap.libp2p.io/tcp/443/wss/p2p/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd',
    ];

    const noise = window.ChainsafeLibp2PNoise?.noise?.() || window.Libp2p?.noise?.();

    const kuboClient = window.KuboRpcClient.create({
      url: 'https://delegated-ipfs.dev/api/v0'
    });

    const libp2pOptions = {
      addresses: {
        listen: [
      '/ip4/0.0.0.0/tcp/0',
      '/ip4/0.0.0.0/tcp/0/ws',
      '/ip4/0.0.0.0/udp/0/webrtc-direct',
      '/ip6/::/tcp/0',
      '/ip6/::/tcp/0/ws',
      '/ip6/::/udp/0/webrtc-direct',
      '/p2p-circuit'
      ],
        announce: [
          '/p2p-circuit/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ'
        ],
      },
      transports: [
        window.Libp2p.webRTC(
          { iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
                          ]
      }),
        window.Libp2p.webSockets(),
        window.Libp2p.circuitRelayTransport({ discoverRelays: 10, reservationConcurrency: 5, hop: { enabled: true } })
      ],
      connectionEncryption: noise ? [noise] : [],
      connectionManager: { minConnections: 2, maxConnections: 100 },
      peerDiscovery: [
        window.Libp2p.bootstrap({ list: bootstrapList, interval: 1000 }),
      ],
      services: {
        identify: window.Libp2p.identify(),
        dht: window.Libp2p.kadDHT({
          clientMode: true,
          kBucketSize: 20,
          router: window.Libp2PDelegatedPeerRouting.delegatedPeerRouting(kuboClient),
        }),
        ping: window.Libp2p.ping(),
      },
    };

    helia = await window.Helia.createHelia({ Libp2p: libp2pOptions });
    fs = window.HeliaUnixfs.unixfs(helia);


    await helia.libp2p.services.dht.start();

    console.log('Helia Peer ID:', helia.libp2p.peerId.toString());

    setInterval(() => {
      const peers = helia.libp2p.getPeers();
      console.groupCollapsed('Number of connected peers:', peers.length);
      console.log('Peers:', peers);
      console.groupEnd();
      console.log('DHT routing table size:', helia.libp2p.services.dht.routingTable?.size || 'N/A');
    }, 5000);

    document.getElementById('upload-to-ipfs-button').disabled = false;
  } catch (error) {
    console.error('Initialization failed:', error);
    document.getElementById('cid-output').textContent = `Initialization failed: ${error.message}`;
  }
}

initHelia();

document.getElementById('upload-to-ipfs-button').addEventListener('click', async () => {
  await upload();
});

async function upload() {
  const fileInput = document.getElementById('fileInput');
  const file = fileInput.files[0];
  if (!file) {
    alert('No file selected');
    return;
  }
  if (!fs || !helia) {
    document.getElementById('cid-output').textContent = 'Helia not initialized.';
    return;
  }

  try {
    const fileArrayBuffer = await file.arrayBuffer();
    const fileBytes = new Uint8Array(fileArrayBuffer);
    console.log('File size:', fileBytes.length);

    const cid = await fs.addBytes(fileBytes);
    console.log('Uploaded and pinned locally, CID:', cid.toString());
    document.getElementById('cid-output').textContent = `w8 for it to upload to the network`;

    adjustTextareaHeight(document.getElementById('cid-output'));

    await helia.pins.add(cid);
    let announced = false;
    const maxRetries = 10;
    let retryCount = 0;
    const baseTimeout = 150000; // 150s

    while (!announced && retryCount < maxRetries) {
      try {
        console.log(`Announcing CID to DHT (attempt ${retryCount + 1}/${maxRetries})`);
        const announcePromise = helia.routing.provide(cid);
        const globalTimeout = new Promise((_, reject) => 
          setTimeout(() => reject(new Error(`DHT provide timed out after ${baseTimeout/1000}s`)), baseTimeout)
        );
        await Promise.race([announcePromise, globalTimeout]);
        console.log('Announced CID to DHT successfully');
        announced = true;
      } catch (error) {
        console.error(`DHT announcement failed (attempt ${retryCount + 1}):`, error);
        retryCount++;
        if (retryCount < maxRetries) {
          const backoff = Math.pow(2, retryCount) * 5000; // 5s, 10s, 20s
          console.log(`Retrying after ${backoff/1000}s...`);
          await new Promise(resolve => setTimeout(resolve, backoff));
        }
      }
    }

    if (announced) {
      const multiaddrs = helia.libp2p.getMultiaddrs();
      console.log('Node multiaddresses:', multiaddrs.map(addr => addr.toString()));
      document.getElementById('cid-output').textContent = ``;
      document.getElementById('cid-output').textContent = `successfully uploaded to the network CID: ${cid.toString()}`;
      adjustTextareaHeight(document.getElementById('cid-output'));
    }

    if (maxretries === retryCount) {
      document.getElementById('cid-output').textContent = `Failed to upload to the network`;
      adjustTextareaHeight(document.getElementById('cid-output'));
    }

  } catch (error) {
    console.error('Error:', error);
    document.getElementById('cid-output').textContent = `Failed: ${error.message}`;
  }
}

document.getElementById('fetch-from-ipfs-button').addEventListener('click', async () => {
  await fetchContent();
});


async function fetchContent() {
  const cidInput = document.getElementById('cid-input').value.trim();
  if (!cidInput) {
    alert('No CID provided');
    return;
  }
  if (!fs || !helia) {
    document.getElementById('cid-output').textContent = 'Helia not initialized.';
    return;
  }

  let cid;
  try {
    cid = window.Multiformats.CID.parse(cidInput);
  } catch (error) {
    document.getElementById('cid-output').textContent = `Invalid CID: ${error.message}`;
    return;
  }

  const contentType = document.getElementById('content-type')?.value || 'image';

  try {
    let chunks = [];

    try {

      const gateways = [
  'https://dweb.link/ipfs/',
  'https://ipfs.io/ipfs/',
  'https://cloudflare-ipfs.com/ipfs/',
];
for (const gateway of gateways) {
  try {
    const gatewayUrl = `${gateway}${cid.toString()}`;
    console.log(`Attempting to fetch from: ${gatewayUrl}`);
    const response = await window.HeliaVerifiedFetch.verifiedFetch(gatewayUrl, {
      timeout: 30000,
    });
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    const data = new Uint8Array(await response.arrayBuffer());
    chunks = [data];
    console.log(`Successfully fetched from ${gateway}`);
    break;
  } catch (gatewayError) {
    console.warn(`Gateway ${gateway} failed: ${gatewayError.message}`);
    if (gateway === gateways[gateways.length - 1]) {
      throw new Error(`All gateways failed: ${gateways.join(', ')}`);
    }
  }
}


      if (chunks.length === 0) {
        throw new Error('Failed to fetch CID from any provider or gateway');
      }

    } catch (error) {
      console.error('Fetch error:', error);
      document.getElementById('cid-output').textContent = `Fetch failed: ${error.message}`;
      adjustTextareaHeight(document.getElementById('cid-output'));
    }

    console.log('chunks', chunks);


    // Step 2: Process and display the fetched content
    const data = new Uint8Array(chunks.reduce((acc, chunk) => acc.concat([...chunk]), []));
    console.log('Fetched file size:', data.length);
    document.getElementById('cid-output').textContent = `Fetched: ${cidInput}`;
    adjustTextareaHeight(document.getElementById('cid-output'));

    let mimeType;
    let displayElement;
    if (contentType === 'video') {
      mimeType = 'video/*';
      displayElement = document.createElement('video');
      displayElement.controls = true;
      displayElement.style.maxWidth = '100%';
    } else {
      mimeType = 'image/*';
      displayElement = document.createElement('img');
      displayElement.style.maxWidth = '100%';
    }

    const blob = new Blob([data], { type: mimeType });
    const url = URL.createObjectURL(blob);
    displayElement.src = url;
    displayElement.alt = `${contentType} from IPFS`;

    const container = document.getElementById('image-container') || document.body;
    container.innerHTML = '';
    container.appendChild(displayElement);

    // Step 3: Pin the content and announce as provider
    try {
        await helia.pins.add(cid);

        let announced = false;
        const maxRetries = 10;
        let retryCount = 0;

        while (!announced && retryCount < maxRetries) {
          try {
            console.log(`Announcing CID to DHT (attempt ${retryCount + 1}/${maxRetries})`);
            const announcePromise = helia.libp2p.services.dht.provide(cid);
            const baseTimeout = retryCount === 0 ? 30000 : (retryCount === 1 || retryCount === 2) ? 150000 : Math.pow(2, retryCount - 1) * 5000;
            const globalTimeout = new Promise((_, reject) =>
              setTimeout(() => reject(new Error(`DHT provide timed out after ${baseTimeout/1000}s`)), baseTimeout)
            );
            await Promise.race([announcePromise, globalTimeout]);
            console.log('Announced CID to DHT successfully');
            announced = true;
          } catch (error) {
            console.error(`DHT announcement failed (attempt ${retryCount + 1}):`, error);
            retryCount++;
            if (retryCount < maxRetries) {
              const backoff = retryCount === 1 ? 30000 : (retryCount === 2 || retryCount === 3) ? 150000 : Math.pow(2, retryCount - 1) * 5000;
              console.log(`Retrying after ${backoff/1000}s...`);
              await new Promise(resolve => setTimeout(resolve, backoff));
            }
          }
        }
      
    } catch (pinError) {
      console.error('Pinning failed:', pinError);
      document.getElementById('cid-output').textContent += `\nPinning failed: ${pinError.message}`;
      adjustTextareaHeight(document.getElementById('cid-output'));
    }
  } catch (error) {
    console.error('Fetch error:', error);
    document.getElementById('cid-output').textContent = `Fetch failed: ${error.message}`;
    adjustTextareaHeight(document.getElementById('cid-output'));
  }
}

document.getElementById("load-msgs-from-ids-button").addEventListener("click", async () => {
  const ids = document.getElementById("load-msgs-from-ids").value.toLowerCase();
  const idsArray = ids.split(",").map(id => id.trim()).filter(id => id.length > 0); // Trim whitespace and filter out empty strings

  idsArray.forEach(id => {
    if (!id.startsWith("0.0.")) {
      const domainEntry = loadedDomains.find(domain => domain.domain === id); // Assuming loadedDomains is an array of objects with an 'id' property
      idsArray.splice(idsArray.indexOf(id), 1); // Remove the id from idsArray
      if (domainEntry) {
      idsArray.push(domainEntry.lastMessage.topic); // Add the domain entry to idsArray
      }
    }
  });

  await handleAllMessages();

  geojson.features = [];
      // Filter geojson.features based on the specified payers
  const filteredFeatures = geojson.features.filter(feature => {
    const match = idsArray.includes(feature.payer);
    return match;
  });

  const filteredPolygons = polygons.filter(polygon => {
    const match = idsArray.includes(polygon.payer);
    return match;
  });



  geojson.features = filteredFeatures;
  polygons.length = 0; // Clear existing polygons
  polygons.push(...filteredPolygons); // Add filtered polygons



  setTimeout(() => {
    existingMarkers.forEach(marker => marker.remove());
    existingMarkers = [];
  }, 250);

  map.getStyle().layers.forEach(layer => {
    if (layer.id.includes('-layer')) {
    map.removeLayer(layer.id);
  }
  });

  const sourceIds = Object.keys(map.getStyle().sources);
      sourceIds.forEach(sourceId => {
      if (sourceId.includes('-source')) {
      map.removeSource(sourceId);
    }
  });


      if (geojson.features.length > 0) {
          index.load(geojson.features);
          updateClusters(); // Assuming you have a function to update clusters
        }
        
      if (polygons.length > 0) {
          polygons.forEach(polygon => {
          addPolygonWithImageFill(map, polygon);
      });
    }
});

loader.updateProgress();

document.getElementById("button4").addEventListener("click", async () => {

  const domain = document.getElementById("toolbar-input").value.toLowerCase();
  const domainObject = loadedDomains.find(d => d.domain === domain);

  if (domainObject) {

    console.log("domainObject", domainObject);
    const currentTime = Date.now() / 1000; // Get current time in seconds

    const timeLeftInSeconds = domainObject.addedTime - currentTime;

    // Calculate days, hours, minutes, and seconds
    const days = Math.floor(timeLeftInSeconds / (24 * 3600));
    const hours = Math.floor((timeLeftInSeconds % (24 * 3600)) / 3600);
    const minutes = Math.floor((timeLeftInSeconds % 3600) / 60);
    const seconds = Math.floor(timeLeftInSeconds % 60);

    const formattedTimeLeft = `${days}d ${hours}h ${minutes}m ${seconds}s`;

    document.getElementById("domain-time-left").textContent = `Time left: ${formattedTimeLeft}`;
  } else {
    console.warn("Domain not found in loadedDomains.");
    document.getElementById("domain-time-left").textContent = 'no one uses this domain';
  }
});

document.getElementById('go-to-top-msgs').addEventListener('click', function() {

    const container = document.getElementById('topic-chat-container');
    container.scrollTop = 0;
  });


  let storedMessages = []; // Declare an external array to store messages

let colorForAccidTopicChat = 'rgb(128, 0, 128)'; // Default: purple (#800080) for payerInfo
let colorForUsernameTopicChat = 'rgb(255, 255, 255)'; // Default: white (#FFFFFF) for username
let colorForTextTopicChat = 'rgb(255, 255, 255)'; // Default: black for message text

document.getElementById("load-msgs-from").addEventListener("click", async () => {
  try {
    let userInput = document.getElementById("topic-chat-topic-id").value.toLowerCase();
    let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
    let topicId;

    if (domainEntry && domainEntry.lastMessage) {
      topicId = domainEntry.lastMessage.topic;
    } else {
      topicId = userInput;
    }

    const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          const memo = topicInfo.memo;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
            }
          });

    const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

    if (!result || !Array.isArray(result.messages)) {
      console.log("No messages found or result is not an array.");
      return [];
    }

    const profilePictures = await loadProfilePicture(); // Load profile pictures
    const usernames = await loadUsername(); // Load usernames
    const click2url = await loadCLICK2URL();
    const topic2pic = await loadTOPIC2PIC();


    let allMessages = ''; // Initialize an empty string to hold all messages

    let previousPayer = null; // Track the previous payer

    const topicActions = new Map();

    const loadedNFTsForTopicChat = [];


    for (let index = 0; index < result.messages.length; index++) {
      const message = result.messages[index];
      try {
        let parsedMessage = message;
        if (typeof message === 'string') {
          parsedMessage = JSON.parse(message);
        }
        const timestamp = message.timestamp || Date.now(); // Use message timestamp or current time

        if (parsedMessage.addTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
        const nfts = parsedMessage.addTopicChatNFT.split(',').map(nft => nft.trim());
        nfts.forEach(nft => {
          if (nft.startsWith("0.0.") && !loadedNFTsForTopicChat.includes(nft)) { // Check if NFT starts with "0.0."
            loadedNFTsForTopicChat.push(nft);
          }
        });
      }

      if (parsedMessage.removeTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
        const nft = parsedMessage.removeTopicChatNFT.trim();
        if (nft.startsWith("0.0.")) { // Check if NFT starts with "0.0."
          const index = loadedNFTsForTopicChat.indexOf(nft);
          if (index !== -1) {
            loadedNFTsForTopicChat.splice(index, 1);
          }
        }
      }
      } catch (messageError) {
        console.error(`Error processing message ${index}:`, messageError);
      }
    }


    if (loadedNFTsForTopicChat.length > 0) {
  console.log("loadedNFTsForTopicChat", loadedNFTsForTopicChat);
}

// Process messages
for (let index = 0; index < result.messages.length; index++) {
  const message = result.messages[index];
  try {
    let parsedMessage = message;
    if (typeof message === 'string') {
      parsedMessage = JSON.parse(message);
    }

    const payer = parsedMessage.payer || 'Unknown';

    // Check if the payer owns any NFT from loadedNFTsForTopicChat
    let payerHasNFT = false;
    if (loadedNFTsForTopicChat.length > 0) {
      for (const item of loadedNFTsForTopicChat) {
        const checkIfUserHasNFT = await sdk.getAccountNFTs(payer, item);
        if (checkIfUserHasNFT.length > 0) {
          payerHasNFT = true;
          break;
        }
      }
    } else {
      payerHasNFT = true; // If no NFTs to check, allow all messages
    }

    if (payerHasNFT && parsedMessage.userMessage) {
      const userMessage = parsedMessage.userMessage;

const payerImage = profilePictures[payer]?.url || 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';

// Function to validate URL
function isValidUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
}

// Check if payerImage is valid, if not use fallback
const validPayerImage = isValidUrl(payerImage) ? payerImage : 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';


      const timestamp = new Date(parsedMessage.created).toLocaleString('en-US', {
  hour12: false,
  year: 'numeric',
  month: '2-digit',
  day: '2-digit',
  hour: '2-digit',
  minute: '2-digit',
  second: '2-digit'
}); // Format as MM/DD/YYYY HH:MM:SS

const payerInfo = message.payer ? `${message.payer}` : 'Anonymous';
              const username = message.payer && usernames[message.payer] ?
                ` ${usernames[message.payer].username}` :
                '';

                const click2link= message.payer && click2url[message.payer] ?
                ` ${click2url[message.payer].click2url}` :
                '';

const displayHeader = 
`<a href="https://explore.hashpack.app/${payerInfo}" target="_blank" style="color: ${colorForAccidTopicChat}; text-decoration: none;">${payerInfo}</a>
${click2link ? `<a href="${click2link}" target="_blank" style="color: ${colorForUsernameTopicChat};
text-decoration: none;">${username}</a>` : `<span style="color: ${colorForUsernameTopicChat};">${username}</span>`}`;

storedMessages.push(parsedMessage);

if (payer !== previousPayer) {
  allMessages += `<div style="display: flex; align-items: center; margin-top: 0.1em;">
    <img src="${validPayerImage}" alt="Profile photo"
    style="width: 2em; height: 2em; margin-right: 0.5em; border-radius: 1em; cursor: pointer;"
    onclick="loadTOPIC4PIC('${message.payer}');">
                    <div style="display: flex; flex-direction: column; justify-content: center;">
                      <div>${displayHeader}</div>
                      <span style="font-size: 0.8em; color: gray;">${timestamp}</span>
                      <div style="color: ${colorForTextTopicChat};">${userMessage}</div>
                    </div>
                  </div><br>`;
} else {
  allMessages += `<div style="display: flex; align-items: center; margin-left: 2.5em; margin-top: -1.25em;">
                    <div style="color: ${colorForTextTopicChat};">${userMessage}</div>
                  </div><br>`;
}
      previousPayer = payer; // Update the previous payer
    } else {
      console.warn(`Message ${index} is missing payer or data.`);
    }
  } catch (messageError) {
    console.error(`Error processing message ${index}:`, messageError);
  }
}

const chatContainer = document.getElementById('topic-chat-container');
  let startY, scrollTop;

  chatContainer.addEventListener('touchstart', (e) => {
    startY = e.touches[0].pageY - chatContainer.offsetTop;
    scrollTop = chatContainer.scrollTop;
  });

  chatContainer.addEventListener('touchmove', (e) => {
    const y = e.touches[0].pageY - chatContainer.offsetTop;
    const walk = (y - startY) * 2; // Adjust the multiplier for sensitivity
    chatContainer.scrollTop = scrollTop - walk;
    e.preventDefault(); // Prevent default touch behavior
  });

  const messagesContainer = document.getElementById('messages-from-topic-chat');

messagesContainer.addEventListener('touchstart', (e) => {
  startY = e.touches[0].pageY - messagesContainer.offsetTop;
  scrollTop = messagesContainer.scrollTop;
  e.stopPropagation(); // Stop the event from bubbling up
});

messagesContainer.addEventListener('touchmove', (e) => {
  const y = e.touches[0].pageY - messagesContainer.offsetTop;
  const walk = (y - startY) * 2; // Adjust the multiplier for sensitivity
  messagesContainer.scrollTop = scrollTop - walk;
  e.preventDefault(); // Prevent default touch behavior
  e.stopPropagation(); // Stop the event from bubbling up
});


const messageContainer = document.getElementById("messages-from-topic-chat");
messageContainer.innerHTML = allMessages;
adjustTextareaHeight(messageContainer);

// Scroll to the bottom of the message container
messageContainer.scrollTop = messageContainer.scrollHeight;

  } catch (error) {
    console.error("Error setting rules:", error);
  }
});

document.getElementById("topic-msgs-filter").addEventListener("click", async () => {
  const fromDateInput = document.getElementById("from-mmddyyyy").value;
  const toDateInput = document.getElementById("to-mmddyyyy").value;

  if (!fromDateInput || !toDateInput) {
    console.error("Please provide both from and to dates.");
    return;
  }

  const profilePictures = await loadProfilePicture(); // Load profile pictures
  const usernames = await loadUsername(); // Load usernames
  const click2url = await loadCLICK2URL();
  const topic2pic = await loadTOPIC2PIC();

  const fromDate = new Date(fromDateInput.slice(4, 8), fromDateInput.slice(0, 2) - 1, fromDateInput.slice(2, 4));
  const toDate = new Date(toDateInput.slice(4, 8), toDateInput.slice(0, 2) - 1, toDateInput.slice(2, 4));

  console.log("fromDate", fromDate);
  console.log("toDate", toDate);

  // Adjust toDate to include the entire day
  toDate.setHours(23, 59, 59, 999);

  const filteredMessages = storedMessages.filter(message => {
    const messageDate = new Date(message.created); // Parse the created date string
    return messageDate >= fromDate && messageDate <= toDate;
  });

  let filteredMessagesHtml = '';
  let previousPayer = null;


  filteredMessages.forEach(parsedMessage => {
    const userMessage = parsedMessage.userMessage;
    const payer = parsedMessage.payer || 'Unknown';
    const payerImage = profilePictures[payer]?.url || 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';

// Function to validate URL
function isValidUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
}

// Check if payerImage is valid, if not use fallback
const validPayerImage = isValidUrl(payerImage) ? payerImage : 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';
    const timestamp = new Date(parsedMessage.created).toLocaleString('en-US', {
  hour12: false,
  year: 'numeric',
  month: '2-digit',
  day: '2-digit',
  hour: '2-digit',
  minute: '2-digit',
  second: '2-digit'
}); // Format as MM/DD/YYYY HH:MM:SS

const payerInfo = message.payer ? `${message.payer}` : 'Anonymous';
              const username = message.payer && usernames[message.payer] ?
                ` ${usernames[message.payer].username}` :
                '';

                const click2link= message.payer && click2url[message.payer] ?
                ` ${click2url[message.payer].click2url}` :
                '';

const displayHeader = 
`<a href="https://explore.hashpack.app/${payerInfo}" target="_blank" style="color: ${colorForAccidTopicChat}; text-decoration: none;">${payerInfo}</a>
${click2link ? `<a href="${click2link}" target="_blank" style="color: ${colorForUsernameTopicChat};
text-decoration: none;">${username}</a>` : `<span style="color: ${colorForUsernameTopicChat};">${username}</span>`}`;

      storedMessages.push(parsedMessage);



      if (payer !== previousPayer) {
  allMessages += `<div style="display: flex; align-items: center; margin-top: 0.1em; border-color: ${colorForTextContainerTopicChat};">
    <img src="${validPayerImage}" alt="Profile photo"
    style="width: 2em; height: 2em; margin-right: 0.5em; border-radius: 1em; cursor: pointer;"
    onclick="loadTOPIC4PIC('${message.payer}');">
                    <div style="display: flex; flex-direction: column; justify-content: center;">
                      <div>${displayHeader}</div>
                      <span style="font-size: 0.8em; color: gray;">${timestamp}</span>
                      <div style="color: ${colorForTextTopicChat};">${userMessage}</div>
                    </div>
                  </div><br>`;
} else {
  allMessages += `<div style="display: flex; align-items: center; margin-left: 2.5em; margin-top: -1.25em; border-color: ${colorForTextContainerTopicChat};">
                    <div style="color: ${colorForTextTopicChat};">${userMessage}</div>
                  </div><br>`;
}
      previousPayer = payer; // Update the previous payer
  });

  const messageContainer = document.getElementById("messages-from-topic-chat");
  messageContainer.innerHTML = filteredMessagesHtml;
  adjustTextareaHeight(messageContainer);
  messageContainer.scrollTop = messageContainer.scrollHeight;

});

document.getElementById("topic-msgs-filter-time").addEventListener("click", async () => {
  const fromDateInput = document.getElementById("from-mmddyyyy").value;
  const toDateInput = document.getElementById("to-mmddyyyy").value;
  const fromTimeInput = document.getElementById("from-hhmmss").value;
  const toTimeInput = document.getElementById("to-hhmmss").value;

  if (!fromDateInput || !toDateInput || !fromTimeInput || !toTimeInput) {
    console.error("Please provide both from and to dates and times.");
    return;
  }

  const profilePictures = await loadProfilePicture(); // Load profile pictures
  const usernames = await loadUsername(); // Load usernames
  const click2url = await loadCLICK2URL();
  const topic2pic = await loadTOPIC2PIC();

  const fromDate = new Date(
    fromDateInput.slice(4, 8),
    fromDateInput.slice(0, 2) - 1,
    fromDateInput.slice(2, 4),
    fromTimeInput.slice(0, 2), // Hours
    fromTimeInput.slice(2, 4), // Minutes
    fromTimeInput.slice(4, 6)  // Seconds
  );

  const toDate = new Date(
    toDateInput.slice(4, 8),
    toDateInput.slice(0, 2) - 1,
    toDateInput.slice(2, 4),
    toTimeInput.slice(0, 2), // Hours
    toTimeInput.slice(2, 4), // Minutes
    toTimeInput.slice(4, 6)  // Seconds
  );

  console.log("fromDate", fromDate);
  console.log("toDate", toDate);

  const filteredMessages = storedMessages.filter(message => {
    const messageDate = new Date(message.created); // Parse the created date string
    return messageDate >= fromDate && messageDate <= toDate;
  });

  let filteredMessagesHtml = '';
  let previousPayer = null;

  filteredMessages.forEach(parsedMessage => {
    const userMessage = parsedMessage.userMessage;
    const payer = parsedMessage.payer || 'Unknown';
    const payerImage = profilePictures[payer]?.url || 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';

// Function to validate URL
function isValidUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
}

// Check if payerImage is valid, if not use fallback
const validPayerImage = isValidUrl(payerImage) ? payerImage : 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';
    const timestamp = new Date(parsedMessage.created).toLocaleString('en-US', {
  hour12: false,
  year: 'numeric',
  month: '2-digit',
  day: '2-digit',
  hour: '2-digit',
  minute: '2-digit',
  second: '2-digit'
}); // Format as MM/DD/YYYY HH:MM:SS

const payerInfo = message.payer ? `${message.payer}` : 'Anonymous';
              const username = message.payer && usernames[message.payer] ?
                ` ${usernames[message.payer].username}` :
                '';

                const click2link= message.payer && click2url[message.payer] ?
                ` ${click2url[message.payer].click2url}` :
                '';

                const displayHeader = 
`<a href="https://explore.hashpack.app/${payerInfo}" target="_blank" style="color: ${colorForAccidTopicChat}; text-decoration: none;">${payerInfo}</a>
${click2link ? `<a href="${click2link}" target="_blank" style="color: ${colorForUsernameTopicChat};
text-decoration: none;">${username}</a>` : `<span style="color: ${colorForUsernameTopicChat};">${username}</span>`}`;

      // Store the message in the external array
      storedMessages.push(parsedMessage);



      if (payer !== previousPayer) {
  allMessages += `<div style="display: flex; align-items: center; margin-top: 0.1em; border-color: ${colorForTextContainerTopicChat};">
    <img src="${validPayerImage}" alt="Profile photo"
    style="width: 2em; height: 2em; margin-right: 0.5em; border-radius: 1em; cursor: pointer;"
    onclick="loadTOPIC4PIC('${message.payer}');">
                    <div style="display: flex; flex-direction: column; justify-content: center;">
                      <div>${displayHeader}</div>
                      <span style="font-size: 0.8em; color: gray;">${timestamp}</span>
                      <div style="color: ${colorForTextTopicChat};">${userMessage}</div>
                    </div>
                  </div><br>`;
} else {
  allMessages += `<div style="display: flex; align-items: center; margin-left: 2.5em; margin-top: -1.25em; border-color: ${colorForTextContainerTopicChat};">
                    <div style="color: ${colorForTextTopicChat};">${userMessage}</div>
                  </div><br>`;
}
      previousPayer = payer; // Update the previous payer
  });

  const messageContainer = document.getElementById("messages-from-topic-chat");
  messageContainer.innerHTML = filteredMessagesHtml;
  adjustTextareaHeight(messageContainer);
  messageContainer.scrollTop = messageContainer.scrollHeight;

});




let loadedDomains = [];


async function loadDomains() {
  try {
    const topicId = "0.0.9606779";

    const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

    if (!result || !Array.isArray(result.messages)) {
      console.log("No messages found or result is not an array.");
      return [];
    }

    const domainsMap = new Map();

    for (let index = 0; index < result.messages.length; index++) {
      const message = result.messages[index];
      try {
        let parsedMessage = message;
        if (typeof message === 'string') {
          parsedMessage = JSON.parse(message);
        }

        if (parsedMessage.payer && parsedMessage.domain) {
          const domain = parsedMessage.domain;
          if (!domainsMap.has(domain)) {
            domainsMap.set(domain, []);
          }
          domainsMap.get(domain).push({
            topic: parsedMessage.topic,
            domain: domain,
            payer: parsedMessage.payer,
            timestamp: parsedMessage.consensus_timestamp // or parsedMessage.timestamp
          });
        } else {
          console.warn(`Message ${index} is missing payer or domain.`);
        }
      } catch (messageError) {
        console.error(`Error processing message ${index}:`, messageError);
      }
    }

    const SECONDS_TO_ADD = 2419200;
    const currentTime = Date.now() / 1000;

    let domainsArray = Array.from(domainsMap.entries()).map(([domain, messages]) => {
      // Sort all messages for the domain by timestamp
      messages.sort((a, b) => parseFloat(a.timestamp) - parseFloat(b.timestamp));

      if (messages.length === 0) {
        return { domain, lastMessage: null, addedTime: 0 };
      }

      const firstPayer = messages[0].payer;
      const firstTimestamp = parseFloat(messages[0].timestamp);
      const initialWindowEnd = firstTimestamp + SECONDS_TO_ADD;

      // Check if firstPayer has any renewal (subsequent message) within the initial window
      const hasRenewal = messages.some((msg, idx) => idx > 0 && msg.payer === firstPayer && parseFloat(msg.timestamp) <= initialWindowEnd);

      let validPayerMessages = [];
      let startTimestamp;

      if (hasRenewal) {
        // Use firstPayer and all their messages
        validPayerMessages = messages.filter(message => message.payer === firstPayer);
        startTimestamp = firstTimestamp;
      } else {
        // Find the first takeover message from a different payer AFTER the initial window end
        let takeoverIndex = -1;
        for (let i = 1; i < messages.length; i++) {
          const msgTimestamp = parseFloat(messages[i].timestamp);
          if (messages[i].payer !== firstPayer && msgTimestamp > initialWindowEnd) {
            takeoverIndex = i;
            break;
          }
        }

        if (takeoverIndex === -1) {
          // No takeover, fall back to firstPayer with no renewal (initial period only)
          validPayerMessages = messages.filter(message => message.payer === firstPayer);
          startTimestamp = firstTimestamp;
        } else {
          // Switch to takeover payer and their messages from takeover onwards
          const takeoverPayer = messages[takeoverIndex].payer;
          startTimestamp = parseFloat(messages[takeoverIndex].timestamp);
          validPayerMessages = messages.slice(takeoverIndex).filter(message => message.payer === takeoverPayer);
        }
      }

      if (validPayerMessages.length === 0) {
        return { domain, lastMessage: null, addedTime: 0 };
      }

      // Compute addedTime starting from the startTimestamp
      let addedTime = startTimestamp + SECONDS_TO_ADD;

      // Handle sequential renewals: iterate through subsequent messages
      for (let i = 1; i < validPayerMessages.length; i++) {
        const renewalTime = parseFloat(validPayerMessages[i].timestamp);
        if (renewalTime < addedTime) {
          // Extend expiry if renewal is within current window
          addedTime = addedTime + SECONDS_TO_ADD;
        }
      }

      // Get the last message from the valid payer
      const lastMessage = validPayerMessages[validPayerMessages.length - 1];

      return {
        domain,
        lastMessage,
        addedTime
      };
    });

    // Filter out expired domains (keep only active ones where addedTime > currentTime)
    domainsArray = domainsArray.filter(item => item.addedTime > currentTime);

    return domainsArray;

  } catch (error) {
    console.error("Error in loadDomains:", error);
    return [];
  }
}

loadDomains().then(domains => {
  loadedDomains = domains.filter(domain => !domain.domain.includes("0.0."));
});


document.getElementById("copy-coordinates").addEventListener("click", () => {
  event.stopPropagation();
  const center = map.getCenter();
  const coordinates = `${center.lng.toFixed(5)},${center.lat.toFixed(5)}`;

  navigator.clipboard.writeText(coordinates).then(() => {
    }).catch(err => {
    console.error("Failed to copy coordinates:", err);
  });
});

loader.updateProgress();

// Define a default model URL
const defaultModelUrl = 'https://kiloscribe.com/api/inscription-cdn/0.0.9742046'; // Replace with your actual default model URL
await loadUfoModel(defaultModelUrl);
let BetaNFTScaleFactor = 1;

        async function connectWallet() {
          try {
            const { balance, accountId } = await sdk.connectWallet(
              PROJECT_ID,
              APP_METADATA
            );
            console.log("account info is", accountId, balance);
            updateAccountInfo(accountId, balance);
          } catch (error) {
            console.error("Failed to connect wallet:", error);
          }
        }

        async function disconnectWallet() {
          try {
            await sdk.disconnectWallet(PROJECT_ID, APP_METADATA);
            updateAccountInfo(undefined);
          } catch (error) {
            console.error("Failed to connect wallet:", error);
          }
        }

        async function initAccount() {
          const accountResponse = await sdk.initAccount(
            PROJECT_ID,
            APP_METADATA
          );

          if (accountResponse && accountResponse.accountId) {
            updateAccountInfo(
              accountResponse.accountId,
              accountResponse.balance
            );


          } else {
            console.log("Account ID not found in response");
          }
        }


initAccount()
updateAccountInfo();

document.getElementById("connect-wallet-btn").addEventListener("click", connectWallet);
document.getElementById("disconnect-wallet-btn").addEventListener("click", disconnectWallet);


async function extractAccountId() {
  const thisAccountId = globalAccountId;
  console.log("globalAccountId is", thisAccountId)
  return thisAccountId;
}


document.getElementById("submit-button-Create_New_Topic").addEventListener("click", async () => {
  try {
    const memo = document.getElementById("input-field-5-1").value || '';
    const adminKey = document.getElementById("input-field-5-2").value;
    // const fee = document.getElementById("input-field-5-3").value;
    // const tokenId = document.getElementById("input-field-5-4").value;
    // const royaltyAccount = document.getElementById("input-field-5-5").value;

    if ((memo && !adminKey) || (!memo && adminKey)) {
      console.error("Both memo and adminKey must be provided together.");
      return;
    }

    let createdTopicId;

    if (memo && adminKey) {
      createdTopicId = await window.HashinalsWalletConnectSDK.createTopic(memo, adminKey);
      } else {
      createdTopicId = await window.HashinalsWalletConnectSDK.createTopic();
    }

    console.log("createdTopicId is", createdTopicId);


    document.getElementById("input-field-5").value = createdTopicId;
    document.getElementById("input-field-2-0").value = createdTopicId;
    document.getElementById("input-field-3-0").value = createdTopicId;
    document.getElementById("input-field").value = createdTopicId;
    } catch (error) {
    console.error("Error creating topic:", error);
  }
});

function adjustTextareaHeight(textarea) {
  textarea.style.height = ''; // Reset the height
  textarea.style.height = textarea.scrollHeight + 10 + 'px'; // Set it to the scroll height
}

document.getElementById("generate-private-and-public-key").addEventListener("click", async () => {
  try {
    const { privateKey, publicKey } = await sdk.generatePrivateAndPublicKey();

    const privateKeyTextarea = document.getElementById("generated-private-key");
    const publicKeyTextarea = document.getElementById("generated-public-key");

    privateKeyTextarea.value = privateKey;

    adjustTextareaHeight(privateKeyTextarea);

    } catch (error) {
    console.error("Error creating topic:", error);
  }
});


document.getElementById("submit-button-Change_Memo").addEventListener("click", async () => {
  try {
    let userInput = document.getElementById("input-field-topic-id").value.toLowerCase();
    let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
    let topicId;

    if (domainEntry && domainEntry.lastMessage) {
      topicId = domainEntry.lastMessage.topic;
      } else {
      topicId = userInput;
    }
    const memo =document.getElementById("input-field-memo").value || '';

    let adminKey = document.getElementById("input-field-admin-key").value;

    const realfee = document.getElementById("input-field-fee").value;
    const tokenId = document.getElementById("input-field-fee-token").value;
    const royaltyAccount = document.getElementById("input-field-royal-acc").value;
    const feeScheduleKey = document.getElementById("input-field-admin-key").value;

    const fee = realfee * 1000000

    let customFees = [];

    let createdTopicId;

    if (fee && tokenId && royaltyAccount) {
      customFees.push({
        denominatingTokenId: tokenId,
        amount: fee,
        collectorAccountId: royaltyAccount
      });
      const topic = topicId;
      const changeMemo =
      await window.HashinalsWalletConnectSDK.updateTopic(topic , memo, adminKey, customFees, feeScheduleKey);
    } else {
    const topic = topicId;
    const changeMemo =
    await window.HashinalsWalletConnectSDK.updateTopic(topic , memo, adminKey);
    }


  } catch (error) {
  console.error("Error creating topic:", error);
  }
});






async function loadProfilePicture() {
const topicId = "0.0.9609881";
const accountUrls = {}; // Dictionary to store account IDs and their URLs

  try {
    const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

    // Check if result exists and has messages
    if (!result || !Array.isArray(result.messages)) {
      console.log("No profile pictures found, using defaults");
      return {};
    }

    // Process all messages to build the accountUrls dictionary
    result.messages.forEach(message => {
      if (message.payer && message.data && message.data.urls && message.data.urls.length > 0) {
        // Store or update the URL for this account
        accountUrls[message.payer] = {
        url: message.data.urls[0],
        timestamp: message.timestamp
        };
      }
    });


    return accountUrls;

    } catch (error) {
      console.log("Error in loadProfilePicture:", error);
      return {}; // Return empty object instead of throwing error
    }
}

loadProfilePicture();
loader.updateProgress();

async function loadUsername() {
  const topicId = "0.0.9609904";
  const accountUsernames = {};

  try {
    const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

    // Check if result exists and has messages
    if (!result || !Array.isArray(result.messages)) {
      console.log("No usernames found, using defaults");
      return {};
    }

    // Process all messages to build the accountUsernames dictionary
    result.messages.forEach(message => {
      if (message.payer && message.data && message.data.username) {
        // Only store usernames with less than 20 characters
        if (message.data.username.length < 20) {
          accountUsernames[message.payer] = {
            username: message.data.username,
            timestamp: message.timestamp
          };
        }
      }
    });

    return accountUsernames;

  } catch (error) {
    console.log("Error in loadUsername:", error);
    return {}; // Return empty object instead of throwing error
  }
}

async function loadCLICK2URL() {
  const topicId = "0.0.9752486";
  const accountCLICK2URL = {};

  try {
    const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

    // Check if result exists and has messages
    if (!result || !Array.isArray(result.messages)) {
      console.log("No CLICK2URL found, using defaults");
      return {};
    }

    // Process all messages to build the accountUsernames dictionary
    result.messages.forEach(message => {
      if (message.payer && message.data && message.data.click2url && message.data.click2url.length > 0) {
        // Only store usernames with less than 20 characters
          accountCLICK2URL[message.payer] = {
            click2url: message.data.click2url[0],
            timestamp: message.timestamp
          };
        }
    });

    return accountCLICK2URL;

  } catch (error) {
    console.log("Error in loadCLICK2URL:", error);
    return {}; // Return empty object instead of throwing error
  }
}


async function loadTOPIC2PIC() {
  const topicId = "0.0.9759201";
  const accountTOPIC2PIC = {}; // Dictionary to store account IDs and their topics2pic

  try {
    const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

    // Check if result exists and has messages
    if (!result || !Array.isArray(result.messages)) {
      console.log("No TOPIC2PIC found, using defaults");
      return {};
    }

    // Process all messages to build the accountTOPIC2PIC dictionary
    result.messages.forEach(message => {
      if (message.payer && message.data && message.data.topic2pic) {
        // Only store topics2pic with less than 20 characters
        if (message.data.topic2pic.length < 20) {
          accountTOPIC2PIC[message.payer] = {
            topic2pic: message.data.topic2pic,
            timestamp: message.timestamp
          };
        }
      }
    });

    return accountTOPIC2PIC;

  } catch (error) {
    console.log("Error in loadTOPIC2PIC:", error);
    return {}; // Return empty object instead of throwing error
  }
}

window.loadTOPIC4PIC = async function(payer) {
  try {
    const accountTOPIC2PIC = await loadTOPIC2PIC();

    if (!accountTOPIC2PIC[payer] || !accountTOPIC2PIC[payer].topic2pic) {
      return {};
    }

    const topicId = accountTOPIC2PIC[payer].topic2pic;
    const topicIdStr = topicId[0];
    const topicInfo = await window.HashinalsWalletConnectSDK.getTopicInfo(topicIdStr);
    const topicAdmin = [];
    const memo = topicInfo.memo;

    const parts = memo.split(',');
    let hasRules = false;
    parts.forEach(part => {
      if (part.startsWith("0.0.")) {
        topicAdmin.push(part);
        hasRules = true;
      }
    });

    const result = await window.HashinalsWalletConnectSDK.getMessages(topicIdStr);

    if (!result || !Array.isArray(result.messages)) {
      console.log(`No messages found for topicId ${topicId}, returning empty object`);
      return {};
    }

    let hasMoreThanOneTopic = false;
    const topicActions = new Map();

    for (let index = 0; index < result.messages.length; index++) {
      const message = result.messages[index];
      try {
        let parsedMessage = message;
        if (typeof message === 'string') {
          parsedMessage = JSON.parse(message);
        }
        const timestamp = message.timestamp || Date.now();

        if (
          parsedMessage.addTopic &&
          parsedMessage.addTopic.addTopic &&
          (topicAdmin.length === 0 || topicAdmin.includes(message.payer))
        ) {
          hasMoreThanOneTopic = true;
          const topics =
            typeof parsedMessage.addTopic.addTopic === 'string'
              ? parsedMessage.addTopic.addTopic.split(',')
              : [];
          topics.forEach(topic => {
            topicActions.set(topic, { action: 'add', timestamp });
          });
        }

        if (
          parsedMessage.removeTopic &&
          parsedMessage.removeTopic.removeTopic &&
          (topicAdmin.length === 0 || topicAdmin.includes(message.payer))
        ) {
          hasMoreThanOneTopic = true;
          const topics =
            typeof parsedMessage.removeTopic.removeTopic === 'string'
              ? parsedMessage.removeTopic.removeTopic.split(',')
              : [];
          topics.forEach(topic => {
            topicActions.set(topic, { action: 'remove', timestamp });
          });
        }
      } catch (messageError) {
        console.error(`Error processing message ${index}:`, messageError);
      }
    }

    const loadedTopicsIds = Array.from(topicActions.entries())
      .filter(([topic, { action }]) => action === 'add' && topic.startsWith('0.0.'))
      .map(([topic]) => topic);

    const loadedTopicIdsWithNames = [];
    for (const topicId of loadedTopicsIds) {
      const { loadedTopicName } = await processTopicMessages(topicId);

      if (loadedTopicName !== undefined) {
        const topicNamePart = loadedTopicName ? `-${loadedTopicName}` : '';
        loadedTopicIdsWithNames.push(`${topicId}${topicNamePart}`);
      }
    }

    globalLoadedTopicIdsWithNames = loadedTopicIdsWithNames.sort((a, b) => {
      const idA = parseFloat(a.split('-')[0].replace('0.0.', ''));
      const idB = parseFloat(b.split('-')[0].replace('0.0.', ''));
      return idA - idB;
    });

    activePolygonPopups.forEach((popup) => popup.remove());
    activeMarkerPopups.forEach((popup) => popup.remove());
    CloseALL();
    const loadColumn = document.getElementById("load-column");
    loadColumn.style.display = "block";
    const inputarea = document.getElementById("input-field");
    inputarea.value = '';
    const loaded_text_area = document.getElementById("loaded-topics");
    loaded_text_area.value = '';
    loaded_text_area.value = globalLoadedTopicIdsWithNames.join('\n');
    adjustTextareaHeight(loaded_text_area);

    return { loadedTopicIdsWithNames };

  } catch (error) {
    console.log(`Error in loadTOPIC4PIC for payer ${payer}:`, error);
    return {};
  }
}

const geojson = {
  type: "FeatureCollection",
  features: []
};

const polygons = [
];

const loadedNFTsForModel = [];
const loadedNFTScaleForModel = [];
let hasRulesForModelNFT = false;

function updateRulesForModelNFTState() {
  if (loadedNFTsForModel.length > 0) {
    hasRulesForModelNFT = true;
  } else {
    hasRulesForModelNFT = false;
  }
}

let globalLoadedTopicIdsWithNames = [];

async function handleAllMessages() {
  try {
    const profilePics = await loadProfilePicture();
    const usernames = await loadUsername();
    const click2url = await loadCLICK2URL();
    let userInput = document.getElementById("input-field").value.toLowerCase();
    let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
    let topicId;

    if (domainEntry && domainEntry.lastMessage) {
      topicId = domainEntry.lastMessage.topic;
    } else {
      topicId = userInput || initialTopicId;
    }

    const result = await sdk.getMessages(topicId);

    globalLoadedTopicIdsWithNames = [];
    let addedTopics = [];
    let removedTopics = [];
    let loadedTopicsIds = [];

    const loaded_text_area = document.getElementById("loaded-topics");
    loaded_text_area.value = '';

    let hasMoreThanOneTopic = false;

    geojson.features = [];
    polygons.length = 0;

    // Remove existing markers
    existingMarkers.forEach(marker => marker.remove());
    existingMarkers = [];

    // Remove existing polygon layers
    map.getStyle().layers.forEach(layer => {
      if (layer.id.includes('-layer')) {
        map.removeLayer(layer.id);
      }
    });

    // Remove existing polygon sources
    const sourceIds = Object.keys(map.getStyle().sources);
    sourceIds.forEach(sourceId => {
      if (sourceId.includes('-source')) {
        map.removeSource(sourceId);
      }
    });

    const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          const memo = topicInfo.memo;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
              hasRules = true;
            }
          });

    const topicActions = new Map();

    for (let index = 0; index < result.messages.length; index++) {
      const message = result.messages[index];
      try {
        let parsedMessage = message;
        if (typeof message === 'string') {
          parsedMessage = JSON.parse(message);
        }
        const timestamp = message.timestamp || Date.now(); // Use message timestamp or current time

        if (parsedMessage.addTopic && parsedMessage.addTopic.addTopic && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
          hasMoreThanOneTopic = true;
          const topics = typeof parsedMessage.addTopic.addTopic === 'string'
            ? parsedMessage.addTopic.addTopic.split(',')
            : [];
          topics.forEach(topic => {
            topicActions.set(topic, { action: 'add', timestamp });
          });
        }

        if (parsedMessage.removeTopic && parsedMessage.removeTopic.removeTopic && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
          hasMoreThanOneTopic = true;
          const topics = typeof parsedMessage.removeTopic.removeTopic === 'string'
            ? parsedMessage.removeTopic.removeTopic.split(',')
            : [];
          topics.forEach(topic => {
            topicActions.set(topic, { action: 'remove', timestamp });
          });
        }
      } catch (messageError) {
        console.error(`Error processing message ${index}:`, messageError);
      }
    }

    // Determine the final list of topics based on the latest action
    loadedTopicsIds = Array.from(topicActions.entries())
      .filter(([topic, { action }]) => action === 'add' && topic.startsWith('0.0.'))
      .map(([topic]) => topic);

      const loadedTopicIdsWithNames = [];


    // Load and process messages from each topic in loadedTopicsIds
    for (const topicId of loadedTopicsIds) {
      const { topicGeojsonFeatures, topicPolygons, loadedTopicName } = await processTopicMessages(topicId); // Ensure this is awaited if it's async

      // Update markers/clusters
      if (geojson.features.length > 0) {
        index.load(geojson.features);
        updateClusters();
      }
      // Add new polygons
      polygons.forEach(polygon => {
        addPolygonWithImageFill(map, polygon);
      });


    if (loadedTopicName !== undefined) { // Only skip if loadedTopicName is undefined
      const topicNamePart = loadedTopicName ? `-${loadedTopicName}` : '';
      loadedTopicIdsWithNames.push(`${topicId}${topicNamePart}`);
     }
    }

    globalLoadedTopicIdsWithNames = loadedTopicIdsWithNames;


    globalLoadedTopicIdsWithNames.sort((a, b) => {
      const idA = parseFloat(a.split('-')[0].replace('0.0.', ''));
      const idB = parseFloat(b.split('-')[0].replace('0.0.', ''));
      return idA - idB;
    });

    loaded_text_area.value = globalLoadedTopicIdsWithNames.join('\n'); // Update with new values
    adjustTextareaHeight(loaded_text_area); // Adjust height after loading

    return loadedTopicIdsWithNames; // Return the loadedTopicsIds array

      } catch (error) {
        console.error("Error processing topic messages:", error);
      }
};

loader.updateProgress();

loadedNFTScaleForModel.sort((a, b) => b.scale - a.scale);
let scaleForModel = 1;
let finalScaleForModel = 1;



async function confirmNFTFunction(accountId) {
  let tokenIdForModel = "0.0.9605689";
  let tokenIDForBeta = "0.0.9606654";
  let userInput = document.getElementById("input-field").value.toLowerCase();
  let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
  let topicId;

  if (domainEntry && domainEntry.lastMessage) {
    topicId = domainEntry.lastMessage.topic;
  } else {
    topicId = userInput || initialTopicId;
  }
  await handleAllMessages();

  loadedNFTsForModel.length = 0;
  hasRulesForModelNFT = false;


  const NFTForModel = await sdk.getAccountNFTs(accountId, tokenIdForModel);
  const NFTForBeta = await sdk.getAccountNFTs(accountId, tokenIDForBeta);

  if (NFTForBeta.length > 0) {
    BetaNFTScaleFactor = 1.5;
    finalScaleForModel = BetaNFTScaleFactor*scaleForModel;
  } else {
    BetaNFTScaleFactor = 1; // Set to 1 if no beta NFTs
  }



  if (loadedNFTScaleForModel.length > 0) {
    for (const item of loadedNFTScaleForModel) {
      const checkIfUserHasNFT = await sdk.getAccountNFTs(accountId, item.NFT);
      if (checkIfUserHasNFT.length > 0) {
        scaleForModel = item.scale;
        finalScaleForModel = BetaNFTScaleFactor*scaleForModel;
        break;
      }
      else {
        scaleForModel = 1;
      }
    }
  }


  if (NFTForModel.length > 0) {
    try {
      if (hasRulesForModelNFT === true) {
        for (const nft of loadedNFTsForModel) {
          const checkIfUserHasNFT = await sdk.getAccountNFTs(accountId, nft);
          if (checkIfUserHasNFT.length > 0) {
            await someFunction(accountId, topicId);
            return true;
          }
        }
        return false;
      }

      if (hasRulesForModelNFT === false) {
        await someFunction(accountId, topicId);
      }

    } catch (error) {
    }
  } else {
    return false;
  }
}

const renderer = new THREE.WebGLRenderer({ alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document
  .getElementById("three-container")
  .appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);


function createStars() {
  const starsGeometry = new THREE.BufferGeometry();
  const starCount = 2000;
  const positions = new Float32Array(starCount * 3);
  const innerRadius = 900;
  const outerRadius = 950;

  for (let i = 0; i < starCount; i++) {
    const i3 = i * 3;

    // Generate random spherical coordinates
    const theta = Math.random() * 2 * Math.PI; // Azimuthal angle
    const phi = Math.acos(2 * Math.random() - 1); // Polar angle
    // Random radius between innerRadius and outerRadius
    const radius = Math.cbrt(Math.random()) * (outerRadius - innerRadius) + innerRadius;

    // Convert to Cartesian coordinates
    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
    positions[i3 + 2] = radius * Math.cos(phi);
  }

  starsGeometry.setAttribute(
    "position",
    new THREE.BufferAttribute(positions, 3)
  );
  const starsMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 1.5,
    sizeAttenuation: true,
  });

  const stars = new THREE.Points(starsGeometry, starsMaterial);
  scene.add(stars);
  return stars;
}

const stars = createStars();


const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 5, 5);
scene.add(directionalLight);

camera.position.z = 10;

const randomLatitude = (Math.random() * 180) - 90; // Random latitude between -90 and 90
const randomLongitude = (Math.random() * 360) - 180; // Random longitude between -180 and 180

const map = new maplibregl.Map({
  container: "map",
  style: "https://tiles.openfreemap.org/styles/liberty",
  center: [-172, -19],
  zoom: 0,
  pitch: 0,
  bearing: 0,
  maxPitch: 75,
  maxZoom: 19,
  antialias: true,
  projection: {
    name: "globe",
  },
});

// Add navigation controls (optional, for testing bearing changes)
map.addControl(new maplibregl.NavigationControl());

// map.dragPan.disable();
// map.scrollZoom.disable();
// map.boxZoom.disable();
// map.doubleClickZoom.disable();
// map.touchZoomRotate.disable();
// map.dragRotate.disable();


const keys = {
  w: false,
  a: false,
  s: false,
  d: false,
  q: false,
  e: false,
  space: false,
  shift: false,
  r: false,
  f: false,
};

const MOVE_SPEED = 0.5;
const BUTTON_PAN_SPEED = 6;
const BUTTON_ZOOM_SPEED = 0.05;

const speedSlider = document.getElementById("speed-slider");

function getSpeedMultiplier() {
  return parseFloat(speedSlider.value);
}

loader.updateProgress();


function handleMovement() {

  const isBlocked = [
    ...everythinginsideyourfov,
    ...everythinginsidetoolbar
  ].some(id => {
    const element = document.getElementById(id);
    return element && window.getComputedStyle(element).display === "block";
  });

  const zoom = map.getZoom();
  const panSpeed = 10 * getSpeedMultiplier();
  const zoomSpeed = 0.05 * getSpeedMultiplier();

  if (!isBlocked) {
    if (keys.w) {
      map.panBy([0, -panSpeed], { animate: false });
    }
    if (keys.s) {
      map.panBy([0, panSpeed], { animate: false });
    }

    if (keys.a) {
      map.panBy([-panSpeed, 0], { animate: false });
    }
    if (keys.d) {
      map.panBy([panSpeed, 0], { animate: false });
    }

    if (keys.e) {
      map.setBearing(map.getBearing() + MOVE_SPEED * getSpeedMultiplier());
    }
    if (keys.q) {
      map.setBearing(map.getBearing() - MOVE_SPEED * getSpeedMultiplier());
    }

    if (keys.space) {
      map.setZoom(map.getZoom() + zoomSpeed);
    }
    if (keys.shift) {
      map.setZoom(map.getZoom() - zoomSpeed);
    }

    if (keys.r) {
      map.setPitch(map.getPitch() + 1 * getSpeedMultiplier());
    }
    if (keys.f) {
      map.setPitch(map.getPitch() - 1 * getSpeedMultiplier());
    }
  }
}

document.addEventListener("keydown", (event) => {
  const activeElement = document.activeElement; // Get the currently focused element
  const isInputField = activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA";
  const isSpeedSlider = activeElement.id === "speed-slider"; // Check if the active element is the speed slider

  switch (event.key.toLowerCase()) {
    case "w":
      keys.w = true;
      break;
    case "a":
      keys.a = true;
      break;
    case "s":
      keys.s = true;
      break;
    case "d":
      keys.d = true;
      break;
    case "q":
      keys.q = true;
      break;
    case "e":
      keys.e = true;
      break;
    case " ":
      if (!isInputField || isSpeedSlider) { // Allow spacebar if the active element is the speed slider
        keys.shift = true;
        event.preventDefault();
      }
      break;
    case "shift":
      keys.space = true;
      break;
    case "r":
      keys.r = true;
      break;
    case "f":
      keys.f = true;
      case " ":
  }
});

document.addEventListener("keyup", (event) => {
  switch (event.key.toLowerCase()) {
    case "w":
      keys.w = false;
      break;
    case "a":
      keys.a = false;
      break;
    case "s":
      keys.s = false;
      break;
    case "d":
      keys.d = false;
      break;
    case "q":
      keys.q = false;
      break;
    case "e":
      keys.e = false;
      break;
    case " ":
      keys.shift = false;
      break;
    case "shift":
      keys.space = false;
      break;
    case "r":
      keys.r = false;
      break;
    case "f":
      keys.f = false;
      break;
  }
});

const everythinginsideoptionsbuttons = [
  "toggle-controls-btn",
  "toggle-your-fov-btn",
  "toggle-visibility-controls-btn",
  "toggle-toolbar-btn"
];

const firstlayercolumns = [
  "rotation-controls",
  "toolbar",
  "visibility-controls",
  "topic-chat-container",
];


const everythinginsideyourfov = [
  "model-column",
  "crosshair-column",
  "popup-column",
  "main-button-column",
  "marker-options-column",
  "button-input-column",
  "container-column",
  "topic-chat-column",
];

const everythinginsidetoolbar = [
  "Edit_Profile-column",
  "load-column",
  "create-column",
  "upload-to-ipfs-column",
  "marker-column",
  "polygon-column",
  "rules-column",
  "utility-column",
  "memo-column",
  "stack-topic-ids",
];

function CloseALL() {
  everythinginsideoptionsbuttons.forEach(buttonId => {
    document.getElementById(buttonId).style.display = "none";
  });
  everythinginsideyourfov.forEach(buttonId => {
    document.getElementById(buttonId).style.display = "none";
  });
  everythinginsidetoolbar.forEach(buttonId => {
    document.getElementById(buttonId).style.display = "none";
  });
  firstlayercolumns.forEach(buttonId => {
    document.getElementById(buttonId).style.display = "none";
  });
  document.getElementById("main-toggle-btn").style.display = "block";
  document.getElementById("topic-chat-btn").style.display = "block";
}

document.addEventListener('click', function(event) {
  CloseALL();
});

document.getElementById("main-toggle-btn").addEventListener("click", function(event) {
  event.stopPropagation();
  CloseALL();
  activePolygonPopups.forEach((popup) => popup.remove());
  activeMarkerPopups.forEach((popup) => popup.remove());
  document.getElementById("main-toggle-btn").style.display = "none";
  document.getElementById("topic-chat-btn").style.display = "none";
  everythinginsideoptionsbuttons.forEach(buttonId => {
    document.getElementById(buttonId).style.display = "flex";
  });
});

let toggleControlsPressCount = 0;

document.getElementById("toggle-controls-btn").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  const speedSlider = document.getElementById("speed-slider");
  const maplibreglCtrlGroup = document.querySelector(".maplibregl-ctrl.maplibregl-ctrl-group");
  toggleControlsPressCount++;
  if (toggleControlsPressCount === 1) {
    speedSlider.style.display = "block";
    if (maplibreglCtrlGroup) maplibreglCtrlGroup.style.display = "block";
  } else if (toggleControlsPressCount > 3) {
    speedSlider.style.display = "none";
    if (maplibreglCtrlGroup) maplibreglCtrlGroup.style.display = "none";
    toggleControlsPressCount = 0;
  }
  const zoomControls = document.getElementById("zoom-controls");
  const leftDpad = document.getElementById("left-dpad");
  const rightDpad = document.getElementById("right-dpad");
  const isVisible = getComputedStyle(zoomControls).display !== "none";
  if (isVisible) {
    zoomControls.setAttribute("style", "display: none !important");
    leftDpad.setAttribute("style", "display: none !important");
    rightDpad.setAttribute("style", "display: none !important");
  } else {
    zoomControls.setAttribute("style", "display: flex !important; z-index: 2000 !important; opacity: 1 !important; visibility: visible !important;");
    leftDpad.setAttribute("style", "display: grid !important; z-index: 2000 !important; opacity: 1 !important; visibility: visible !important;");
    rightDpad.setAttribute("style", "display: grid !important; z-index: 2000 !important; opacity: 1 !important; visibility: visible !important;");
  }
});

document.getElementById("toggle-visibility-controls-btn").addEventListener("click", function(event) {
  event.stopPropagation();
  CloseALL();
  document.getElementById("visibility-controls").style.display = "block";
});

document.getElementById("toggle-your-fov-btn").addEventListener("click", function(event) {
  event.stopPropagation();
  CloseALL();
  document.getElementById("rotation-controls").style.display = "block";
});

document.getElementById("change-model-settings").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("model-column").style.display = "block";
  document.getElementById("model-column-container").style.display = "block";
});

document.getElementById("change-crosshair-settings").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("crosshair-column").style.display = "block";
  document.getElementById("crosshair-column-container").style.display = "block";
});

document.getElementById("change-popup-settings").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("popup-column").style.display = "block";
  document.getElementById("popup-column-container").style.display = "block";
});

document.getElementById("change-color-of-main-buttons").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("main-button-column").style.display = "block";
  document.getElementById("main-button-column-container").style.display = "block";
});

document.getElementById("change-marker-options").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("marker-options-column").style.display = "block";
  document.getElementById("marker-options-column-container").style.display = "block";
});

document.getElementById("change-button-input-settings").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("button-input-column").style.display = "block";
  document.getElementById("button-input-column-container").style.display = "block";
});

document.getElementById("change-container-settings").addEventListener("click", (event) => {
  event.stopPropagation();  
  CloseALL();
  document.getElementById("container-column").style.display = "block";
  document.getElementById("container-column-container").style.display = "block";
});

document.getElementById("change-topic-chat-options").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("topic-chat-column").style.display = "block";
  document.getElementById("topic-chat-column-container").style.display = "block";
});

document.getElementById("toggle-toolbar-btn").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("toolbar").style.display = "block";
});

document.getElementById("Edit_Profile").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("Edit_Profile-column").style.display = "block";
  document.getElementById("Edit_Profile-column-container").style.display = "block";
});

document.getElementById("Load_Everything").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("load-column").style.display = "block";
  document.getElementById("load-column-container").style.display = "block";
  const loaded_text_area = document.getElementById("loaded-topics");
  loaded_text_area.value = '';
  loaded_text_area.value = globalLoadedTopicIdsWithNames.join('\n');
  adjustTextareaHeight(loaded_text_area);
});

document.getElementById("Upload_To_IPFS").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("upload-to-ipfs-column").style.display = "block";
  document.getElementById("upload-to-ipfs-column-container").style.display = "block";
});

document.getElementById("Create_New_Topic").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("create-column").style.display = "block";
  document.getElementById("create-column-container").style.display = "block";
});

document.getElementById("Create_Marker").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("marker-column").style.display = "block";
  document.getElementById("marker-column-container").style.display = "block";
});

document.getElementById("Create_Polygon").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("polygon-column").style.display = "block";
  document.getElementById("polygon-column-container").style.display = "block";
});

document.getElementById("Set_Rules").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("rules-column").style.display = "block";
  document.getElementById("rules-column-container").style.display = "block";
});

document.getElementById("NFT-utility").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("utility-column").style.display = "block";
  document.getElementById("utility-column-container").style.display = "block";
});

document.getElementById("Change_Memo").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("memo-column").style.display = "block";
  document.getElementById("memo-column-container").style.display = "block";
});

document.getElementById("Stack_topic_IDs").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  document.getElementById("stack-topic-ids").style.display = "block";
  document.getElementById("stack-topic-ids-container").style.display = "block";
});

document.getElementById("topic-chat-btn").addEventListener("click", (event) => {
  event.stopPropagation();
  CloseALL();
  activePolygonPopups.forEach((popup) => popup.remove());
  activeMarkerPopups.forEach((popup) => popup.remove());
  document.getElementById("topic-chat-container").style.display = "block";
});



document.getElementById("button3").addEventListener("click", async () => {
try {
  const topicId = document.getElementById("Edit_Profile-topic-id").value;
  const newName = document.getElementById("toolbar-input").value;

  const meesageobject = {
    changeName: newName
  };

  const meesage = JSON.stringify(meesageobject);
  const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);

} catch (error) {
  console.error("Error setting rules:", error);
}
});

document.getElementById("post-msg").addEventListener("click", async () => {
try {
  const newMessage = document.getElementById("user-write-message").value;

let userInput = document.getElementById("topic-chat-topic-id").value.toLowerCase();
let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
let topicId;

if (domainEntry && domainEntry.lastMessage) {
  topicId = domainEntry.lastMessage.topic;
} else {
  topicId = userInput;
}

  const meesageobject = {
    userMessage: newMessage
  };

  const meesage = JSON.stringify(meesageobject);
  const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);

} catch (error) {
  console.error("Error setting rules:", error);
}
});



document
.getElementById("submit-button-Set_Rules")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const polygonTopicId = document.getElementById("input-field-topic-id-for-polygons").value;
              const markerTopicId = document.getElementById("input-field-topic-id-for-markers").value;
              const messagesPerNftPolygon = document.getElementById("input-field-messages-per-nft-for-polygons").value;
              const messagesPerNftMarker = document.getElementById("input-field-messages-per-nft-for-markers").value;
              const SizeForPolygons = document.getElementById("input-field-messages-size-for-polygons").value;

              const meesageobject = {
                rules : {
                  forpolygon: {
                    polygonTopicId: polygonTopicId,
                    polygonMessagesPerNft: messagesPerNftPolygon,
                    polygonSize: SizeForPolygons
                  },
                  formarker: {
                    markerTopicId: markerTopicId,
                    markerMessagesPerNft: messagesPerNftMarker
                  }
              }};

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);

            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });


          document.getElementById("load-topic-rules-for-topic").addEventListener("click", async () => {
    try {
        let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
        let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
        let topicId;

        if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
        } else {
            topicId = userInput;
        }
        const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);
        const topicInfo = await sdk.getTopicInfo(topicId);
        const topicAdmin = [];
        const memo = topicInfo.memo;
        let hasRules = false;

        // Split the memo by commas
        const parts = memo.split(',');

        // Iterate over each part
        parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
                // Add it to the topicAdmin array
                topicAdmin.push(part);
                hasRules = true;
            }
        });

        const messages = response.messages; // Extract messages
        let lastRule = null;



        // Read rules from messages in reverse order
        for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
                let parsedMessage = message;
                if (typeof message === 'string') {
                    parsedMessage = JSON.parse(message);
                }
                if (parsedMessage.rules && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                    lastRule = parsedMessage.rules;
                    break; // Exit the loop after finding the last message with rules
                }

            } catch (messageError) {
                console.error(`Error processing message ${index}:`, messageError);
            }
        }

              let formattedRules = '';
              if (lastRule) {
                if (lastRule.forpolygon) {
                  const polygonSize = lastRule.forpolygon.polygonSize;
                  const maxLongitudeSize = 360 / polygonSize;
                  const maxLatitudeSize = 180 / polygonSize;

                  formattedRules +=
                    `Polygon Topic ID: ${lastRule.forpolygon.polygonTopicId}\n` +
                    `Polygon Messages Per NFT: ${lastRule.forpolygon.polygonMessagesPerNft}\n` +
                    `Polygon Size: ${polygonSize}\n` +
                    `Maximum distance between points is:\n360/${polygonSize}=${maxLongitudeSize} for longitude\n180/${polygonSize}=${maxLatitudeSize} for latitude.\n`;
                  hasRules = true;
                  }
                if (lastRule.formarker ) {
                  formattedRules +=
                    `Marker Topic ID: ${lastRule.formarker.markerTopicId}\n` +
                    `Marker Messages Per NFT: ${lastRule.formarker.markerMessagesPerNft}\n`;
                  hasRules = true;
                }
              }

                      // Check if messages exist and is an array
        if (hasRules===false) {
            const markerRulesMessage = `No rules for this topic.`;
            document.getElementById("loaded-topic-rules-for-topic").textContent = markerRulesMessage;
            adjustTextareaHeight(document.getElementById("loaded-topic-rules-for-topic"));
            return;
        }

                      // Log the formatted rules onto the textarea
                      document.getElementById("loaded-topic-rules-for-topic").textContent = formattedRules;
                      adjustTextareaHeight(document.getElementById("loaded-topic-rules-for-topic"));

                  } catch (error) {
                      console.error("Error creating topic:", error);
                  }
              });

document.getElementById("load-topic-rules-for-utility").addEventListener("click", async () => {
    try {
        let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
        let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
        let topicId;

        if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
        } else {
            topicId = userInput;
        }
        const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);
        const topicInfo = await sdk.getTopicInfo(topicId);
        const topicAdmin = [];
        const memo = topicInfo.memo;
        let hasRules = false;

        // Split the memo by commas
        const parts = memo.split(',');

        // Iterate over each part
        parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
                // Add it to the topicAdmin array
                topicAdmin.push(part);
                hasRules = true;
            }
        });

        const messages = response.messages; // Extract messages


const loadedNFTsForModel = [];
const loadedNFTScaleForModel = [];
const loadedNFTsForTopicChat = [];


for (let index = 0; index < messages.length; index++) {
  const message = messages[index];
  try {
    let parsedMessage = message;
    if (typeof message === 'string') {
      parsedMessage = JSON.parse(message);
    }
    if (parsedMessage.addTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
  const nfts = parsedMessage.addTopicNFT.split(',').map(nft => nft.trim());
  nfts.forEach(nft => {
    if (!loadedNFTsForModel.includes(nft)) {
      loadedNFTsForModel.push(nft);
    }
  });
}

if (parsedMessage.removeTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
  const nft = parsedMessage.removeTopicNFT.trim();
  const index = loadedNFTsForModel.indexOf(nft);
  if (index !== -1) {
    loadedNFTsForModel.splice(index, 1);
  }
}

  if (parsedMessage.addScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
    const { NFT, scale } = parsedMessage.addScale;
    loadedNFTScaleForModel.push({ NFT, scale });
  }

  if (parsedMessage.removeScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
    const { NFT } = parsedMessage.removeScale;
    const index = loadedNFTScaleForModel.findIndex(item => item.NFT === NFT);
    if (index !== -1) {
      loadedNFTScaleForModel.splice(index, 1); // Remove the item if it exists
    } else {
      console.log(`NFT: ${NFT} not found in addScale list`);
    }
  }

  if (parsedMessage.addTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
  const nfts = parsedMessage.addTopicChatNFT.split(',').map(nft => nft.trim());
  nfts.forEach(nft => {
    if (!loadedNFTsForTopicChat.includes(nft)) {
      loadedNFTsForTopicChat.push(nft);
    }
  });
  console.log("NFT added to topic chat:", loadedNFTsForTopicChat.join(', '));
}

if (parsedMessage.removeTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
  const nft = parsedMessage.removeTopicChatNFT.trim();


  const index = loadedNFTsForTopicChat.indexOf(nft);
  if (index !== -1) {
    loadedNFTsForTopicChat.splice(index, 1);
  }
}
}
catch (messageError) {
                console.error(`Error processing message ${index}:`, messageError);
            }
}

let formattedRules = '';

  if (loadedNFTsForModel.length > 0) {
    formattedRules += `NFTs for model: ${loadedNFTsForModel.join(', ')}\n`;
    hasRules = true;
  }
  if (loadedNFTScaleForModel.length > 0) {
    formattedRules += `Scales for model: ${loadedNFTScaleForModel.map(item => `${item.NFT} = ${item.scale}`).join(', ')}\n`;
    hasRules = true;
  }
  if (loadedNFTsForTopicChat.length > 0) {
    formattedRules += `NFTs for topic chat: ${loadedNFTsForTopicChat.join(', ')}\n`;
    hasRules = true;
  }

          // Check if messages exist and is an array
          if (hasRules===false) {
            const utilityRulesMessage = `No rules for this topic.`;
            document.getElementById("loaded-topic-rules-for-utility").textContent = utilityRulesMessage;
            adjustTextareaHeight(document.getElementById("loaded-topic-rules-for-utility"));
            return;
        }

        // Log the formatted rules onto the textarea
        document.getElementById("loaded-topic-rules-for-utility").textContent = formattedRules;
        adjustTextareaHeight(document.getElementById("loaded-topic-rules-for-utility"));

    } catch (error) {
        console.error("Error creating topic:", error);
    }
});



          document
.getElementById("button5")
.addEventListener("click", async () => {
            try {
              const topicId = '0.0.9606779';
              const topic = document.getElementById("Edit_Profile-topic-id").value;
              const domain = document.getElementById("toolbar-input").value.toLowerCase();


              const meesageobject = {
                topic : topic,
                domain : domain
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);

            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });



          document
.getElementById("submit-button-add-scale-for-model")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicAddTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;
              const stackTopicAddScale = document.getElementById("input-field-add-remove-scale-for-model").value;


              const meesageobject = {
                    addScale:{
                      NFT: stackTopicAddTopicNFT,
                      scale: stackTopicAddScale
                    }
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);

            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });

          document
.getElementById("submit-button-remove-scale-for-model")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicRemoveTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;

              const meesageobject = {
                      removeScale:{
                        NFT: stackTopicRemoveTopicNFT
                      }
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);

            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });

          document
.getElementById("submit-button-add-NFT-for-model")
.addEventListener("click", async () => {
            try {
                let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicAddTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;


              const meesageobject = {
                    addTopicNFT: stackTopicAddTopicNFT
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);

            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });
          loader.updateProgress();
          document
.getElementById("submit-button-remove-NFT-for-model")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicRemoveTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;


              const meesageobject = {
                  removeTopicNFT: stackTopicRemoveTopicNFT
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);

            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });

          document
.getElementById("submit-button-add-topic-chat")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicAddTopicNFT = document.getElementById("input-field-add-remove-topic-chat").value;


              const meesageobject = {
                    addTopicChatNFT: stackTopicAddTopicNFT
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);

            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });

          document
.getElementById("submit-button-remove-topic-chat")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicRemoveTopicNFT = document.getElementById("input-field-add-remove-topic-chat").value;


              const meesageobject = {
                  removeTopicChatNFT: stackTopicRemoveTopicNFT
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);

            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });



          document
.getElementById("add-topic-id")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("stack-topic-ids-topic").value.toLowerCase();
    let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
    let topicId;

    if (domainEntry && domainEntry.lastMessage) {
      topicId = domainEntry.lastMessage.topic;
    } else {
      topicId = userInput;
    }
              const stackTopicAddTopic = document.getElementById("stack-topic-add-topic").value;


              const meesageobject = {
                  addTopic: {
                    addTopic: stackTopicAddTopic
                  },
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);

            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });

          document
.getElementById("remove-topic-id")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("stack-topic-ids-topic").value.toLowerCase();
    let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
    let topicId;

    if (domainEntry && domainEntry.lastMessage) {
      topicId = domainEntry.lastMessage.topic;
    } else {
      topicId = userInput;
    }
              const stackTopicRemoveTopic = document.getElementById("stack-topic-remove-topic").value;


              const meesageobject = {
                removeTopic: {
                  removeTopic: stackTopicRemoveTopic
                }
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);

            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });



  document
  .getElementById("submit-button-Create_Marker")
  .addEventListener("click", async () => {
    try {
      let userInput = document.getElementById("input-field-2-0").value.toLowerCase();
      let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
      let topicId;

      if (domainEntry && domainEntry.lastMessage) {
        topicId = domainEntry.lastMessage.topic;
      } else {
        topicId = userInput;
      }
      const title = document.getElementById("input-field-2-1").value;
      const imageurl = document.getElementById("input-field-image-marker").value;
      const coverimage = document.getElementById("input-field-coverimage-marker").value;
      const cleanUrl = imageurl.replace(/\?network=mainnet$/, "");
      const cleanCoverimage = coverimage.replace(/\?network=mainnet$/, "");
      const msg = document.getElementById("input-field-2-2").value;
      const cord = document.getElementById("input-field-2-3").value;
      const numberOfMarker = document.getElementById("input-field-number-of-marker").value;

            if (numberOfMarker === "" || !Number.isInteger(Number(numberOfMarker))) {
          alert("Please enter a valid whole number for the Number of Marker.");
          return;
      }

      if (!numberOfMarker || !topicId || !cord) {
            alert("Please fill in all required fields: Number of Marker, Topic ID, and Coordinates.");
            return;
          }

      const messageObj = {marker: {data: {title: title, image: [cleanUrl], coverimage: [cleanCoverimage], msg: msg, cord: cord, numberOfMarker: numberOfMarker }}};
      const message = JSON.stringify(messageObj);

      const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
        topicId,
        message
      );
      console.log('Receipt:', receipt);
    } catch (error) {
      console.error('Error submitting message:', error);
    }
  });

  document.getElementById("delete-marker-number").addEventListener("click", async () => {
    try {

      let userInput = document.getElementById("input-field-2-0").value.toLowerCase();
      let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
      let topicId;

      if (domainEntry && domainEntry.lastMessage) {
        topicId = domainEntry.lastMessage.topic;
      } else {
        topicId = userInput;
      }
      const oldMarkerNumber = document.getElementById("input-field-delete-marker-number").value;

            if (oldMarkerNumber === "" || !Number.isInteger(Number(oldMarkerNumber))) {
          alert("Please enter a valid whole number for the Number of Marker.");
          return;
      }

      if (!oldMarkerNumber || !topicId) {
            alert("Please fill in all required fields: Number of Marker, Topic ID");
            return;
          }

      const messageObj = {marker: {data: {deleteMarkerNumber: oldMarkerNumber}}};
      const message = JSON.stringify(messageObj);

      const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
        topicId,
        message
      );
      console.log('Receipt:', receipt);


    } catch (error) {
      console.error('Error submitting message:', error);
    }
  });


document
  .getElementById("submit-button-Create_Polygon")
  .addEventListener("click", async () => {
    try {
      let userInput = document.getElementById("input-field-3-0").value.toLowerCase();
      let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
      let topicId;

      if (domainEntry && domainEntry.lastMessage) {
        topicId = domainEntry.lastMessage.topic;
      } else {
        topicId = userInput;
      }
      const title = document.getElementById("input-field-3-1").value;
      const msg = document.getElementById("input-field-3-2").value;
      const imageurl = document.getElementById("input-field-image-polygon").value;
      const coverimage = document.getElementById("input-field-coverimage-polygon").value;
      const cord1 = document.getElementById("input-field-3-3").value; // TOP LEFT
      const cord3 = document.getElementById("input-field-3-5").value; // BOTTOM RIGHT
      const numberOfPolygon = document.getElementById("input-field-number-of-polygon").value;
      const cleanUrl = imageurl.replace(/\?network=mainnet$/, "");
      const cleanCoverimage = coverimage.replace(/\?network=mainnet$/, "");

            if (numberOfPolygon === "" || !Number.isInteger(Number(numberOfPolygon))) {
          alert("Please enter a valid whole number for the Number of Polygon.");
          return;
      }

      if (!numberOfPolygon || !topicId || !cord1 || !cord3) {
            alert("Please fill in all required fields: Number of Polygon, Topic ID, and Coordinates.");
            return; // Stop the submission if any field is empty
          }

      // Validate and format the coordinates input
      const Cords = {
        cord1 : cord1.split(',').map(Number), // Convert to array of numbers
        cord3 : cord3.split(',').map(Number),
      };

      const formattedCord = [
        Cords.cord1,
        [Cords.cord1[0],Cords.cord3[1]],
        Cords.cord3,
        [Cords.cord3[0],Cords.cord1[1]]
      ];

      // Ensure all coordinates are valid numbers
      const isValid = formattedCord.every(cord =>
        Array.isArray(cord) &&
        cord.length === 2 &&
        cord.every(num => !isNaN(num) && isFinite(num))
      );

      if (!isValid) {
        throw new Error('Please enter valid coordinates in the format number,number for all four corners.');
      }

      // Create the desired coordinate string without additional array wrapping
      const cordString = formattedCord.map(cord => `[${cord.join(',')}]`).join(', '); // Join the valid coordinates

      const messageObj = {
        polygon: {
          data: {
            title: title,
            image: [cleanUrl],
            coverimage: [cleanCoverimage],
            msg: msg,
            cord: cordString,
            numberOfPolygon: numberOfPolygon
          }
        }
      };
      const message = JSON.stringify(messageObj);

      const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
        topicId,
        message
      );
      console.log('Receipt:', receipt);

    } catch (error) {
      console.error('Error submitting message:', error);
    }
  });

  document.getElementById("delete-polygon-number").addEventListener("click", async () => {
    try {
      let userInput = document.getElementById("input-field-2-0").value.toLowerCase();
      let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
      let topicId;

      if (domainEntry && domainEntry.lastMessage) {
        topicId = domainEntry.lastMessage.topic;
      } else {
        topicId = userInput;
      }
      const oldPolygonNumber = document.getElementById("input-field-delete-polygon-number").value;

            if (oldPolygonNumber === "" || !Number.isInteger(Number(oldPolygonNumber))) {
          alert("Please enter a valid whole number for the Number of Polygon.");
          return;
      }

      if (!oldPolygonNumber || !topicId) {
            alert("Please fill in all required fields: Number of Polygon, Topic ID");
            return;
          }

      const messageObj = {polygon: {data: {deletePolygonNumber: oldPolygonNumber}}};
      const message = JSON.stringify(messageObj);

      const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
        topicId,
        message
      );
      console.log('Receipt:', receipt);


    } catch (error) {
      console.error('Error submitting message:', error);
    }
  });


function adjustButtonSize() {
    const coordinatesDisplay = document.getElementById('coordinates-display');
    const copyCoordinatesButton = document.getElementById('copy-coordinates');

    // Get the computed styles of the input field
    const computedStyle = window.getComputedStyle(coordinatesDisplay);

    // Parse the width and height to numbers (removing 'px')
    const width = parseFloat(computedStyle.width);
    const height = parseFloat(computedStyle.height);

    // Add a bit extra (e.g., 10px) and set back as strings with 'px'
    copyCoordinatesButton.style.width = `${width + 30}px`;
    copyCoordinatesButton.style.height = `${height + 10}px`;
  }

  // Call the function initially to set the size
  adjustButtonSize();

  // Optionally, add an event listener to adjust size on window resize
  window.addEventListener('resize', adjustButtonSize);



let targetRotationX = 0;
let targetRotationY = 0;
let prevLng = 0;
let prevLat = 0;
const lerpFactor = 0.05; // Controls smoothness

function animate() {
  requestAnimationFrame(animate);
  handleMovement();

  const zoomLevel = map.getZoom().toFixed(1);
  const pitchAngle = Math.round(map.getPitch());
  const center = map.getCenter();
  const lat = center.lat.toFixed(5);
  const lng = center.lng.toFixed(5);

  // Update coordinates display only if changed
  const coordinatesDisplay = document.getElementById("coordinates-display");
  const newCoords = `lng,lat = ${lng},${lat}`;
  if (coordinatesDisplay.value !== newCoords) {
    coordinatesDisplay.value = newCoords;

    const tempSpan = document.createElement("span");
    tempSpan.style.visibility = "hidden";
    tempSpan.style.position = "absolute";
    tempSpan.style.whiteSpace = "nowrap";
    tempSpan.style.font = window.getComputedStyle(coordinatesDisplay).font;
    tempSpan.textContent = newCoords;
    document.body.appendChild(tempSpan);

    coordinatesDisplay.style.width = `${tempSpan.offsetWidth + 10}px`;
    document.body.removeChild(tempSpan);
  }

  // Smooth longitude transition
  let deltaLng = lng - prevLng;
  if (deltaLng > 180) deltaLng -= 360;
  else if (deltaLng < -180) deltaLng += 360;
  prevLng = lng;

  // Smooth latitude transition
  let deltaLat = lat - prevLat;
  if (deltaLat > 90) deltaLat -= 180;
  else if (deltaLat < -90) deltaLat += 180;
  prevLat = lat;

  // Update target rotations (removed 0.5 factor)
  targetRotationY -= (deltaLng * Math.PI) / 180; // Full rotation mapping
  targetRotationX += (deltaLat * Math.PI) / 180;

  // Apply lerp for smooth rotation
  stars.rotation.y += (targetRotationY - stars.rotation.y) * lerpFactor;
  stars.rotation.x += (targetRotationX - stars.rotation.x) * lerpFactor;

  renderer.render(scene, camera);
}

// Initialize with starting longitude and latitude
function initializeRotation(initialLng, initialLat) {
  cumulativeLng = initialLng;
  prevLng = initialLng;
  cumulativeLat = initialLat;
  prevLat = initialLat;
}

// Example: Call this when your map or scene is initialized
// initializeRotation(map.getCenter().lng, map.getCenter().lat);

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  map.resize();
});

animate();

const index = new Supercluster({
  radius: 60,
  maxZoom: 11,
});

// Only load features if there are any
if (geojson.features.length > 0) {
  index.load(geojson.features);
}

function debounce(func, wait) {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

let existingMarkers = [];

function createLowQualityImage(imageUrl, size = 32) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.onload = () => {
      // Create a small canvas for the low quality version
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');

      // Draw image at lower resolution
      ctx.drawImage(img, 0, 0, size, size);

      // Convert to low quality JPEG-like format
      resolve(canvas.toDataURL('image/jpeg', 0.5));
    };
    img.onerror = reject;
    img.src = imageUrl;
  });
}

let lastBounds = null;

const activeMarkerPopups = [];

let currentMarkerSize = 5;

function updateClusters() {
  if (geojson.features.length === 0) {
    console.log("No features to update clusters.");
    return;
  }

  const currentBounds = map.getBounds().toArray().flat();
  lastBounds = currentBounds;
  const zoom = map.getZoom();
  const clusters = index.getClusters(currentBounds, Math.floor(zoom));

  // Remove existing markers
  existingMarkers.forEach((marker) => marker.remove());
  existingMarkers = [];

  clusters.forEach(async (cluster) => {
    const el = document.createElement("div");
    el.className = cluster.properties.cluster ? "cluster-marker" : "marker";
    const iconSize = [`${currentMarkerSize}vh`, `${currentMarkerSize}vh`];
    el.style.width = iconSize[0];
    el.style.height = iconSize[1];
    el.style.cursor = "pointer";
    el.style.borderRadius = "50%";

    if (cluster.properties.cluster) {
      el.textContent = cluster.properties.point_count_abbreviated;
      el.style.color = "black";
      el.style.textAlign = "center";
      el.style.lineHeight = iconSize[0];
      el.style.backgroundColor = "rgba(255, 255, 255, 0.8)";

      el.addEventListener("click", async (e) => {
        e.stopPropagation();
        const expansionZoom = await index.getClusterExpansionZoom(cluster.id);
        map.easeTo({
          center: cluster.geometry.coordinates,
          zoom: expansionZoom + 0.1,
          duration: 1000 // Set duration to 1000ms (1 second) or higher for a slower transition
        });
        activePolygonPopups.forEach((popup) => popup.remove());
        activeMarkerPopups.forEach((popup) => popup.remove());
      });
    } else {
      try {
        const lowQualityUrl = await createLowQualityImage(cluster.properties.imageUrl);
        el.style.backgroundImage = `url(${lowQualityUrl})`;
        el.style.backgroundSize = "cover";

        const img = new Image();
        img.onload = () => {
          el.style.backgroundImage = `url(${cluster.properties.imageUrl})`;
        };
        img.src = cluster.properties.imageUrl;
      } catch (error) {
        console.error("Error loading marker image:", error);
        el.style.backgroundColor = "rgba(255, 255, 255, 0.8)";
      }
    }

    const marker = new maplibregl.Marker({ element: el })
      .setLngLat(cluster.geometry.coordinates)
      .addTo(map);

    if (!cluster.properties.cluster) {
      const popup = new maplibregl.Popup().setHTML(cluster.properties.message);
      activeMarkerPopups.push(popup);

      popup.on("close", () => {
        if (currentUfoModel) {
          scene.add(currentUfoModel);
          crosshair.style.display = "block";
        }
      });

      el.addEventListener("click", (e) => {
        e.stopPropagation();
        activePolygonPopups.forEach((popup) => popup.remove());
        activeMarkerPopups.forEach((popup) => popup.remove());
        CloseALL();
        map.easeTo({
          center: cluster.geometry.coordinates,
          zoom: map.getZoom(),
          duration: 1000 // Set duration to 1000ms (1 second) or higher for a slower transition
        });
        popup.setLngLat(cluster.geometry.coordinates).addTo(map);
        applyAllStyles();
        if (currentUfoModel) {
          scene.remove(currentUfoModel);
          crosshair.style.display = "none";
        }
      });
    }
    existingMarkers.push(marker);
  });
}


const debouncedUpdateClusters = debounce(() => {
  updateClusters(); // Run updateClusters
}, 2000);
// map.on("moveend", debouncedUpdateClusters);

window.addEventListener("beforeunload", () => {
  map.remove();
  scene.clear();
  renderer.dispose();
});

async function createResizedImage(imageUrl, maxWidth = 256, maxHeight = 256) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "Anonymous";

    img.onload = () => {
      const canvas = document.createElement('canvas');
      let width = img.width;
      let height = img.height;

      // Calculate new dimensions while maintaining aspect ratio
      if (width > height) {
        if (width > maxWidth) {
          height = Math.round(height * (maxWidth / width));
          width = maxWidth;
        }
      } else {
        if (height > maxHeight) {
          width = Math.round(width * (maxHeight / height));
          height = maxHeight;
        }
      }

      canvas.width = width;
      canvas.height = height;

      const ctx = canvas.getContext('2d');
      // Use better image smoothing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      ctx.drawImage(img, 0, 0, width, height);
      resolve(canvas.toDataURL('image/jpeg', 1)); // Adjust quality here (0-1)
    };

    img.onerror = reject;
    img.src = imageUrl;
  });
}

// Track added layers to avoid duplicates
const addedLayers = new Set();
const activePolygonPopups = [];

async function addPolygonWithImageFill(map, polygon) {
  const sourceId = `${polygon.id}-source`;
  const layerId = `${polygon.id}-image-layer`;
  const maskLayerId = `${polygon.id}-mask-layer`;

  // Check if the source already exists
  if (map.getSource(sourceId)) {
    return; // Skip adding this polygon if the source already exists
  }

  // Wait for the map style to load if not already loaded
  if (!map.isStyleLoaded()) {
    await new Promise((resolve) => {
      map.once('load', () => resolve());
    });
  }

  try {
    // Calculate the bounding box of the polygon
    const coordinates = polygon.coordinates[0];
    const bounds = coordinates.reduce((bounds, coord) => {
      return {
        minLng: Math.min(bounds.minLng, coord[0]),
        maxLng: Math.max(bounds.maxLng, coord[0]),
        minLat: Math.min(bounds.minLat, coord[1]),
        maxLat: Math.max(bounds.maxLat, coord[1])
      };
    }, {
      minLng: Infinity,
      maxLng: -Infinity,
      minLat: Infinity,
      maxLat: -Infinity
    });

    // Create and add the resized image (now awaited)
    const resizedImageUrl = await createResizedImage(polygon.imageUrl, 512, 512);

    // Now safe to add source and layers since style is loaded
    map.addSource(sourceId, {
      type: 'image',
      url: resizedImageUrl,
      coordinates: [
        [bounds.minLng, bounds.maxLat],
        [bounds.maxLng, bounds.maxLat],
        [bounds.maxLng, bounds.minLat],
        [bounds.minLng, bounds.minLat]
      ]
    });

    map.addLayer({
      id: layerId,
      type: 'raster',
      source: sourceId,
      paint: {
        'raster-opacity': 1,
        'raster-fade-duration': 0,
        'raster-resampling': 'linear',
        'raster-brightness-min': 0,
        'raster-brightness-max': 1,
        'raster-contrast': 0,
        'raster-saturation': 0
      },
      layout: {
        'visibility': 'visible'
      },
      interactive: false // Disable click interactions
    });

    // Opacity slider listener (only add once per layer, but since it's per-layer, it's fine here)
    document.getElementById("raster-opacity-slider").addEventListener("input", (event) => {
      const opacityValue = event.target.value; // Get the current value of the slider
      if (map.getLayer(layerId)) { // Safety check
        map.setPaintProperty(layerId, 'raster-opacity', parseFloat(opacityValue)); // Update the layer's opacity
      }
    });

    // Add mask for the polygon
    const maskSourceId = `${polygon.id}-mask-source`;

    map.addSource(maskSourceId, {
      type: 'geojson',
      data: {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'Polygon',
          coordinates: polygon.coordinates
        }
      }
    });

    map.addLayer({
      id: maskLayerId,
      type: 'fill',
      source: maskSourceId,
      paint: {
        'fill-opacity': 0, // Set back to 0 for invisibility after debugging
        'fill-outline-color': '#000'
      }
    }, layerId); // Ensure mask layer is above raster layer

    // Add interactivity (only if not already added)
    if (!addedLayers.has(maskLayerId)) {
      const popup = new maplibregl.Popup();

      map.on('click', maskLayerId, (e) => {
        if (polygon.description) {
          popup
            .setLngLat(e.lngLat)
            .setHTML(polygon.description)
            .addTo(map);
          map.easeTo({
            center: e.lngLat,
            zoom: map.getZoom(), // Maintain current zoom level
            duration: 1000 // Set duration to 1000ms (1 second) or higher for a slower transition
          });
          activePolygonPopups.forEach((p) => p.remove());
          activeMarkerPopups.forEach((p) => p.remove());
          CloseALL();
          activePolygonPopups.push(popup);
          applyAllStyles();
        }
        if (currentUfoModel) {
          scene.remove(currentUfoModel);
          crosshair.style.display = "none";
        }
      });

      // Add a listener for the popup's close event
      popup.on('close', () => {
        if (currentUfoModel) {
          scene.add(currentUfoModel);
          crosshair.style.display = "block";
          // Remove popup from tracking array when closed
          const index = activePolygonPopups.indexOf(popup);
          if (index > -1) {
            activePolygonPopups.splice(index, 1);
          }
        }
      });

      map.on('mouseenter', maskLayerId, () => {
        map.getCanvas().style.cursor = 'pointer';
      });

      map.on('mouseleave', maskLayerId, () => {
        map.getCanvas().style.cursor = '';
      });

      // Mark this layer as added
      addedLayers.add(maskLayerId);
    }
  } catch (error) {
    console.error('Error loading or resizing image:', error);
  }
}

      const leftUpButton = document.getElementById("left-up");
      const leftLeftButton = document.getElementById("left-left");
      const leftRightButton = document.getElementById("left-right");
      const leftDownButton = document.getElementById("left-down");

      const rightUpButton = document.getElementById("right-up");
      const rightLeftButton = document.getElementById("right-left");
      const rightRightButton = document.getElementById("right-right");
      const rightDownButton = document.getElementById("right-down");

      const activeIntervals = new Set();

      function setupButton(buttonElement, action) {
        let intervalId;

        const startAction = (event) => {
          event.preventDefault();
          if (!intervalId) {
            intervalId = setInterval(action, 16); // 60fps timing
            activeIntervals.add(intervalId);
          }
        };

        const stopAction = () => {
          if (intervalId) {
            clearInterval(intervalId);
            activeIntervals.delete(intervalId);
            intervalId = null;
          }
        };

        buttonElement.addEventListener("mousedown", startAction);
        buttonElement.addEventListener("mouseup", stopAction);
        buttonElement.addEventListener("mouseleave", stopAction);

        buttonElement.addEventListener("touchstart", startAction);
        buttonElement.addEventListener("touchend", stopAction);
        buttonElement.addEventListener("touchcancel", stopAction);
      }

      setupButton(leftUpButton, () => map.panBy([0, -BUTTON_PAN_SPEED * getSpeedMultiplier()], { animate: false }));
      setupButton(leftDownButton, () => map.panBy([0, BUTTON_PAN_SPEED * getSpeedMultiplier()], { animate: false }));
      setupButton(leftLeftButton, () => map.panBy([-BUTTON_PAN_SPEED * getSpeedMultiplier(), 0], { animate: false }));
      setupButton(leftRightButton, () => map.panBy([BUTTON_PAN_SPEED * getSpeedMultiplier(), 0], { animate: false }));

      setupButton(rightUpButton, () => map.setZoom(map.getZoom() + BUTTON_ZOOM_SPEED * getSpeedMultiplier()));
      setupButton(rightDownButton, () => map.setZoom(map.getZoom() - BUTTON_ZOOM_SPEED * getSpeedMultiplier()));

      setupButton(rightLeftButton, () => map.setBearing(map.getBearing() - MOVE_SPEED * getSpeedMultiplier()));
      setupButton(rightRightButton, () => map.setBearing(map.getBearing() + MOVE_SPEED * getSpeedMultiplier()));

      setupButton(document.getElementById("zoom-in"), () => map.setPitch(map.getPitch() + 1 * getSpeedMultiplier()));
      setupButton(document.getElementById("zoom-out"), () => map.setPitch(map.getPitch() - 1 * getSpeedMultiplier()));

      window.addEventListener("beforeunload", () => {
        activeIntervals.forEach(interval => clearInterval(interval));
        activeIntervals.clear();
      });

      // Add event listeners for the new buttons
      document.getElementById("button1").addEventListener("click", async (event) => {
        event.stopPropagation();
        const inputValue = document.getElementById("toolbar-input").value;

        try {
          const topicId = "0.0.9609881";
          const cleanUrl = inputValue.replace(/\?network=mainnet$/, "");

          const messageData = {
            data: {
              urls: [cleanUrl],
            },
          };
          const message = JSON.stringify(messageData);

          const receipt = await sdk.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile picture updated successfully:", receipt);

          document.getElementById("toolbar-input").value = "";

        } catch (error) {
          console.error("Error updating profile picture:", error);
          // Removed alert
        }
      });

      document.getElementById("button2").addEventListener("click", async (event) => {
  event.stopPropagation();
  const inputValue = document.getElementById("toolbar-input").value;

  // Check if inputValue has less than 20 characters
  if (inputValue.length >= 20) {
    console.error("Input must be less than 20 characters");
    return; // Exit the function if the input is too long
  }

  try {
    const topicId = "0.0.9609904";

    const messageData = {
      data: {
        username: inputValue,
      },
    };
    const message = JSON.stringify(messageData);

    const receipt = await sdk.submitMessageToTopic(topicId, message);
    console.log("Username updated successfully:", receipt);

    document.getElementById("toolbar-input").value = "";
  } catch (error) {
    console.error("Error updating username:", error);
  }
});

      // Add event listeners for the new buttons
      document.getElementById("button_for_click_url").addEventListener("click", async (event) => {
        event.stopPropagation();
        const inputValue = document.getElementById("toolbar-input").value;

        try {
          const topicId = "0.0.9752486";
          const cleanUrl = inputValue.replace(/\?network=mainnet$/, "");

          const messageData = {
            data: {
              click2url: [cleanUrl],
            },
          };
          const message = JSON.stringify(messageData);

          const receipt = await sdk.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile CLICK2URL updated successfully:", receipt);

          document.getElementById("toolbar-input").value = "";

        } catch (error) {
          console.error("Error updating profile CLICK2URL:", error);
          // Removed alert
        }
      });

document.getElementById("button_for_topic2pic").addEventListener("click", async (event) => {
  event.stopPropagation();
  const inputValue = document.getElementById("Edit_Profile-topic-id").value;
  if (inputValue.length >= 20) {
    console.error("Input must be less than 20 characters");
    return;
  }
  try {
    const topicId = "0.0.9759201";
    const messageData = {
      data: {
        topic2pic: [inputValue],
      },
    };
    const message = JSON.stringify(messageData);
    const receipt = await sdk.submitMessageToTopic(
      topicId,
      message
    );
    console.log("Profile TOPIC2PIC updated successfully:", receipt);
    document.getElementById("Edit_Profile-topic-id").value = "";
  } catch (error) {
    console.error("Error updating profile TOPIC2PIC:", error);
  }
});


  // Add these variables to manage visibility states
  let markersVisible = false;
  let polygonsVisible = true;

  // Function to toggle markers visibility
  function toggleMarkers() {
      markersVisible = !markersVisible;
      existingMarkers.forEach(marker => {
          // Check if the marker element exists and toggle its visibility
          if (marker.getElement()) {
              if (markersVisible) {
                  marker.getElement().style.display = 'block'; // Show marker
                  marker.addTo(map); // Add marker back to the map
              } else {
                  marker.getElement().style.display = 'none'; // Hide marker
                  marker.remove(); // Remove marker from the map
              }
          }
      });
      // Update the button state text
      document.getElementById("marker-visibility-value").textContent = markersVisible ? "On" : "Off";

      // Prevent updating clusters if markers are not visible
      if (!markersVisible) {
          map.off("moveend", debouncedUpdateClusters); // Unsubscribe from moveend event
      } else {
          map.on("moveend", debouncedUpdateClusters); // Subscribe back to moveend event
      }
  }

  toggleMarkers();

  // Function to toggle polygons visibility
  function togglePolygons() {
      polygonsVisible = !polygonsVisible; // Toggle state

      polygons.forEach(polygon => {
          const layerId = `${polygon.id}-image-layer`;
          const maskLayerId = `${polygon.id}-mask-layer`; // Define the mask layer ID

          if (map.getLayer(layerId)) {
              const visibility = polygonsVisible ? 'visible' : 'none'; // Set visibility based on the current state
              map.setLayoutProperty(layerId, 'visibility', visibility);
              map.setLayoutProperty(maskLayerId, 'visibility', visibility); // Also toggle the mask layer visibility
          }
      });

      document.getElementById("polygon-visibility-value").textContent = polygonsVisible ? "On" : "Off"; // Update button state
  }

  document.getElementById("toggle-polygon-visibility").addEventListener("click", togglePolygons);

  document.getElementById("toggle-marker-visibility").addEventListener("click", () => {
      toggleMarkers(); // Call the toggle function directly
  });

document.getElementById("buttonforobject").addEventListener("click", async (event) => {
        event.stopPropagation();
        const inputValue = document.getElementById("object-input").value;

        try {
          const topicId = "0.0.9609898";
          const cleanUrl = inputValue.replace(/\?network=mainnet$/, "");

          const messageData = {
            data: {
              settings: [],
              urls: [cleanUrl],
            },
          };
          const message = JSON.stringify(messageData);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile picture updated successfully:", receipt);

          document.getElementById("object-input").value = "";

        } catch (error) {
          console.error("Error updating profile picture:", error);
          // Removed alert
        }
      });

async function loadProfileObject() {

  const topicId = "0.0.9609898";
  const accountObjectUrl = []; // Initialize an empty array to store account URLs
  try {
        const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

        // Check if result exists and has messages
        if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            console.log("No profile object found, using defaults");
            return accountObjectUrl; // Return empty array if no messages
        }

        // Filter messages to find those from the current user
        const userMessages = result.messages.filter(message => message.payer === globalAccountId);

        // Get the last message from the filtered user messages
        const lastMessage = userMessages[userMessages.length - 1];

        // Check if the last message has valid data
        if (lastMessage && lastMessage.data && lastMessage.data.urls && lastMessage.data.urls.length > 0) {
            // Store the URL for this account
            accountObjectUrl.push(lastMessage.data.urls[0]); // Accessing the first URL
        }

        return accountObjectUrl; // Return the populated array

    } catch (error) {
        console.log("Error in loadProfileObject:", error);
        return []; // Return empty array instead of throwing error
  }
}


document.getElementById("savesettings").addEventListener("click", async (event) => {
event.stopPropagation();

  try {
            const topicId = "0.0.9609898";
            const profileObjectUrl = await loadProfileObject();
            const cleanUrl = (profileObjectUrl.length > 0 ? profileObjectUrl[0].replace(/\?network=mainnet$/, "") : defaultModelUrl);

            const rotationX = document.getElementById("rotation-x").value;
            const rotationY = document.getElementById("rotation-y").value;
            const rotationZ = document.getElementById("rotation-z").value;

            const positionX = document.getElementById("position-x").value;
            const positionY = document.getElementById("position-y").value;
            const positionZ = document.getElementById("position-z").value;

            const scaleFactor = document.getElementById("scale-factor").value;

            // Construct the message data
            const messageData = {
                data: {
                    settings : {
                      rotation: {
                        x: rotationX,
                        y: rotationY,
                        z: rotationZ
                    },
                    position: {
                        x: positionX,
                        y: positionY,
                        z: positionZ
                    },
                    scale: {
                      scaleFactor
                    },
                },
                urls: [cleanUrl],
              },
            };

            const message = JSON.stringify(messageData);

            const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
                topicId,
                message
            );
            console.log("Profile settings updated successfully:", receipt);

        } catch (error) {
            console.error("Error updating settings picture:", error);
            // Removed alert
        }
      });



async function loadProfileSettings() {
const topicId = "0.0.9609898";
const accountObjectSettings = []; // Initialize an empty array to store account Settings
try {
    const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

    // Check if result exists and has messages
    if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
        return accountObjectSettings; // Return empty array if no messages
    }

    // Filter messages to find those from the current user
    const userMessages = result.messages.filter(message => message.payer === globalAccountId);

    // Get the last message from the filtered user messages
    const lastMessage = userMessages[userMessages.length - 1];

    // Check if the last message has valid data
    if (lastMessage && lastMessage.data) {

      // Check if settings are empty
      if (Array.isArray(lastMessage.data.settings) && lastMessage.data.settings.length === 0) {
        const urls = lastMessage.data.urls; // This will give you the entire array
        // Store the settings in accountObjectSettings
        accountObjectSettings.push({ urls });
      } else {
        // Extract relevant data
        const { rotation, position, scale } = lastMessage.data.settings;
        const urls = lastMessage.data.urls; // This will give you the entire array

        // Store the settings in accountObjectSettings
        accountObjectSettings.push({ rotation, position, scale, urls });

        // Update input fields with the extracted data
        document.getElementById("rotation-x").value = rotation.x; // Set rotation X
        document.getElementById("rotation-x-value").value = rotation.x; // Set rotation X value
        document.getElementById("rotation-y").value = rotation.y; // Set rotation Y
        document.getElementById("rotation-y-value").value = rotation.y; // Set rotation Y value
        document.getElementById("rotation-z").value = rotation.z; // Set rotation Z
        document.getElementById("rotation-z-value").value = rotation.z; // Set rotation Z value

        document.getElementById("position-x").value = position.x; // Set position X
        document.getElementById("position-x-value").value = position.x; // Set position X value
        document.getElementById("position-y").value = position.y; // Set position Y
        document.getElementById("position-y-value").value = position.y; // Set position Y value
        document.getElementById("position-z").value = position.z; // Set position Z
        document.getElementById("position-z-value").value = position.z; // Set position Z value

        // Add scale factor input update
        document.getElementById("scale-factor").value = scale.scaleFactor; // Update scale factor input
        document.getElementById("scale-factor-value").value = scale.scaleFactor; // Update scale factor value

        // Update the object's position and rotation
        const ufoModel = scene.getObjectByName('gltfModel'); // Assuming the UFO model is named 'ufo'
        if (ufoModel) {
            ufoModel.rotation.x = THREE.MathUtils.degToRad(rotation.x);
            ufoModel.rotation.y = THREE.MathUtils.degToRad(rotation.y);
            ufoModel.rotation.z = THREE.MathUtils.degToRad(rotation.z);
            ufoModel.position.set(position.x, position.y, position.z);
            ufoModel.scale.set(scale.scaleFactor, scale.scaleFactor, scale.scaleFactor); // Scale the model
        }
      }
    } else {
      console.log("Last message does not have valid data."); // Log invalid data
    }

              // Check if accountObjectSettings is empty and set default model URL
              if (accountObjectSettings.length === 0) {
        await loadUfoModel(defaultModelUrl); // Load the default model
    }

    return accountObjectSettings; // Return the populated array
} catch (error) {
    console.log("Error in loadProfileSettings:", error);
    return []; // Return empty array instead of throwing error
}
}


// Add event listeners for the new buttons
document.getElementById("savecrosshair").addEventListener("click", async (event) => {
event.stopPropagation();

        try {
            const topicId = "0.0.9609927";

            const colorRed = document.getElementById("color-red").value;
            const colorGreen = document.getElementById("color-green").value;
            const colorBlue = document.getElementById("color-blue").value;

            const crosshairBeforeWidth = document.getElementById("crosshair-before-after").value;
            const crosshairAfterHeight = document.getElementById("crosshair-after-before").value;

            // Construct the message data
            const messageData = {
                data: {
                    color: {
                        red: colorRed,
                        green: colorGreen,
                        blue: colorBlue
                    },
                    crosshair: {
                        beforeWidth: crosshairBeforeWidth,
                        afterHeight: crosshairAfterHeight
                    }
                },
            };

            const message = JSON.stringify(messageData);

            const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
                topicId,
                message
            );
            console.log("Profile settings updated successfully:", receipt);

        } catch (error) {
            console.error("Error updating settings picture:", error);
            // Removed alert
        }
      });

      

async function loadProfileCrosshair() {
  const topicId = "0.0.9609927";
  const accountObjectSettings = []; // Initialize an empty array to store account Settings
  try {
    const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

    // Check if result exists and has messages
    if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
        return accountObjectSettings; // Return empty array if no messages
    }

    // Filter messages to find those from the current user
    const userMessages = result.messages.filter(message => message.payer === globalAccountId);

    // Get the last message from the filtered user messages
    const lastMessage = userMessages[userMessages.length - 1];

    // Check if the last message has valid data
    if (lastMessage && lastMessage.data) {

        // Extract relevant data
        const { rotation, position, color, scale, crosshair } = lastMessage.data;

        // Store the settings in accountObjectSettings
        accountObjectSettings.push({
            color,
            crosshair
        });

        document.getElementById("color-red").value = color.red; // Set color red
        document.getElementById("color-red-value").value = color.red; // Set color red value
        document.getElementById("color-green").value = color.green; // Set color green
        document.getElementById("color-green-value").value = color.green; // Set color green value
        document.getElementById("color-blue").value = color.blue; // Set color blue
        document.getElementById("color-blue-value").value = color.blue; // Set color blue value

        document.getElementById("crosshair-before-after").value = crosshair.beforeWidth; // Set crosshair before width
        document.getElementById("crosshair-before-after-value").value = crosshair.beforeWidth; // Set crosshair before width value
        document.getElementById("crosshair-after-before").value = crosshair.afterHeight; // Set crosshair after height
        document.getElementById("crosshair-after-before-value").value = crosshair.afterHeight; // Set crosshair after height value

        // Call update functions to apply the loaded values
        updateColorCrosshair(); // Update crosshair color
        updateCrosshairBeforeAfter(crosshair.beforeWidth); // Update crosshair before width
        updateCrosshairAfterBefore(crosshair.afterHeight); // Update crosshair after height

    } else {
        console.log("Last message does not have valid data."); // Log invalid data
    }

    return accountObjectSettings; // Return the populated array

} catch (error) {
    console.log("Error in loadProfileCrosshair:", error);
    return []; // Return empty array instead of throwing error
}
}

function updateCrosshairBeforeAfter(value) {
    const crosshair = document.getElementById("crosshair");
    crosshair.style.setProperty('--crosshair-before-width', `${value}px`); // Width of ::before
    crosshair.style.setProperty('--crosshair-after-height', `${value}px`); // Height of ::after
}

function updateCrosshairAfterBefore(value) {
    const crosshair = document.getElementById("crosshair");
    crosshair.style.setProperty('--crosshair-after-width', `${value}px`); // Width of ::after
    crosshair.style.setProperty('--crosshair-before-height', `${value}px`); // Height of ::before
}

// Add event listeners for crosshair size sliders
document.getElementById("crosshair-before-after").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("crosshair-before-after-value").textContent = value;
    updateCrosshairBeforeAfter(value);
    document.getElementById("crosshair-before-after-value").value = value; // Update number input
});

document.getElementById("crosshair-after-before").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("crosshair-after-before-value").textContent = value;
    updateCrosshairAfterBefore(value);
    document.getElementById("crosshair-after-before-value").value = value; // Update number input
});

// Add event listeners for number inputs to update sliders
document.getElementById("crosshair-before-after-value").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("crosshair-before-after").value = value; // Update range input
    updateCrosshairBeforeAfter(value);
});

document.getElementById("crosshair-after-before-value").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("crosshair-after-before").value = value; // Update range input
    updateCrosshairAfterBefore(value);
});

function applyAllStyles() {
    updatePopupBorder();
    updatePopupNumber();
    updatePopupClose();
    updatePopupAccid();
    updatePopupUsername();
    updatePopupTitles();
    updatePopupText();
    updatePopupFontSize();
}

document.getElementById("color-red").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-red-value").textContent = value; // Update displayed value
    document.getElementById("color-red-value").value = value; // Update number input
    updateColorCrosshair(); // Call function to update color immediately
});

document.getElementById("color-green").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-green-value").textContent = value; // Update displayed value
    document.getElementById("color-green-value").value = value; // Update number input
    updateColorCrosshair(); // Call function to update color immediately
});

document.getElementById("color-blue").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-blue-value").textContent = value; // Update displayed value
    document.getElementById("color-blue-value").value = value; // Update number input
    updateColorCrosshair(); // Call function to update color immediately
});

document.getElementById("color-red-value").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-red").value = value; // Update range input
    updateColorCrosshair(); // Call function to update color immediately
});

document.getElementById("color-green-value").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-green").value = value; // Update range input
    updateColorCrosshair(); // Call function to update color immediately
});

document.getElementById("color-blue-value").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-blue").value = value; // Update range input
    updateColorCrosshair(); // Call function to update color immediately
});

// Function to update the color based on slider values
function updateColorCrosshair() {
    const red = document.getElementById("color-red").value;
    const green = document.getElementById("color-green").value;
    const blue = document.getElementById("color-blue").value;

    // Construct the RGB color string
    const color = `rgb(${red}, ${green}, ${blue})`;

    // Change the color of the crosshair
    const crosshair = document.getElementById("crosshair");
    if (crosshair) {
        crosshair.style.setProperty('--crosshair-color', color);
    }
}

document.getElementById("savepopup").addEventListener("click", async (event) => {
event.stopPropagation();

        try {
            const topicId = "0.0.9771374";

    const colorRedBorder = Math.min(parseInt(document.getElementById("color-red-border").value) || 0, 255);
    const colorGreenBorder = Math.min(parseInt(document.getElementById("color-green-border").value) || 0, 255);
    const colorBlueBorder = Math.min(parseInt(document.getElementById("color-blue-border").value) || 0, 255);

    const colorRedNumber = Math.min(parseInt(document.getElementById("color-red-number").value) || 0, 255);
    const colorGreenNumber = Math.min(parseInt(document.getElementById("color-green-number").value) || 0, 255);
    const colorBlueNumber = Math.min(parseInt(document.getElementById("color-blue-number").value) || 0, 255);

    const colorRedClose = Math.min(parseInt(document.getElementById("color-red-close").value) || 0, 255);
    const colorGreenClose = Math.min(parseInt(document.getElementById("color-green-close").value) || 0, 255);
    const colorBlueClose = Math.min(parseInt(document.getElementById("color-blue-close").value) || 0, 255);

    const colorRedUsername = Math.min(parseInt(document.getElementById("color-red-username").value) || 0, 255);
    const colorGreenUsername = Math.min(parseInt(document.getElementById("color-green-username").value) || 0, 255);
    const colorBlueUsername = Math.min(parseInt(document.getElementById("color-blue-username").value) || 0, 255);

    const colorRedAccid = Math.min(parseInt(document.getElementById("color-red-accid").value) || 0, 255);
    const colorGreenAccid = Math.min(parseInt(document.getElementById("color-green-accid").value) || 0, 255);
    const colorBlueAccid = Math.min(parseInt(document.getElementById("color-blue-accid").value) || 0, 255);

    const colorRedText = Math.min(parseInt(document.getElementById("color-red-text").value) || 0, 255);
    const colorGreenText = Math.min(parseInt(document.getElementById("color-green-text").value) || 0, 255);
    const colorBlueText = Math.min(parseInt(document.getElementById("color-blue-text").value) || 0, 255);

    const colorRedTitles = Math.min(parseInt(document.getElementById("color-red-titles").value) || 0, 255);
    const colorGreenTitles = Math.min(parseInt(document.getElementById("color-green-titles").value) || 0, 255);
    const colorBlueTitles = Math.min(parseInt(document.getElementById("color-blue-titles").value) || 0, 255);

    const popupFontSize = Math.min(parseInt(document.getElementById("popup-font-size").value) || 0.5, 10);

            const messageData = {
                data: {
                    colorBorder: {
                        redBorder: colorRedBorder,
                        greenBorder: colorGreenBorder,
                        blueBorder: colorBlueBorder
                    },
                    colorNumber: {
                        redNumber: colorRedNumber,
                        greenNumber: colorGreenNumber,
                        blueNumber: colorBlueNumber
                    },
                    colorClose: {
                        redClose: colorRedClose,
                        greenClose: colorGreenClose,
                        blueClose: colorBlueClose
                    },
                    colorUsername: {
                        redUsername: colorRedUsername,
                        greenUsername: colorGreenUsername,
                        blueUsername: colorBlueUsername
                    },
                    colorAccid: {
                        redAccid: colorRedAccid,
                        greenAccid: colorGreenAccid,
                        blueAccid: colorBlueAccid
                    },
                    colorText: {
                        redText: colorRedText,
                        greenText: colorGreenText,
                        blueText: colorBlueText
                    },
                    colorTitles: {
                        redTitles: colorRedTitles,
                        greenTitles: colorGreenTitles,
                        blueTitles: colorBlueTitles
                    },
                    popupFontSize: {
                        popupFontSize: popupFontSize
                    }
                },
            };

            const message = JSON.stringify(messageData);

            const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
                topicId,
                message
            );
            console.log("Profile settings updated successfully:", receipt);

        } catch (error) {
            console.error("Error updating settings picture:", error);
            // Removed alert
        }
      });

async function loadProfilePopup() {
    const topicId = "0.0.9771374";
    const accountObjectSettings = []; // Initialize an empty array to store account Settings
    try {
        const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
        // Check if result exists and has messages
        if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            return accountObjectSettings; // Return empty array if no messages
        }

        // Filter messages to find those from the current user
        const userMessages = result.messages.filter(message => message.payer === globalAccountId);

        // Get the last message from the filtered user messages
        const lastMessage = userMessages[userMessages.length - 1];

        // Check if the last message has valid data
        if (lastMessage && lastMessage.data) {
            // Extract relevant data and clamp to max 255
            const { colorBorder, colorNumber, colorClose, colorUsername, colorAccid, colorText, colorTitles, popupFontSize } = lastMessage.data;

            // Clamp values to max 255
            const clampedColorBorder = {
                redBorder: Math.min(parseInt(colorBorder.redBorder) || 0, 255),
                greenBorder: Math.min(parseInt(colorBorder.greenBorder) || 0, 255),
                blueBorder: Math.min(parseInt(colorBorder.blueBorder) || 0, 255)
            };
            const clampedColorNumber = {
                redNumber: Math.min(parseInt(colorNumber.redNumber) || 0, 255),
                greenNumber: Math.min(parseInt(colorNumber.greenNumber) || 0, 255),
                blueNumber: Math.min(parseInt(colorNumber.blueNumber) || 0, 255)
            };
            const clampedColorClose = {
                redClose: Math.min(parseInt(colorClose.redClose) || 0, 255),
                greenClose: Math.min(parseInt(colorClose.greenClose) || 0, 255),
                blueClose: Math.min(parseInt(colorClose.blueClose) || 0, 255)
            };
            const clampedColorUsername = {
                redUsername: Math.min(parseInt(colorUsername.redUsername) || 0, 255),
                greenUsername: Math.min(parseInt(colorUsername.greenUsername) || 0, 255),
                blueUsername: Math.min(parseInt(colorUsername.blueUsername) || 0, 255)
            };
            const clampedColorAccid = {
                redAccid: Math.min(parseInt(colorAccid.redAccid) || 0, 255),
                greenAccid: Math.min(parseInt(colorAccid.greenAccid) || 0, 255),
                blueAccid: Math.min(parseInt(colorAccid.blueAccid) || 0, 255)
            };
            const clampedColorText = {
                redText: Math.min(parseInt(colorText.redText) || 0, 255),
                greenText: Math.min(parseInt(colorText.greenText) || 0, 255),
                blueText: Math.min(parseInt(colorText.blueText) || 0, 255)
            };
            const clampedColorTitles = {
                redTitles: Math.min(parseInt(colorTitles.redTitles) || 0, 255),
                greenTitles: Math.min(parseInt(colorTitles.greenTitles) || 0, 255),
                blueTitles: Math.min(parseInt(colorTitles.blueTitles) || 0, 255)
            };
            const clampedPopupFontSize = Math.min(parseInt(popupFontSize.popupFontSize) || 0.5, 10);
            // Store the clamped settings in accountObjectSettings
            accountObjectSettings.push({
                colorBorder: clampedColorBorder,
                colorUsername: clampedColorUsername,
                colorAccid: clampedColorAccid,
                colorText: clampedColorText,
                colorTitles: clampedColorTitles,
                popupFontSize: clampedPopupFontSize
            });

            document.getElementById("color-red-border").value = clampedColorBorder.redBorder;
            document.getElementById("color-green-border").value = clampedColorBorder.greenBorder;
            document.getElementById("color-blue-border").value = clampedColorBorder.blueBorder;

            document.getElementById("color-red-number").value = clampedColorNumber.redNumber;
            document.getElementById("color-green-number").value = clampedColorNumber.greenNumber;
            document.getElementById("color-blue-number").value = clampedColorNumber.blueNumber;

            document.getElementById("color-red-close").value = clampedColorClose.redClose;
            document.getElementById("color-green-close").value = clampedColorClose.greenClose;
            document.getElementById("color-blue-close").value = clampedColorClose.blueClose;

            document.getElementById("color-red-username").value = clampedColorUsername.redUsername;
            document.getElementById("color-green-username").value = clampedColorUsername.greenUsername;
            document.getElementById("color-blue-username").value = clampedColorUsername.blueUsername;

            document.getElementById("color-red-accid").value = clampedColorAccid.redAccid;
            document.getElementById("color-green-accid").value = clampedColorAccid.greenAccid;
            document.getElementById("color-blue-accid").value = clampedColorAccid.blueAccid;

            document.getElementById("color-red-text").value = clampedColorText.redText;
            document.getElementById("color-green-text").value = clampedColorText.greenText;
            document.getElementById("color-blue-text").value = clampedColorText.blueText;

            document.getElementById("color-red-titles").value = clampedColorTitles.redTitles;
            document.getElementById("color-green-titles").value = clampedColorTitles.greenTitles;
            document.getElementById("color-blue-titles").value = clampedColorTitles.blueTitles;

            document.getElementById("popup-font-size").value = clampedPopupFontSize;

            // Call update functions to apply the loaded values
            updatePopupBorder();
            updatePopupNumber();
            updatePopupClose();
            updatePopupAccid();
            updatePopupUsername();
            updatePopupTitles();
            updatePopupText();
            updatePopupFontSize();

        } else {
            console.log("Last message does not have valid data.");
        }

        return accountObjectSettings;

    } catch (error) {
        console.log("Error in loadProfilePopup:", error);
        return [];
    }
}

document.getElementById("color-red-border").addEventListener("input", (event) => {updatePopupBorder();});

document.getElementById("color-green-border").addEventListener("input", (event) => {updatePopupBorder();});

document.getElementById("color-blue-border").addEventListener("input", (event) => {updatePopupBorder();});

document.getElementById("color-red-number").addEventListener("input", (event) => {updatePopupNumber();});

document.getElementById("color-green-number").addEventListener("input", (event) => {updatePopupNumber();});

document.getElementById("color-blue-number").addEventListener("input", (event) => {updatePopupNumber();});

document.getElementById("color-red-close").addEventListener("input", (event) => {updatePopupClose();});

document.getElementById("color-green-close").addEventListener("input", (event) => {updatePopupClose();});

document.getElementById("color-blue-close").addEventListener("input", (event) => {updatePopupClose();});

document.getElementById("color-red-accid").addEventListener("input", (event) => {updatePopupAccid();});

document.getElementById("color-green-accid").addEventListener("input", (event) => {updatePopupAccid();});

document.getElementById("color-blue-accid").addEventListener("input", (event) => {updatePopupAccid();});

document.getElementById("color-red-username").addEventListener("input", (event) => {updatePopupUsername();});

document.getElementById("color-green-username").addEventListener("input", (event) => {updatePopupUsername();});

document.getElementById("color-blue-username").addEventListener("input", (event) => {updatePopupUsername();});

document.getElementById("color-red-titles").addEventListener("input", (event) => {updatePopupTitles();});

document.getElementById("color-green-titles").addEventListener("input", (event) => {updatePopupTitles();});

document.getElementById("color-blue-titles").addEventListener("input", (event) => {updatePopupTitles();});

document.getElementById("color-red-text").addEventListener("input", (event) => {updatePopupText();});

document.getElementById("color-green-text").addEventListener("input", (event) => {updatePopupText();});

document.getElementById("color-blue-text").addEventListener("input", (event) => {updatePopupText();});

document.getElementById("popup-font-size").addEventListener("input", (event) => {updatePopupFontSize();});

function updatePopupBorder() {
    const red_border = document.getElementById("color-red-border").value;
    const green_border = document.getElementById("color-green-border").value;
    const blue_border = document.getElementById("color-blue-border").value;
    const color_border = `rgb(${red_border}, ${green_border}, ${blue_border})`;

    const popupContents = document.querySelectorAll('.maplibregl-popup');

    popupContents.forEach(popup => {
        popup.style.borderColor = color_border;
    });
}

function updatePopupNumber() {

    const red_number = document.getElementById("color-red-number").value;
    const green_number = document.getElementById("color-green-number").value;
    const blue_number = document.getElementById("color-blue-number").value;
    const color_number = `rgb(${red_number}, ${green_number}, ${blue_number})`;

    const popupNumbers = document.querySelectorAll('.maplibregl-popup .number');

    popupNumbers.forEach(number => {
        number.style.color = color_number;
    });
}

function updatePopupClose() {

    const red_close = document.getElementById("color-red-close").value;
    const green_close = document.getElementById("color-green-close").value;
    const blue_close = document.getElementById("color-blue-close").value;
    const color_close = `rgb(${red_close}, ${green_close}, ${blue_close})`;

    const popupCloses = document.querySelectorAll('.maplibregl-popup-close-button');

    popupCloses.forEach(close => {
        close.style.color = color_close;
    });
}

function updatePopupAccid() {
    const red_accid = document.getElementById("color-red-accid").value;
    const green_accid = document.getElementById("color-green-accid").value;
    const blue_accid = document.getElementById("color-blue-accid").value;
    const color_accid = `rgb(${red_accid}, ${green_accid}, ${blue_accid})`;

    const popupAccids = document.querySelectorAll('.maplibregl-popup .payer-info');

    popupAccids.forEach(accid => {
        accid.style.color = color_accid;
    });
}

function updatePopupUsername() {
    const red_username = document.getElementById("color-red-username").value;
    const green_username = document.getElementById("color-green-username").value;
    const blue_username = document.getElementById("color-blue-username").value;
    const color_username = `rgb(${red_username}, ${green_username}, ${blue_username})`;

    const popupUsernames = document.querySelectorAll('.maplibregl-popup .username');

    popupUsernames.forEach(username => {
        username.style.color = color_username;
    });
}

function updatePopupTitles() {
    const red_titles = document.getElementById("color-red-titles").value;
    const green_titles = document.getElementById("color-green-titles").value;
    const blue_titles = document.getElementById("color-blue-titles").value;
    const color_titles = `rgb(${red_titles}, ${green_titles}, ${blue_titles})`;

    const popupTitles = document.querySelectorAll('.maplibregl-popup .title_color');

    popupTitles.forEach(title => {
        title.style.color = color_titles;
    });
}

function updatePopupText() {
    const red_text = document.getElementById("color-red-text").value;
    const green_text = document.getElementById("color-green-text").value;
    const blue_text = document.getElementById("color-blue-text").value;
    const color_text = `rgb(${red_text}, ${green_text}, ${blue_text})`;

    const popupTexts = document.querySelectorAll('.maplibregl-popup .text_color');

    popupTexts.forEach(text => {
        text.style.color = color_text;
    });
}

function updatePopupFontSize() {
    const popupFontSize = document.getElementById("popup-font-size").value;
    const popupFontSizeValue = Math.min(parseInt(popupFontSize) || 0.5, 10);
    const popupTexts = document.querySelectorAll('.maplibregl-popup-content');
    popupTexts.forEach(text => {
        text.style.fontSize = `${popupFontSizeValue}vh`;
    });
}

document.getElementById("save-main-button").addEventListener("click", async (event) => {
    event.stopPropagation();
    
    try {
        const topicId = "0.0.9797981";
        
        const colorRedDisconnect = Math.min(parseInt(document.getElementById("color-red-disconnect-button").value) || 0, 255);
        const colorGreenDisconnect = Math.min(parseInt(document.getElementById("color-green-disconnect-button").value) || 0, 255);
        const colorBlueDisconnect = Math.min(parseInt(document.getElementById("color-blue-disconnect-button").value) || 0, 255);

        const colorRedMainButton = Math.min(parseInt(document.getElementById("color-red-main-button").value) || 0, 255);
        const colorGreenMainButton = Math.min(parseInt(document.getElementById("color-green-main-button").value) || 0, 255);
        const colorBlueMainButton = Math.min(parseInt(document.getElementById("color-blue-main-button").value) || 0, 255);

        const messageData = {
            data: {
                colorDisconnect: {
                    redDisconnect: colorRedDisconnect,
                    greenDisconnect: colorGreenDisconnect,
                    blueDisconnect: colorBlueDisconnect
                },
                colorMainButton: {
                    redMainButton: colorRedMainButton,
                    greenMainButton: colorGreenMainButton,
                    blueMainButton: colorBlueMainButton
                }
            }
        };

        const message = JSON.stringify(messageData);

        const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
        );
        console.log("Profile settings updated successfully:", receipt);

    } catch (error) {
        console.error("Error updating settings picture:", error);
    }
});

async function loadMainButtonSettings() {
    const topicId = "0.0.9797981";
    const accountObjectSettings = []; // Initialize an empty array to store account Settings
    try {
        const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
        // Check if result exists and has messages
        if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            return accountObjectSettings; // Return empty array if no messages
        }

        // Filter messages to find those from the current user
        const userMessages = result.messages.filter(message => message.payer === globalAccountId);

        // Get the last message from the filtered user messages
        const lastMessage = userMessages[userMessages.length - 1];

        // Check if the last message has valid data
        if (lastMessage && lastMessage.data) {
            // Extract relevant data and clamp to max 255
            const { colorDisconnect, colorMainButton } = lastMessage.data;

            const clampedColorDisconnect = {
                redDisconnect: Math.min(parseInt(colorDisconnect.redDisconnect) || 0, 255),
                greenDisconnect: Math.min(parseInt(colorDisconnect.greenDisconnect) || 0, 255),
                blueDisconnect: Math.min(parseInt(colorDisconnect.blueDisconnect) || 0, 255)
            };
            const clampedColorMainButton = {
                redMainButton: Math.min(parseInt(colorMainButton.redMainButton) || 0, 255),
                greenMainButton: Math.min(parseInt(colorMainButton.greenMainButton) || 0, 255),
                blueMainButton: Math.min(parseInt(colorMainButton.blueMainButton) || 0, 255)
            };

            accountObjectSettings.push({
                colorDisconnect: clampedColorDisconnect,
                colorMainButton: clampedColorMainButton
            });

            document.getElementById("color-red-disconnect-button").value = clampedColorDisconnect.redDisconnect;
            document.getElementById("color-green-disconnect-button").value = clampedColorDisconnect.greenDisconnect;
            document.getElementById("color-blue-disconnect-button").value = clampedColorDisconnect.blueDisconnect;
            document.getElementById("color-red-main-button").value = clampedColorMainButton.redMainButton;
            document.getElementById("color-green-main-button").value = clampedColorMainButton.greenMainButton;
            document.getElementById("color-blue-main-button").value = clampedColorMainButton.blueMainButton;

            updateMainButtonSettings();

        }

        return accountObjectSettings;

    } catch (error) {
        console.log("Error in loadMainButtonSettings:", error);
        return [];
    }
    }

    function updateMainButtonSettings() {
        const redDisconnect = document.getElementById("color-red-disconnect-button").value;
        const greenDisconnect = document.getElementById("color-green-disconnect-button").value;
        const blueDisconnect = document.getElementById("color-blue-disconnect-button").value;
        const redMainButton = document.getElementById("color-red-main-button").value;
        const greenMainButton = document.getElementById("color-green-main-button").value;
        const blueMainButton = document.getElementById("color-blue-main-button").value;
        const colorDisconnect = `rgb(${redDisconnect}, ${greenDisconnect}, ${blueDisconnect})`;
        const colorMainButton = `rgb(${redMainButton}, ${greenMainButton}, ${blueMainButton})`;
        const disconnectButton = document.querySelectorAll('#disconnect-wallet-btn');
        const mainButton_1 = document.querySelectorAll('.menu_buttons');
        const mainButton_2 = document.querySelectorAll('.options-and-topic');

        const disconnectButtons = document.querySelectorAll('#disconnect-wallet-btn');
        disconnectButtons.forEach(button => {
            button.style.backgroundColor = colorDisconnect;
        });

        // Update menu_buttons background color
        const menuButtons = document.querySelectorAll('.menu_buttons');
        menuButtons.forEach(button => {
            button.style.backgroundColor = colorMainButton;
        });

        // Update options-and-topic background color
        const optionsButtons = document.querySelectorAll('.options-and-topic');
        optionsButtons.forEach(button => {
            button.style.backgroundColor = colorMainButton;
        });
    }

    document.getElementById("color-red-disconnect-button").addEventListener("input", (event) => {updateMainButtonSettings();});
    document.getElementById("color-green-disconnect-button").addEventListener("input", (event) => {updateMainButtonSettings();});
    document.getElementById("color-blue-disconnect-button").addEventListener("input", (event) => {updateMainButtonSettings();});
    document.getElementById("color-red-main-button").addEventListener("input", (event) => {updateMainButtonSettings();});
    document.getElementById("color-green-main-button").addEventListener("input", (event) => {updateMainButtonSettings();});
    document.getElementById("color-blue-main-button").addEventListener("input", (event) => {updateMainButtonSettings();});

document.getElementById("save-marker-settings").addEventListener("click", async (event) => {
    event.stopPropagation();
    try {
        const topicId = "0.0.9796116";

        const sizeMarker = Math.min(parseInt(document.getElementById("Marker-Sizer").value) || 0, 255);
        const messageData = {
            data: {
                sizeMarker: sizeMarker
            }
        };

        const message = JSON.stringify(messageData);

        const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
        );
        console.log("Profile settings updated successfully:", receipt);

    } catch (error) {
        console.error("Error updating settings picture:", error);
    }
    
});

async function loadMarkerSettings() {
        const topicId = "0.0.9796116";
        const accountObjectSettings = []; // Initialize an empty array to store account Settings
        try {
            const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
            // Check if result exists and has messages
            if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
                return accountObjectSettings; // Return empty array if no messages
            }

            // Filter messages to find those from the current user
            const userMessages = result.messages.filter(message => message.payer === globalAccountId);

            // Get the last message from the filtered user messages
            const lastMessage = userMessages[userMessages.length - 1];

            // Check if the last message has valid data
            if (lastMessage && lastMessage.data) {
                // Extract relevant data and clamp to max 255
                const { sizeMarker } = lastMessage.data;

                const clampedSizeMarker = Math.min(parseInt(sizeMarker) || 0, 10);

                accountObjectSettings.push({
                    sizeMarker: clampedSizeMarker
                });

                document.getElementById("Marker-Size").value = clampedSizeMarker;

                updateMarkerSettings();
            }

            return accountObjectSettings;

        } catch (error) {
            console.log("Error in loadMarkerSettings:", error);
            return [];
        }
        }

function updateMarkerSettings() {
  const MarkerSize = document.getElementById("Marker-Size").value;
  currentMarkerSize = Math.min(parseInt(MarkerSize) || 5, 10);
  updateClusters();
}

document.getElementById("Marker-Size").addEventListener("input", (event) => {updateMarkerSettings();});

document.getElementById("save-button-button-input").addEventListener("click", async (event) => {
    event.stopPropagation();

    try {
        const topicId = "0.0.9798047";

        const colorRedBorderButtonInput = Math.min(parseInt(document.getElementById("color-red-border-button-input").value) || 0, 255);
        const colorGreenBorderButtonInput = Math.min(parseInt(document.getElementById("color-green-border-button-input").value) || 0, 255);
        const colorBlueBorderButtonInput = Math.min(parseInt(document.getElementById("color-blue-border-button-input").value) || 0, 255);

        const colorRedFontColorInput = Math.min(parseInt(document.getElementById("color-red-font-color-input-button-input").value) || 0, 255);
        const colorGreenFontColorInput = Math.min(parseInt(document.getElementById("color-green-font-color-input-button-input").value) || 0, 255);
        const colorBlueFontColorInput = Math.min(parseInt(document.getElementById("color-blue-font-color-input-button-input").value) || 0, 255);

        const colorRedButtonBorderButtonInput = Math.min(parseInt(document.getElementById("color-red-button-border-button-input").value) || 0, 255);
        const colorGreenButtonBorderButtonInput = Math.min(parseInt(document.getElementById("color-green-button-border-button-input").value) || 0, 255);
        const colorBlueButtonBorderButtonInput = Math.min(parseInt(document.getElementById("color-blue-button-border-button-input").value) || 0, 255);

        const colorRedOnhoverButtonInput = Math.min(parseInt(document.getElementById("color-red-onhover-button-input").value) || 0, 255);
        const colorGreenOnhoverButtonInput = Math.min(parseInt(document.getElementById("color-green-onhover-button-input").value) || 0, 255);
        const colorBlueOnhoverButtonInput = Math.min(parseInt(document.getElementById("color-blue-onhover-button-input").value) || 0, 255);

        const fontForButtonInput = Math.min(parseInt(document.getElementById("font-for-button-input").value) || 1.5, 10);
        const transparencyButtonInput = Math.min(parseInt(document.getElementById("color-red-transparency-button-input").value) || 0.5, 1);

        const colorRedFontColorButtonInput = Math.min(parseInt(document.getElementById("color-red-font-color-button-input").value) || 0, 255);
        const colorGreenFontColorButtonInput = Math.min(parseInt(document.getElementById("color-green-font-color-button-input").value) || 0, 255);
        const colorBlueFontColorButtonInput = Math.min(parseInt(document.getElementById("color-blue-font-color-button-input").value) || 0, 255);

        const messageData = {
            data: {
                colorBorderButtonInput: {
                    redBorderButtonInput: colorRedBorderButtonInput,
                    greenBorderButtonInput: colorGreenBorderButtonInput,
                    blueBorderButtonInput: colorBlueBorderButtonInput
                },
                fontForButtonInput: fontForButtonInput,
                transparencyButtonInput: transparencyButtonInput,

                colorFontColorButtonInput: {
                    redFontColorButtonInput: colorRedFontColorButtonInput,
                    greenFontColorButtonInput: colorGreenFontColorButtonInput,
                    blueFontColorButtonInput: colorBlueFontColorButtonInput
                },
                colorOnhoverButtonInput: {
                    redOnhoverButtonInput: colorRedOnhoverButtonInput,
                    greenOnhoverButtonInput: colorGreenOnhoverButtonInput,
                    blueOnhoverButtonInput: colorBlueOnhoverButtonInput
                },
                colorButtonBorderButtonInput: {
                    redButtonBorderButtonInput: colorRedButtonBorderButtonInput,
                    greenButtonBorderButtonInput: colorGreenButtonBorderButtonInput,
                    blueButtonBorderButtonInput: colorBlueButtonBorderButtonInput
                },
                colorFontColorInputButtonInput: {
                    redFontColorInputButtonInput: colorRedFontColorInput,
                    greenFontColorInputButtonInput: colorGreenFontColorInput,
                    blueFontColorInputButtonInput: colorBlueFontColorInput
                }
            }
        };

        const message = JSON.stringify(messageData);

        const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
        );
        console.log("Profile settings updated successfully:", receipt);

    } catch (error) {
        console.error("Error updating settings picture:", error);
    }

});

async function loadButtonInputSettings() {
            const topicId = "0.0.9798047";
            const accountObjectSettings = []; // Initialize an empty array to store account Settings
            try {
                const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
                // Check if result exists and has messages
                if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
                    return accountObjectSettings; // Return empty array if no messages
                }

                // Filter messages to find those from the current user
                const userMessages = result.messages.filter(message => message.payer === globalAccountId);

                // Get the last message from the filtered user messages
                const lastMessage = userMessages[userMessages.length - 1];

                // Check if the last message has valid data
                if (lastMessage && lastMessage.data) {
                    // Extract relevant data and clamp to max 255
                    const { colorBorderButtonInput, fontForButtonInput, transparencyButtonInput,
                       colorFontColorButtonInput, colorOnhoverButtonInput, colorButtonBorderButtonInput, colorFontColorInputButtonInput } = lastMessage.data;

                    const clampedColorBorderButtonInput = {
                        redBorderButtonInput: Math.min(parseInt(colorBorderButtonInput.redBorderButtonInput) || 0, 255),
                        greenBorderButtonInput: Math.min(parseInt(colorBorderButtonInput.greenBorderButtonInput) || 0, 255),
                        blueBorderButtonInput: Math.min(parseInt(colorBorderButtonInput.blueBorderButtonInput) || 0, 255)
                    };
                    const clampedFontForButtonInput = Math.min(parseInt(fontForButtonInput) || 1.5, 10);
                    const clampedTransparencyButtonInput = Math.min(parseInt(transparencyButtonInput) || 0.5, 1);


                    const clampedColorFontColorButtonInput = {
                        redFontColorButtonInput: Math.min(parseInt(colorFontColorButtonInput.redFontColorButtonInput) || 0, 255),
                        greenFontColorButtonInput: Math.min(parseInt(colorFontColorButtonInput.greenFontColorButtonInput) || 0, 255),
                        blueFontColorButtonInput: Math.min(parseInt(colorFontColorButtonInput.blueFontColorButtonInput) || 0, 255)
                    };

                    const clampedColorOnhoverButtonInput = {
                        redOnhoverButtonInput: Math.min(parseInt(colorOnhoverButtonInput.redOnhoverButtonInput) || 0, 255),
                        greenOnhoverButtonInput: Math.min(parseInt(colorOnhoverButtonInput.greenOnhoverButtonInput) || 0, 255),
                        blueOnhoverButtonInput: Math.min(parseInt(colorOnhoverButtonInput.blueOnhoverButtonInput) || 0, 255)
                    };

                    const clampedColorButtonBorderButtonInput = {
                        redButtonBorderButtonInput: Math.min(parseInt(colorButtonBorderButtonInput.redButtonBorderButtonInput) || 0, 255),
                        greenButtonBorderButtonInput: Math.min(parseInt(colorButtonBorderButtonInput.greenButtonBorderButtonInput) || 0, 255),
                        blueButtonBorderButtonInput: Math.min(parseInt(colorButtonBorderButtonInput.blueButtonBorderButtonInput) || 0, 255)
                    };

                    const clampedColorFontColorInputButtonInput = {
                        redFontColorInputButtonInput: Math.min(parseInt(colorFontColorInputButtonInput.redFontColorInputButtonInput) || 0, 255),
                        greenFontColorInputButtonInput: Math.min(parseInt(colorFontColorInputButtonInput.greenFontColorInputButtonInput) || 0, 255),
                        blueFontColorInputButtonInput: Math.min(parseInt(colorFontColorInputButtonInput.blueFontColorInputButtonInput) || 0, 255)
                    };

                    accountObjectSettings.push({
                        colorBorderButtonInput: clampedColorBorderButtonInput,
                        fontForButtonInput: clampedFontForButtonInput,
                        transparencyButtonInput: clampedTransparencyButtonInput,
                        colorFontColorButtonInput: clampedColorFontColorButtonInput,
                        colorOnhoverButtonInput: clampedColorOnhoverButtonInput,
                        colorButtonBorderButtonInput: clampedColorButtonBorderButtonInput,
                        colorFontColorInputButtonInput: clampedColorFontColorInputButtonInput
                    });

                    document.getElementById("color-red-border-button-input").value = clampedColorBorderButtonInput.redBorderButtonInput;
                    document.getElementById("color-green-border-button-input").value = clampedColorBorderButtonInput.greenBorderButtonInput;
                    document.getElementById("color-blue-border-button-input").value = clampedColorBorderButtonInput.blueBorderButtonInput;
                    document.getElementById("font-for-button-input").value = clampedFontForButtonInput;
                    document.getElementById("color-red-transparency-button-input").value = clampedTransparencyButtonInput;
                    document.getElementById("color-red-font-color-button-input").value = clampedColorFontColorButtonInput.redFontColorButtonInput;
                    document.getElementById("color-green-font-color-button-input").value = clampedColorFontColorButtonInput.greenFontColorButtonInput;
                    document.getElementById("color-blue-font-color-button-input").value = clampedColorFontColorButtonInput.blueFontColorButtonInput;
                    document.getElementById("color-red-onhover-button-input").value = clampedColorOnhoverButtonInput.redOnhoverButtonInput;
                    document.getElementById("color-green-onhover-button-input").value = clampedColorOnhoverButtonInput.greenOnhoverButtonInput;
                    document.getElementById("color-blue-onhover-button-input").value = clampedColorOnhoverButtonInput.blueOnhoverButtonInput;
                    document.getElementById("color-red-button-border-button-input").value = clampedColorButtonBorderButtonInput.redButtonBorderButtonInput;
                    document.getElementById("color-green-button-border-button-input").value = clampedColorButtonBorderButtonInput.greenButtonBorderButtonInput;
                    document.getElementById("color-blue-button-border-button-input").value = clampedColorButtonBorderButtonInput.blueButtonBorderButtonInput;
                    document.getElementById("color-red-font-color-input-button-input").value = clampedColorFontColorInputButtonInput.redFontColorInputButtonInput;
                    document.getElementById("color-green-font-color-input-button-input").value = clampedColorFontColorInputButtonInput.greenFontColorInputButtonInput;
                    document.getElementById("color-blue-font-color-input-button-input").value = clampedColorFontColorInputButtonInput.blueFontColorInputButtonInput;
                    updateButtonInputSettings();
                }

                return accountObjectSettings;

            } catch (error) {
                console.log("Error in loadButtonInputSettings:", error);
                return [];
            }
            }

            function updateButtonInputSettings() {
                const colorRedBorderButtonInput = document.getElementById("color-red-border-button-input").value;
                const colorGreenBorderButtonInput = document.getElementById("color-green-border-button-input").value;
                const colorBlueBorderButtonInput = document.getElementById("color-blue-border-button-input").value;
                const fontForButtonInput = document.getElementById("font-for-button-input").value;
                let transparencyButtonInput = document.getElementById("color-red-transparency-button-input").value;
                // Enforce minimum value of 0.5 for transparency
                transparencyButtonInput = Math.max(parseFloat(transparencyButtonInput), 0.5);
                const colorRedFontColorButtonInput = document.getElementById("color-red-font-color-button-input").value;
                const colorGreenFontColorButtonInput = document.getElementById("color-green-font-color-button-input").value;
                const colorBlueFontColorButtonInput = document.getElementById("color-blue-font-color-button-input").value;
                const colorRedOnhoverButtonInput = document.getElementById("color-red-onhover-button-input").value;
                const colorGreenOnhoverButtonInput = document.getElementById("color-green-onhover-button-input").value;
                const colorBlueOnhoverButtonInput = document.getElementById("color-blue-onhover-button-input").value;
                const colorRedButtonBorderButtonInput = document.getElementById("color-red-button-border-button-input").value;
                const colorGreenButtonBorderButtonInput = document.getElementById("color-green-button-border-button-input").value;
                const colorBlueButtonBorderButtonInput = document.getElementById("color-blue-button-border-button-input").value;
                const colorRedFontColorInputButtonInput = document.getElementById("color-red-font-color-input-button-input").value;
                const colorGreenFontColorInputButtonInput = document.getElementById("color-green-font-color-input-button-input").value;
                const colorBlueFontColorInputButtonInput = document.getElementById("color-blue-font-color-input-button-input").value;

                const inputFontColor = `rgb(${colorRedFontColorInputButtonInput}, ${colorGreenFontColorInputButtonInput}, ${colorBlueFontColorInputButtonInput})`;
                const colorForInputBorder = `rgb(${colorRedBorderButtonInput}, ${colorGreenBorderButtonInput}, ${colorBlueBorderButtonInput})`;
                const fontsizewithunits = `${fontForButtonInput}vh`;
                const colorForButtonFont = `rgb(${colorRedFontColorButtonInput}, ${colorGreenFontColorButtonInput}, ${colorBlueFontColorButtonInput})`;
                const colorOnhoverButton = `rgb(${colorRedOnhoverButtonInput}, ${colorGreenOnhoverButtonInput}, ${colorBlueOnhoverButtonInput})`;
                const colorForButtonBorder = `rgb(${colorRedButtonBorderButtonInput}, ${colorGreenButtonBorderButtonInput}, ${colorBlueButtonBorderButtonInput})`;

                const inputButtons = document.querySelectorAll('.toolbar-column, .yourfov');
                inputButtons.forEach(button => {
                    button.style.borderColor = colorForInputBorder;
                    button.style.opacity = transparencyButtonInput;
                    button.style.fontSize = fontsizewithunits;
                    button.style.color = inputFontColor;
                });

                const ButtonInputButtons = document.querySelectorAll('.toolbar-column-btns');
                ButtonInputButtons.forEach(button => {
                    button.style.borderColor = colorForButtonBorder;
                    button.style.opacity = transparencyButtonInput;
                    button.style.fontSize = fontsizewithunits;
                    button.style.color = colorForButtonFont;
                    button.addEventListener('mouseover', () => {
                        button.style.backgroundColor = colorOnhoverButton;
                    });
                    button.addEventListener('mouseout', () => {
                        button.style.backgroundColor = 'transparent';
                        button.style.color = colorForButtonFont;
                    });
                });


            }

            const everythingInsdieButtonInput = [
              document.getElementById("color-red-border-button-input"),
              document.getElementById("color-green-border-button-input"),
              document.getElementById("color-blue-border-button-input"),
              document.getElementById("color-red-transparency-button-input"),
              document.getElementById("color-red-font-color-button-input"),
              document.getElementById("color-green-font-color-button-input"),
              document.getElementById("color-blue-font-color-button-input"),
              document.getElementById("color-red-font-color-input-button-input"),
              document.getElementById("color-green-font-color-input-button-input"),
              document.getElementById("color-blue-font-color-input-button-input"),
              document.getElementById("color-red-onhover-button-input"),
              document.getElementById("color-green-onhover-button-input"),
              document.getElementById("color-blue-onhover-button-input"),
              document.getElementById("color-red-button-border-button-input"),
              document.getElementById("color-green-button-border-button-input"),
              document.getElementById("color-blue-button-border-button-input"),
              document.getElementById("font-for-button-input"),
            ]

            everythingInsdieButtonInput.forEach(element => {
              element.addEventListener("input", (event) => {updateButtonInputSettings();});
            });


document.getElementById("save-container-settings").addEventListener("click", async (event) => {
    event.stopPropagation();
    
    try {
        const topicId = "0.0.9798047";

        const colorRedBorderContainer = Math.min(parseInt(document.getElementById("color-red-border-container").value) || 0, 255);
        const colorGreenBorderContainer = Math.min(parseInt(document.getElementById("color-green-border-container").value) || 0, 255);
        const colorBlueBorderContainer = Math.min(parseInt(document.getElementById("color-blue-border-container").value) || 0, 255);

        const transparencyContainer = Math.min(parseInt(document.getElementById("color-red-transparency-container").value) || 0.1, 1);

        const messageData = {
            data: {
                colorBorderContainer: {
                    redBorderContainer: colorRedBorderContainer,
                    greenBorderContainer: colorGreenBorderContainer,
                    blueBorderContainer: colorBlueBorderContainer
                },
                transparencyContainer: transparencyContainer
            }
        };

        const message = JSON.stringify(messageData);

        const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
        );
        console.log("Profile settings updated successfully:", receipt);

    } catch (error) {
        console.error("Error updating settings picture:", error);
    }
});

async function loadContainerSettings() {
    const topicId = "0.0.9798064";
    const accountObjectSettings = []; // Initialize an empty array to store account Settings
    try {
        const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
        // Check if result exists and has messages
        if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            return accountObjectSettings; // Return empty array if no messages
        }

        // Filter messages to find those from the current user
        const userMessages = result.messages.filter(message => message.payer === globalAccountId);

        // Get the last message from the filtered user messages
        const lastMessage = userMessages[userMessages.length - 1];

        // Check if the last message has valid data
        if (lastMessage && lastMessage.data) {
            // Extract relevant data and clamp to max 255
            const { colorBorderContainer, colorBackgroundContainer, transparencyContainer } = lastMessage.data;

            const clampedColorBorderContainer = {
                redBorderContainer: Math.min(parseInt(colorBorderContainer.redBorderContainer) || 0, 255),
                greenBorderContainer: Math.min(parseInt(colorBorderContainer.greenBorderContainer) || 0, 255),
                blueBorderContainer: Math.min(parseInt(colorBorderContainer.blueBorderContainer) || 0, 255)
            };
            const clampedTransparencyContainer = Math.min(parseInt(transparencyContainer) || 0.1, 1);

            accountObjectSettings.push({
                colorBorderContainer: clampedColorBorderContainer,
                transparencyContainer: clampedTransparencyContainer
            });

            document.getElementById("color-red-border-container").value = clampedColorBorderContainer.redBorderContainer;
            document.getElementById("color-green-border-container").value = clampedColorBorderContainer.greenBorderContainer;
            document.getElementById("color-blue-border-container").value = clampedColorBorderContainer.blueBorderContainer;
            document.getElementById("color-red-transparency-container").value = clampedTransparencyContainer;

            updateContainerSettings();
          }

return accountObjectSettings;

} catch (error) {
console.log("Error in loadButtonInputSettings:", error);
return [];
}
}

function updateContainerSettings() {
  const colorRedBorderContainer = document.getElementById("color-red-border-container").value;
  const colorGreenBorderContainer = document.getElementById("color-green-border-container").value;
  const colorBlueBorderContainer = document.getElementById("color-blue-border-container").value;
  const transparencyContainer = document.getElementById("color-red-transparency-container").value;
  const colorForBorder = `rgb(${colorRedBorderContainer}, ${colorGreenBorderContainer}, ${colorBlueBorderContainer})`;
  const containerSettings = document.querySelectorAll('.toolbar-group');
  containerSettings.forEach(container => {
    container.style.borderColor = colorForBorder;
    container.style.opacity = transparencyContainer;
  });
}

document.getElementById("color-red-border-container").addEventListener("input", (event) => {updateContainerSettings();});
document.getElementById("color-green-border-container").addEventListener("input", (event) => {updateContainerSettings();});
document.getElementById("color-blue-border-container").addEventListener("input", (event) => {updateContainerSettings();});
document.getElementById("color-red-transparency-container").addEventListener("input", (event) => {updateContainerSettings();});

document.getElementById("save-topic-chat-settings").addEventListener("click", async (event) => {
    event.stopPropagation();

    try {
        const topicId = "0.0.9798064";
        const colorRedAccidTopicChat = Math.min(parseInt(document.getElementById("color-red-accid-topic-chat").value) || 0, 255);
        const colorGreenAccidTopicChat = Math.min(parseInt(document.getElementById("color-green-accid-topic-chat").value) || 0, 255);
        const colorBlueAccidTopicChat = Math.min(parseInt(document.getElementById("color-blue-accid-topic-chat").value) || 0, 255);

        const colorRedUsernameTopicChat = Math.min(parseInt(document.getElementById("color-red-username-topic-chat").value) || 0, 255);
        const colorGreenUsernameTopicChat = Math.min(parseInt(document.getElementById("color-green-username-topic-chat").value) || 0, 255);
        const colorBlueUsernameTopicChat = Math.min(parseInt(document.getElementById("color-blue-username-topic-chat").value) || 0, 255);

        const colorRedTextContainerTopicChat = Math.min(parseInt(document.getElementById("color-red-text-container-topic-chat").value) || 0, 255);
        const colorGreenTextContainerTopicChat = Math.min(parseInt(document.getElementById("color-green-text-container-topic-chat").value) || 0, 255);
        const colorBlueTextContainerTopicChat = Math.min(parseInt(document.getElementById("color-blue-text-container-topic-chat").value) || 0, 255);

        const colorRedTextTopicChat = Math.min(parseInt(document.getElementById("color-red-text-topic-chat").value) || 0, 255);
        const colorGreenTextTopicChat = Math.min(parseInt(document.getElementById("color-green-text-topic-chat").value) || 0, 255);
        const colorBlueTextTopicChat = Math.min(parseInt(document.getElementById("color-blue-text-topic-chat").value) || 0, 255);

        const messageData = {
            data: {
                colorAccidTopicChat: {
                    redAccidTopicChat: colorRedAccidTopicChat,
                    greenAccidTopicChat: colorGreenAccidTopicChat,
                    blueAccidTopicChat: colorBlueAccidTopicChat
                },
                colorUsernameTopicChat: {
                    redUsernameTopicChat: colorRedUsernameTopicChat,
                    greenUsernameTopicChat: colorGreenUsernameTopicChat,
                    blueUsernameTopicChat: colorBlueUsernameTopicChat
                },
                colorTextContainerTopicChat: {
                    redTextContainerTopicChat: colorRedTextContainerTopicChat,
                    greenTextContainerTopicChat: colorGreenTextContainerTopicChat,
                    blueTextContainerTopicChat: colorBlueTextContainerTopicChat
                },
                colorTextTopicChat: {
                    redTextTopicChat: colorRedTextTopicChat,
                    greenTextTopicChat: colorGreenTextTopicChat,
                    blueTextTopicChat: colorBlueTextTopicChat
                }
            }
        };

        const message = JSON.stringify(messageData);

        const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
        );
        console.log("Profile settings updated successfully:", receipt);

    } catch (error) {
        console.error("Error updating settings picture:", error);
    }
    
});


async function loadTopicChatSettings() {
    const topicId = "0.0.9798078";
    const accountObjectSettings = []; // Initialize an empty array to store account Settings
    try {
        const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
        // Check if result exists and has messages
        if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            return accountObjectSettings; // Return empty array if no messages
        }

        // Filter messages to find those from the current user
        const userMessages = result.messages.filter(message => message.payer === globalAccountId);

        // Get the last message from the filtered user messages
        const lastMessage = userMessages[userMessages.length - 1];

        // Check if the last message has valid data
        if (lastMessage && lastMessage.data) {
            // Extract relevant data and clamp to max 255
            const { colorAccidTopicChat, colorUsernameTopicChat, colorTextContainerTopicChat, colorTextTopicChat } = lastMessage.data;

            const clampedColorAccidTopicChat = {
                redAccidTopicChat: Math.min(parseInt(colorAccidTopicChat.redAccidTopicChat) || 0, 255),
                greenAccidTopicChat: Math.min(parseInt(colorAccidTopicChat.greenAccidTopicChat) || 0, 255),
                blueAccidTopicChat: Math.min(parseInt(colorAccidTopicChat.blueAccidTopicChat) || 0, 255)
            };
            const clampedColorUsernameTopicChat = {
                redUsernameTopicChat: Math.min(parseInt(colorUsernameTopicChat.redUsernameTopicChat) || 0, 255),
                greenUsernameTopicChat: Math.min(parseInt(colorUsernameTopicChat.greenUsernameTopicChat) || 0, 255),
                blueUsernameTopicChat: Math.min(parseInt(colorUsernameTopicChat.blueUsernameTopicChat) || 0, 255)
            };

            const clampedColorTextContainerTopicChat = {
                redTextContainerTopicChat: Math.min(parseInt(colorTextContainerTopicChat.redTextContainerTopicChat) || 0, 255),
                greenTextContainerTopicChat: Math.min(parseInt(colorTextContainerTopicChat.greenTextContainerTopicChat) || 0, 255),
                blueTextContainerTopicChat: Math.min(parseInt(colorTextContainerTopicChat.blueTextContainerTopicChat) || 0, 255)
            };
            const clampedColorTextTopicChat = {
                redTextTopicChat: Math.min(parseInt(colorTextTopicChat.redTextTopicChat) || 0, 255),
                greenTextTopicChat: Math.min(parseInt(colorTextTopicChat.greenTextTopicChat) || 0, 255),
                blueTextTopicChat: Math.min(parseInt(colorTextTopicChat.blueTextTopicChat) || 0, 255)
            };

            accountObjectSettings.push({
                colorAccidTopicChat: clampedColorAccidTopicChat,
                colorUsernameTopicChat: clampedColorUsernameTopicChat,
                colorTextContainerTopicChat: clampedColorTextContainerTopicChat,
                colorTextTopicChat: clampedColorTextTopicChat
            });

            document.getElementById("color-red-accid-topic-chat").value = clampedColorAccidTopicChat.redAccidTopicChat;
            document.getElementById("color-green-accid-topic-chat").value = clampedColorAccidTopicChat.greenAccidTopicChat;
            document.getElementById("color-blue-accid-topic-chat").value = clampedColorAccidTopicChat.blueAccidTopicChat;
            document.getElementById("color-red-username-topic-chat").value = clampedColorUsernameTopicChat.redUsernameTopicChat;
            document.getElementById("color-green-username-topic-chat").value = clampedColorUsernameTopicChat.greenUsernameTopicChat;
            document.getElementById("color-blue-username-topic-chat").value = clampedColorUsernameTopicChat.blueUsernameTopicChat;
            document.getElementById("color-red-text-container-topic-chat").value = clampedColorTextContainerTopicChat.redTextContainerTopicChat;
            document.getElementById("color-green-text-container-topic-chat").value = clampedColorTextContainerTopicChat.greenTextContainerTopicChat;
            document.getElementById("color-blue-text-container-topic-chat").value = clampedColorTextContainerTopicChat.blueTextContainerTopicChat;
            document.getElementById("color-red-text-topic-chat").value = clampedColorTextTopicChat.redTextTopicChat;
            document.getElementById("color-green-text-topic-chat").value = clampedColorTextTopicChat.greenTextTopicChat;
            document.getElementById("color-blue-text-topic-chat").value = clampedColorTextTopicChat.blueTextTopicChat;

            updateTopicChatSettings();
        }

        return accountObjectSettings;

    } catch (error) {
        console.log("Error in loadTopicChatSettings:", error);
        return [];
    }
    }

    function updateTopicChatSettings() {
    const colorRedAccidTopicChat = document.getElementById("color-red-accid-topic-chat").value;
    const colorGreenAccidTopicChat = document.getElementById("color-green-accid-topic-chat").value;
    const colorBlueAccidTopicChat = document.getElementById("color-blue-accid-topic-chat").value;
    const colorRedUsernameTopicChat = document.getElementById("color-red-username-topic-chat").value;
    const colorGreenUsernameTopicChat = document.getElementById("color-green-username-topic-chat").value;
    const colorBlueUsernameTopicChat = document.getElementById("color-blue-username-topic-chat").value;
    const colorRedTextContainerTopicChat = document.getElementById("color-red-text-container-topic-chat").value;
    const colorGreenTextContainerTopicChat = document.getElementById("color-green-text-container-topic-chat").value;
    const colorBlueTextContainerTopicChat = document.getElementById("color-blue-text-container-topic-chat").value;
    const colorRedTextTopicChat = document.getElementById("color-red-text-topic-chat").value;
    const colorGreenTextTopicChat = document.getElementById("color-green-text-topic-chat").value;
    const colorBlueTextTopicChat = document.getElementById("color-blue-text-topic-chat").value;

    // Update global variables
    colorForAccidTopicChat = `rgb(${colorRedAccidTopicChat}, ${colorGreenAccidTopicChat}, ${colorBlueAccidTopicChat})`;
    colorForUsernameTopicChat = `rgb(${colorRedUsernameTopicChat}, ${colorGreenUsernameTopicChat}, ${colorBlueUsernameTopicChat})`;
    colorForTextTopicChat = `rgb(${colorRedTextTopicChat}, ${colorGreenTextTopicChat}, ${colorBlueTextTopicChat})`;

    const colorForTextContainerTopicChat = `rgb(${colorRedTextContainerTopicChat}, ${colorGreenTextContainerTopicChat}, ${colorBlueTextContainerTopicChat})`;

    const topicChatSettings = document.querySelectorAll('.chat-container');
    topicChatSettings.forEach(topicChat => {
        topicChat.style.borderColor = colorForTextContainerTopicChat;
    });

    return { colorForAccidTopicChat, colorForUsernameTopicChat, colorForTextTopicChat };
}

    document.getElementById("color-red-accid-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});
    document.getElementById("color-green-accid-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});
    document.getElementById("color-blue-accid-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});
    document.getElementById("color-red-username-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});
    document.getElementById("color-green-username-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});
    document.getElementById("color-blue-username-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});
    document.getElementById("color-red-text-container-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});
    document.getElementById("color-green-text-container-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});
    document.getElementById("color-blue-text-container-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});
    document.getElementById("color-red-text-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});
    document.getElementById("color-green-text-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});
    document.getElementById("color-blue-text-topic-chat").addEventListener("input", (event) => {updateTopicChatSettings();});





async function loadUfoModel(modelUrl) {

    // Check if the model URL is defined and valid
    if (!modelUrl || typeof modelUrl !== 'string' || modelUrl.trim() === '') {
        modelUrl = defaultModelUrl; // Use the default model URL
        console.log('Using default model URL:', modelUrl);

    }

    // Load the GLTF model
    try {
        // Remove the previous model if it exists
        if (currentUfoModel) {
            scene.remove(currentUfoModel);
            currentUfoModel = null; // Clear the reference to the removed model
        }

        const gltf = await new Promise((resolve, reject) => {
            ufoLoader.load(modelUrl, resolve, undefined, (error) => {
                console.error("Error loading GLTF model:", error);
                reject(error);
            });
        });

        currentUfoModel = gltf.scene; // Get the loaded model

        // Step 1: Calculate the model's bounding box
        const box = new THREE.Box3().setFromObject(currentUfoModel);
        const modelSize = new THREE.Vector3();
        box.getSize(modelSize); // Get the size of the model

        // Step 2: Define the bounding box dimensions
        const boundingBoxSize = new THREE.Vector3(10, 10, 10); // Width, Height, Depth

        // Step 3: Calculate the scale factor
        const scaleFactor = Math.min(
            boundingBoxSize.x / modelSize.x,
            boundingBoxSize.y / modelSize.y,
            boundingBoxSize.z / modelSize.z
        );

        // Step 4: Apply the scale to the model
        currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Scale the model uniformly

        const isNewUser = modelUrl === defaultModelUrl; // Set to true if no URLs are found

        // Check if the user has loaded their profile object
        if (modelUrl !== defaultModelUrl) {
            // Load user-specific settings if available
            const profileSettings = await loadProfileSettings(); // Load profile settings
            if (profileSettings.length === 0 || !profileSettings[0].position) {
                // If no settings loaded, use bounding box for position
                currentUfoModel.position.set(box.min.x, box.min.y, box.min.z); // Use bounding box min for position
                currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Use calculated scale factor
                // Step 5: Position the model within the bounding box
                currentUfoModel.position.set(0, -5, -30); // Adjust as needed
            } else {
                // Apply user-specific settings
                currentUfoModel.position.set(
                    parseFloat(document.getElementById("position-x").value),
                    parseFloat(document.getElementById("position-y").value),
                    parseFloat(document.getElementById("position-z").value)
                );
                currentUfoModel.rotation.set(
                    THREE.MathUtils.degToRad(document.getElementById("rotation-x").value),
                    THREE.MathUtils.degToRad(document.getElementById("rotation-y").value),
                    THREE.MathUtils.degToRad(document.getElementById("rotation-z").value)
                );
                const userScaleFactor = parseFloat(document.getElementById("scale-factor").value);
                currentUfoModel.scale.set(userScaleFactor, userScaleFactor, userScaleFactor); // Scale the model uniformly
            }
        } else {
            // Default settings for new users
            currentUfoModel.position.set(0, -3, -8); // Default position
            currentUfoModel.rotation.set(
                THREE.MathUtils.degToRad(0),
                THREE.MathUtils.degToRad(0),
                THREE.MathUtils.degToRad(0)
            ); // Default rotation
            const defaultScaleFactor = 1; // Default scale factor
            currentUfoModel.scale.set(defaultScaleFactor, defaultScaleFactor, defaultScaleFactor); // Scale the model uniformly
        }

        // Add the model to the scene
        scene.add(currentUfoModel);

        // Existing event listeners for rotation and position sliders
        document.getElementById("rotation-x").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-x-value").value = value; // Update number input
            currentUfoModel.rotation.x = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        document.getElementById("rotation-y").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-y-value").value = value; // Update number input
            currentUfoModel.rotation.y = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        document.getElementById("rotation-z").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-z-value").value = value; // Update number input
            currentUfoModel.rotation.z = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        // Add event listeners for position sliders
        document.getElementById("position-x").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-x-value").value = value; // Update number input
            currentUfoModel.position.x = parseFloat(value); // Update the x position of the model
        });

        document.getElementById("position-y").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-y-value").value = value; // Update number input
            currentUfoModel.position.y = parseFloat(value); // Update the y position of the model
        });

        // Add Z position slider
        document.getElementById("position-z").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-z-value").value = value; // Update number input
            currentUfoModel.position.z = parseFloat(value); // Update the z position of the model
        });

        // Add scale factor slider
        document.getElementById("scale-factor").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("scale-factor-value").value = value; // Update number input
            const scaleFactor = parseFloat(value); // Get the scale factor
            currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Scale the model uniformly
        });

        // Add event listeners for number inputs to update sliders
        document.getElementById("rotation-x-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-x").value = value; // Update range input
            currentUfoModel.rotation.x = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        document.getElementById("rotation-y-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-y").value = value; // Update range input
            currentUfoModel.rotation.y = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        document.getElementById("rotation-z-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-z").value = value; // Update range input
            currentUfoModel.rotation.z = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        document.getElementById("position-x-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-x").value = value; // Update range input
            currentUfoModel.position.x = parseFloat(value); // Update the x position of the model
        });

        document.getElementById("position-y-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-y").value = value; // Update range input
            currentUfoModel.position.y = parseFloat(value); // Update the y position of the model
        });

        document.getElementById("position-z-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-z").value = value; // Update range input
            currentUfoModel.position.z = parseFloat(value); // Update the z position of the model
        });

        document.getElementById("scale-factor-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("scale-factor").value = value; // Update range input
            const scaleFactor = parseFloat(value); // Get the scale factor
            currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Scale the model uniformly
        });

        // Load current values into input fields after model is loaded
        document.getElementById("position-x").value = currentUfoModel.position.x;
        document.getElementById("position-y").value = currentUfoModel.position.y;
        document.getElementById("position-z").value = currentUfoModel.position.z;
        document.getElementById("scale-factor").value = currentUfoModel.scale.x; // Assuming uniform scaling
        document.getElementById("position-x-value").value = currentUfoModel.position.x;
        document.getElementById("position-y-value").value = currentUfoModel.position.y;
        document.getElementById("position-z-value").value = currentUfoModel.position.z;

        // Convert radians to degrees for display
        const rotationXInDegrees = THREE.MathUtils.radToDeg(currentUfoModel.rotation.x);
        const rotationYInDegrees = THREE.MathUtils.radToDeg(currentUfoModel.rotation.y);
        const rotationZInDegrees = THREE.MathUtils.radToDeg(currentUfoModel.rotation.z);

        document.getElementById("rotation-x").value = Math.round(rotationXInDegrees); // Round to nearest integer
        document.getElementById("rotation-y").value = Math.round(rotationYInDegrees); // Round to nearest integer
        document.getElementById("rotation-z").value = Math.round(rotationZInDegrees); // Round to nearest integer

        document.getElementById("rotation-x-value").value = Math.round(rotationXInDegrees);
        document.getElementById("rotation-y-value").value = Math.round(rotationYInDegrees);
        document.getElementById("rotation-z-value").value = Math.round(rotationZInDegrees);
        document.getElementById("scale-factor-value").value = currentUfoModel.scale.x;

    } catch (error) {
        console.error('An error occurred while loading the GLTF model:', error);
    }
}
loader.updateProgress();
const toolbarColumns = document.querySelectorAll('.toolbar-column');

toolbarColumns.forEach(column => {
  column.addEventListener('touchstart', () => {
    column.classList.add('active'); // Add active class on touch
  });

  column.addEventListener('touchend', () => {
    column.classList.remove('active'); // Remove active class on touch end
  });
});

document.getElementById("load-topic-rules-for-marker").addEventListener("click", async () => {
    try {
      let userInput = document.getElementById("input-field-2-0").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
      const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);
      const topicInfo = await sdk.getTopicInfo(topicId);
      const topicAdmin = [];
      let hasRules = false;
      const memo = topicInfo.memo;

      // Split the memo by commas
      const parts = memo.split(',');

      // Iterate over each part
      parts.forEach(part => {
        // Check if the part starts with "0.0."
        if (part.startsWith("0.0.")) {
          // Add it to the topicAdmin array
          topicAdmin.push(part);
          hasRules = true;
        }
      });

      const messages = response.messages; // Extract messages

      const loadedTopicRulesForMarker = [];

      // Read rules from messages
      for (let index = messages.length - 1; index >= 0; index--) {
        const message = messages[index];
        try {
          let parsedMessage = message;
          if (typeof message === 'string') {
            parsedMessage = JSON.parse(message);
          }
          if (parsedMessage.rules && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
            loadedTopicRulesForMarker.push(parsedMessage.rules.formarker);
            hasRules = true;
            break; // Exit the loop after finding the last message with rules
          }
        } catch (messageError) {
          console.error(`Error processing message ${index}:`, messageError);
        }
      }

        if (hasRules===false) {
        const markerRulesMessage = `No rules for this topic.`;
        document.getElementById("loaded-topic-rules-for-marker").textContent = markerRulesMessage;
        adjustTextareaHeight(document.getElementById("loaded-topic-rules-for-marker"));
        return;
      }



const markerRulesMessage = `You have to own ${loadedTopicRulesForMarker[0].markerTopicId} to show ${loadedTopicRulesForMarker[0].markerMessagesPerNft} messages per NFT.`;
document.getElementById("loaded-topic-rules-for-marker").textContent = markerRulesMessage;
adjustTextareaHeight(document.getElementById("loaded-topic-rules-for-marker"));



    } catch (error) {
      console.error("Error creating topic:", error);
    }
});




document.getElementById("load-topic-rules-for-polygon").addEventListener("click", async () => {
    try {
      let userInput = document.getElementById("input-field-3-0").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
      const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);
      const topicInfo = await sdk.getTopicInfo(topicId);
      const topicAdmin = [];
      let hasRules = false;
      const memo = topicInfo.memo;

      // Split the memo by commas
      const parts = memo.split(',');

      // Iterate over each part
      parts.forEach(part => {
        // Check if the part starts with "0.0."
        if (part.startsWith("0.0.")) {
          // Add it to the topicAdmin array
          topicAdmin.push(part);
          hasRules = true;
        }
      });
      const messages = response.messages; // Extract messages

      const loadedTopicRulesForPolygon = [];

      // Read rules from messages
      for (let index = messages.length - 1; index >= 0; index--) {
        const message = messages[index];
        try {
          let parsedMessage = message;
          if (typeof message === 'string') {
            parsedMessage = JSON.parse(message);
          }
          if (parsedMessage.rules && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
            loadedTopicRulesForPolygon.push(parsedMessage.rules.forpolygon);
            hasRules = true;
            break; // Exit the loop after finding the last message with rules
          }
        } catch (messageError) {
          console.error(`Error processing message ${index}:`, messageError);
        }
      }

        if (hasRules===false) {
        const polygonRulesMessage = `No rules for this topic.`;
        document.getElementById("loaded-topic-rules-for-polygon").textContent = polygonRulesMessage;
        adjustTextareaHeight(document.getElementById("loaded-topic-rules-for-polygon"));
        return;
      }



const polygonRulesMessage = `You have to own NFT ${loadedTopicRulesForPolygon[0].polygonTopicId} to show ${loadedTopicRulesForPolygon[0].polygonMessagesPerNft} messages per NFT.`;

const polygonSize = loadedTopicRulesForPolygon[0].polygonSize;
const maxLongitudeSize = 360 / polygonSize;
const maxLatitudeSize = 180 / polygonSize;

const polygonRulesMessages = `Maximum distance between points is ${maxLongitudeSize} for longitude and ${maxLatitudeSize} for latitude. If not = wont load.`;

document.getElementById("loaded-topic-rules-for-polygon").textContent = `${polygonRulesMessage}\n${polygonRulesMessages}`;
adjustTextareaHeight(document.getElementById("loaded-topic-rules-for-polygon"));



    } catch (error) {
      console.error("Error creating topic:", error);
    }
});




function isValidUrl(url) {
    try {
        new URL(url);
        return true;
    } catch {
        return false;
    }
}




async function processTopicMessages(topicId) {
        const topicGeojsonFeatures = []; // Store geojson features for this topic
        const topicPolygons = []; // Store polygons for this topic
        let loadedTopicName = ''; // Initialize loadedTopicName
        const profilePics = await loadProfilePicture();
        const usernames = await loadUsername();
        const click2url = await loadCLICK2URL();

        try {
          const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          let hasRulesForMarker = false;
          let hasRulesForPolygon = false;
          const memo = topicInfo.memo;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
            }
          });



          // Check if messages exist and is an array
          if (!response.messages || !Array.isArray(response.messages)) {
            console.error(`No messages found for topic ${topicId}.`, response);
            return { topicGeojsonFeatures, topicPolygons }; // Return empty arrays
          }

          const messages = response.messages; // Extract messages

          const loadedTopicRulesForMarker = [];
          const loadedTopicRulesForPolygon = [];



          // Read rules from messages
          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }

              if (parsedMessage.rules && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                if (parsedMessage.rules.formarker.markerTopicId.startsWith('0.0.') && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                loadedTopicRulesForMarker.push(parsedMessage.rules.formarker);
                hasRulesForMarker = true;

              }
              if (parsedMessage.rules.forpolygon.polygonTopicId.startsWith('0.0.') && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                loadedTopicRulesForPolygon.push(parsedMessage.rules.forpolygon);
                hasRulesForPolygon = true;

              }
                break; // Exit the loop after finding the last message with rules
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
              // Check if changeName exists and either topicAdmin is empty or includes the payer
              if (parsedMessage.changeName && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                loadedTopicName = parsedMessage.changeName;
                break; // Stop after finding the first valid message
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }
          const uniquePayerIdsForMarker = new Set();
          const uniquePayerIdsForPolygon = new Set();

          // Extract payer IDs from messages
      for (const message of messages) {
        try {
          let parsedMessage = message;
          if (typeof message === 'string') {
            parsedMessage = JSON.parse(message);
          }

          // Add payer IDs for markers
          if (parsedMessage.marker && parsedMessage.marker.data) {
            uniquePayerIdsForMarker.add(parsedMessage.payer);
          }

          // Add payer IDs for polygons
          if (parsedMessage.polygon && parsedMessage.polygon.data) {
            uniquePayerIdsForPolygon.add(parsedMessage.payer);
          }

          if (parsedMessage.addTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
          const nfts = parsedMessage.addTopicNFT.split(',').map(nft => nft.trim());
          nfts.forEach(nft => {
            if (!loadedNFTsForModel.includes(nft)) {
              loadedNFTsForModel.push(nft);
            }
          });
          }

          if (parsedMessage.removeTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
            const nft = parsedMessage.removeTopicNFT.trim();
            const index = loadedNFTsForModel.indexOf(nft);
            if (index !== -1) {
              loadedNFTsForModel.splice(index, 1);
            }
          }

        if (parsedMessage.addScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
          const { NFT, scale } = parsedMessage.addScale;
          loadedNFTScaleForModel.push({ NFT, scale });
        }

        if (parsedMessage.removeScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
          const { NFT } = parsedMessage.removeScale;
          const index = loadedNFTScaleForModel.findIndex(item => item.NFT === NFT);
          if (index !== -1) {
            loadedNFTScaleForModel.splice(index, 1); // Remove the item if it exists
          } else {
            console.log(`NFT: ${NFT} not found in addScale list`);
          }
        }

        updateRulesForModelNFTState();

        } catch (error) {
          console.error("Error extracting payer ID:", error);
        }
      }

          // Ownership logic
          const markerOwnershipArray = [];
          const polygonOwnershipArray = [];


          if (hasRulesForMarker) {
            // Iterate over each unique payer ID for markers
            for (const payerId of uniquePayerIdsForMarker) {
              const tokenIdForMarker = loadedTopicRulesForMarker[0].markerTopicId;
              const filteredNftsForMarker = await sdk.getAccountNFTs(payerId, tokenIdForMarker);

              // Check if the user owns NFTs and push to an array
              if (filteredNftsForMarker.length > 0) {
                const numberOfMessages = filteredNftsForMarker.length * loadedTopicRulesForMarker[0].markerMessagesPerNft;
                const numberOfMarker = [];
                markerOwnershipArray.push({ payerId, numberOfMessages, numberOfMarker });
              }
            }
          }

          if (hasRulesForPolygon) {

            // Iterate over each unique payer ID for polygons
            for (const payerId of uniquePayerIdsForPolygon) {
              const tokenIdForPoly = loadedTopicRulesForPolygon[0].polygonTopicId;
              const filteredNftsForPoly = await sdk.getAccountNFTs(payerId, tokenIdForPoly);

              // Check if the user owns NFTs and push to an array
              if (filteredNftsForPoly.length > 0) {
                const numberOfMessages = filteredNftsForPoly.length * loadedTopicRulesForPolygon[0].polygonMessagesPerNft;
                const numberOfPolygon = [];
                polygonOwnershipArray.push({ payerId, numberOfMessages, numberOfPolygon });
              }
            }
          }

          if (!hasRulesForMarker) {
          for (const payerId of uniquePayerIdsForMarker) {
            const numberOfMarker = [];
            markerOwnershipArray.push({ payerId, numberOfMarker });
          }
        }
        if (!hasRulesForPolygon) {
          for (const payerId of uniquePayerIdsForPolygon) {
            const numberOfPolygon = [];
            polygonOwnershipArray.push({ payerId, numberOfPolygon });
          }
        }
          // Process each message
          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }

              const defaultProfilePic = "https://kiloscribe.com/api/inscription-cdn/0.0.4819119";
              const profileUrl = isValidUrl(message.payer && profilePics[message.payer] ?
                profilePics[message.payer].url :
                defaultProfilePic) ?
                (message.payer && profilePics[message.payer] ? profilePics[message.payer].url : defaultProfilePic) :
                defaultProfilePic;

              const payerInfo = message.payer ? `${message.payer}` : 'Anonymous';
              const username = message.payer && usernames[message.payer] ?
                ` ${usernames[message.payer].username}` :
                '';
                const click2link= message.payer && click2url[message.payer] ?
                ` ${click2url[message.payer].click2url}` :
                '';

              const displayHeader = `
              <h2>
                <a href="https://explore.hashpack.app/${payerInfo}" target="_blank" class="payer-info" style="color: #800080; text-decoration: none;">${payerInfo}</a>
                <br>
                ${click2link ? `<a href="${click2link}" target="_blank" class="username" style="color: #FFFFFF; text-decoration: none;">${username}</a>` : `${username}`}
              </h2>`;

              if (parsedMessage.marker && parsedMessage.marker.data) {
                const markernumber = parsedMessage.marker.data.numberOfMarker;
                const markerOwner = markerOwnershipArray.find(owner => owner.payerId === message.payer);
                
                if (parsedMessage.marker.data.deleteMarkerNumber) {
                  const deleteMarkerNumber = parsedMessage.marker.data.deleteMarkerNumber;
                  markerOwner.numberOfMarker.push(deleteMarkerNumber);
                }

                if (markernumber === undefined || markernumber === null || !Number.isInteger(Number(markernumber))) {
                  continue;
                }
                  
                if (!markerOwner.numberOfMarker.includes(markernumber)) {
                  markerOwner.numberOfMarker.push(markernumber);
                
                if (!hasRulesForMarker || (markerOwner && markerOwner.numberOfMessages > 0)) {

                  if (hasRulesForMarker) {
                    markerOwner.numberOfMessages -= 1;
                  }

                  let coords;
                  try {
                    const cordData = parsedMessage.marker.data.cord;

                    if (typeof cordData === 'string') {
                      coords = cordData.split(',').map(num => parseFloat(num.trim()));
                    } else if (Array.isArray(cordData)) {
                      coords = cordData;
                    } else {
                      throw new Error('Unsupported coordinate format');
                    }

                    if (!Array.isArray(coords) || coords.length !== 2 || coords.some(isNaN)) {
                      throw new Error('Invalid coordinate format');
                    }

                    topicGeojsonFeatures.push({
                      type: "Feature",
                      payer: message.payer,
                      properties: {
                        message:
    `
      <div style="position: absolute; top: -0.1em; left: 0.1em; font-weight: bold;" class="number">${markernumber}</div>
      <div style="display: flex; align-items: center;">
      <img src="${profileUrl}" alt="Profile photo"
      style="width: 7vh; height: 7vh; margin-right: 1em; border-radius: 50%; cursor: pointer;"
      onclick="loadTOPIC4PIC('${message.payer}');">
        <div>${displayHeader}</div>
      </div>
      <div style="text-align: center;">
        <div style='margin-bottom: 1vh;'>
            <strong class="title_color">${parsedMessage.marker.data.title}</strong>
        </div>
        <div>
          ${isValidUrl(parsedMessage.marker.data.image) ? `<img src="${parsedMessage.marker.data.image}" style="width: 20vh; height: 20vh; display: block; margin: 0 auto;" />` : ''} 
        </div>
        <div>
          <p class="text_color">${parsedMessage.marker.data.msg}</p>
        </div>
      </div>
    `,
    imageUrl: isValidUrl(parsedMessage.marker.data.coverimage) ? parsedMessage.marker.data.coverimage : profileUrl
  },
                      geometry: {
                        type: "Point",
                        coordinates: coords
                      }
                    });
                  } catch (coordError) {
                    console.error("Error parsing marker coordinates:", coordError, "Raw coords:", parsedMessage.marker.data.cord);
                  }
                }
              }
            }

              // Handle polygon type messages
              if (parsedMessage.polygon && parsedMessage.polygon.data) {
                const polygonOwner = polygonOwnershipArray.find(owner => owner.payerId === message.payer) ;
                const polygonnumber = parsedMessage.polygon.data.numberOfPolygon;
                
                if (parsedMessage.polygon.data.deletePolygonNumber) {
                  const deletePolygonNumber = parsedMessage.polygon.data.deletePolygonNumber;
                  polygonOwner.numberOfPolygon.push(deletePolygonNumber);
                }

                if (polygonnumber === undefined || polygonnumber === null || !Number.isInteger(Number(polygonnumber))) {
                  continue;
                }

                if (!polygonOwner.numberOfPolygon.includes(polygonnumber)) {
                  polygonOwner.numberOfPolygon.push(polygonnumber);


                if (!hasRulesForPolygon || (polygonOwner && polygonOwner.numberOfMessages > 0)) {
                  if (hasRulesForPolygon) {
                    polygonOwner.numberOfMessages -= 1;
                  }

                  try {
                    const cordStr = parsedMessage.polygon.data.cord;

                    // Validate the coordinate string format
                    const validCoordPattern = /^\[-?\d+\.?\d*,\s*-?\d+\.?\d*\](,\s*\[-?\d+\.?\d*,\s*-?\d+\.?\d*\])*$/;
                    if (!validCoordPattern.test(cordStr)) {
                      continue; // Skip processing this message
                    }

                    // Parse the coordinates
                    const coordinates = JSON.parse(`[${cordStr}]`); // Wrap in brackets for valid JSON

                    if (Array.isArray(coordinates) && coordinates.length > 2) {
                      const polygonSize = hasRulesForPolygon ? loadedTopicRulesForPolygon[0].polygonSize : 1;




                        topicPolygons.push({
                          id: `
                          polygon-${index}`,
                          payer: message.payer,
                          coordinates: [coordinates],
                          description: `
          <div style="position: absolute; top: -0.1em; left: 0.1em; font-weight: bold;" class="number">${parsedMessage.polygon.data.numberOfPolygon}</div>
          <div style="display: flex; align-items: center;">
<img src="${profileUrl}" alt="Profile photo"
      style="width: 7vh; height: 7vh; margin-right: 1em; border-radius: 50%; cursor: pointer;"
      onclick="loadTOPIC4PIC('${message.payer}');">
            <div>${displayHeader}</div>
          </div>
          <div style="text-align: center;">
            <div style='margin-bottom: 1vh;'>
                <strong class="title_color">${parsedMessage.polygon.data.title}</strong>
            </div>
            <div>
              ${isValidUrl(parsedMessage.polygon.data.image) ? `<img src="${parsedMessage.polygon.data.image}" 
              style="width: 20vh; height: 20vh; display: block; margin: 0 auto;" />` : ''}
            </div>
            <div>
              <p class="text_color">${parsedMessage.polygon.data.msg}</p>
            </div>
          </div>
                          `,
                          imageUrl: isValidUrl(parsedMessage.polygon.data.coverimage) ? parsedMessage.polygon.data.coverimage : profileUrl
                        });


                    }
                  } catch (polygonError) {
                    console.error("Error parsing polygon data:", polygonError);
                  }
                }
              }
            }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }


        // At the end of the function, push the collected features to the parent arrays
        geojson.features.push(...topicGeojsonFeatures); // Push topic features to parent geojson array
        polygons.push(...topicPolygons); // Push topic polygons to parent polygons array
        return { topicGeojsonFeatures, topicPolygons, loadedTopicName };


        } catch (error) {
          console.error(`Error loading messages for topic ${topicId}:`, error);
          return { topicGeojsonFeatures: [], topicPolygons: [] }; // Return empty arrays on error
        }
      }


    // Array of models with their respective URLs, origins, and altitudes
    const models = [];

async function load3dModels() {
const customLayer = {
  id: "3d-model",
  type: "custom",
  renderingMode: "3d",
  onAdd(map, gl) {
    this.camera = new THREE.Camera();
    this.scene = new THREE.Scene();

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    this.scene.add(ambientLight);

    const directions = [
      [1, 1, 1],
      [-1, 1, 1],
      [1, -1, 1],
      [-1, -1, 1],
      [1, 1, -1],
      [-1, 1, -1],
      [1, -1, -1],
      [-1, -1, -1],
    ];

    directions.forEach((dir) => {
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(...dir).normalize();
      this.scene.add(directionalLight);
    });

    this.map = map;

    this.renderer = new THREE.WebGLRenderer({
      canvas: map.getCanvas(),
      context: gl,
      antialias: true,
    });

    this.renderer.autoClear = false;


    const loader = new THREE.GLTFLoader();
    loader.setDRACOLoader(dracoLoader);


    models.forEach(({ url, origin, altitude, scaleFactorNFT }) => {
      loader.load(url, (gltf) => {
        const model = gltf.scene;
        this.scene.add(model);

        // Calculate the model's bounding box
        const box = new THREE.Box3().setFromObject(model);
        const modelSize = new THREE.Vector3();
        box.getSize(modelSize);

        // Define the desired bounding box dimensions
        const boundingBoxSize = new THREE.Vector3(10000, 10000, 10000); // Width, Height, Depth

        // Calculate the scale factor to fit the model within the bounding box
        const scaleFactor = Math.min(
          boundingBoxSize.x / modelSize.x,
          boundingBoxSize.y / modelSize.y,
          boundingBoxSize.z / modelSize.z
        );

        // Apply the scale to the model
        model.scale.set(scaleFactor*scaleFactorNFT, scaleFactor*scaleFactorNFT, scaleFactor*scaleFactorNFT);

          // Calculate the transformation matrix for each model's location and altitude
          const modelMatrix = this.map.transform.getMatrixForModel(origin, altitude);

          // Apply the transformation matrix to the model
          const modelTransformMatrix = new THREE.Matrix4()
            .fromArray(modelMatrix)
            .scale(new THREE.Vector3(10, 10, 10)); // Example scaling

          // Adjust the model's position to the bottom of the bounding box
          const modelHeight = modelSize.y * scaleFactor;
          const boundingBoxHeight = boundingBoxSize.y;
          const yOffset = (boundingBoxHeight - modelHeight) / 2;
          model.position.set(0, -yOffset, 0);

          model.applyMatrix4(modelTransformMatrix);
      });
    });
  },
  render(gl, args) {
    const mapProjectionMatrix = new THREE.Matrix4().fromArray(
      args.defaultProjectionData.mainMatrix
    );

    this.camera.projectionMatrix = mapProjectionMatrix;

    this.renderer.resetState();
    this.renderer.render(this.scene, this.camera);
    this.map.triggerRepaint();
  },
}
return customLayer;
};

map.on("style.load", async () => {
  map.setProjection({
    type: "globe",
  });

  const layers = map.getStyle().layers;
  const roadShieldLayer = layers.find(
    (layer) =>
      layer.id.toLowerCase().includes("road_shield") ||
      layer.id.toLowerCase().includes("shield")
  );

  if (roadShieldLayer) {
    map.setLayoutProperty(roadShieldLayer.id, "visibility", "none");
  }

  // Add the custom 3D model layer here
  map.addLayer(await load3dModels());
});

async function updateMapLayer() {
    // Remove the existing layer if it exists
    if (map.getLayer('3d-model')) {
        map.removeLayer('3d-model');
    }

    // Add the updated custom 3D model layer
    map.addLayer(await load3dModels());
}

let updateMapLayerIntervalId = null; // Initialize the interval ID

let updateInterval = 5000; // Default interval time in milliseconds

document.getElementById("update-loop").addEventListener("click", () => {
  const newInterval = parseInt(document.getElementById("time-input").value, 10);
  const updatesValue = document.getElementById("updates-value");
  const visibilityValue = document.getElementById("3d-model-visibility-value");
  const toggle3DModelButton = document.getElementById("toggle-3d-model-visibility");

  if (!isNaN(newInterval) && newInterval > 0) {
    updateInterval = newInterval;
    stopUpdateMapLayerLoop(); // Stop the current loop
    startUpdateMapLayerLoop(); // Start a new loop with the updated interval
    console.log(`Update interval set to ${updateInterval} milliseconds.`);
    updatesValue.textContent = "On"; // Ensure updates are "On"

    // Ensure 3D models are visible
    if (visibilityValue.textContent === "Off") {
      toggle3DModelButton.click(); // Simulate a click to turn on 3D models
    }
  } else {
    console.error("Invalid interval value. Please enter a positive number.");
  }
});

document.getElementById("toggle-updates").addEventListener("click", () => {
  const updatesValue = document.getElementById("updates-value");
  const visibilityValue = document.getElementById("3d-model-visibility-value");
  const toggle3DModelButton = document.getElementById("toggle-3d-model-visibility");

  if (updatesValue.textContent === "On") {
    stopUpdateMapLayerLoop(); // Stop the update loop
    updatesValue.textContent = "Off";
  } else {
    startUpdateMapLayerLoop(); // Start the update loop
    updatesValue.textContent = "On";

    // Ensure 3D models are visible
    if (visibilityValue.textContent === "Off") {
      toggle3DModelButton.click(); // Simulate a click to turn on 3D models
    }
  }
});

function startUpdateMapLayerLoop() {
  if (updateMapLayerIntervalId === null) { // Only start if not already running
    updateMapLayerIntervalId = setInterval(() => {
      updateMapLayer();
    }, updateInterval); // Use the updated interval time
  }
}

function stopUpdateMapLayerLoop() {
  if (updateMapLayerIntervalId !== null) {
    clearInterval(updateMapLayerIntervalId);
    updateMapLayerIntervalId = null; // Reset the interval ID
  }
}
// Call this function to start the loop
startUpdateMapLayerLoop();

document.getElementById("update-map-layer-btn").addEventListener("click", async function() {
  await updateMapLayer();
});

document.getElementById("toggle-3d-model-visibility").addEventListener("click", async function() {
    const button = this;
    const visibilityValue = document.getElementById("3d-model-visibility-value");
    const updatesValue = document.getElementById("updates-value");

    if (visibilityValue.textContent === "Off") {
        await updateMapLayer(); // Show 3D models
        startUpdateMapLayerLoop(); // Start the update loop
        visibilityValue.textContent = "On";
        button.textContent = "Hide 3D models";
        updatesValue.textContent = "On"; // Ensure updates are "On"
    } else {
        if (map.getLayer('3d-model')) {
            map.removeLayer('3d-model'); // Hide 3D models
        }
        stopUpdateMapLayerLoop(); // Stop the update loop
        visibilityValue.textContent = "Off";
        button.textContent = "Show 3D models";
        updatesValue.textContent = "Off"; // Turn updates "Off" when 3D models are hidden
    }
});

function requestPeerList() {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ action: 'request_peer_list', peer_id: peerId }));
    }
}



let ws = null;
let peerId = null;
let knownPeers = new Map();
let dataChannels = new Map();
let receivedCoords = new Map();
let retryAttempts = new Map();
const maxRetries = 3;
let seenMessages = new Set();
let coordinates = null;
let heartbeatInterval = null;
let gossipInterval = null;
let peerListRequestInterval = null; // Interval for requesting peer list

async function someFunction(accountId, topicId) {
    // Clean up any existing connections
    await cleanup();

    peerId = topicId + '-' + accountId;

    connectToBootstrapServer();

    function generateMessageId() {
        return Math.random().toString(36).substr(2, 9) + '-' + Date.now();
    }

    function updateCoordinates() {
      let longitude = map.getCenter().lng; // Get current longitude from the map
      let latitude = map.getCenter().lat;   // Get current latitude from the map
      const zoomLevel = map.getZoom(); // Get the current zoom level
      let height;

      if (zoomLevel >= 10 && zoomLevel <= 19) {
          height = 50000;
      } else if (zoomLevel <= 9) {
          height = 50000 + (200000 * (10 - zoomLevel)); // Scale from 50000 at zoom 10 to 250000 at zoom 9
      } else if (zoomLevel <= 7) {
          height = 250000 + (450000 * (7 - zoomLevel)); // Scale down from 500000 to 5000000
      } else if (zoomLevel <= 3.5) {
          height = 5000000 + (65000000 * (3.5 - zoomLevel)); // Scale down from 5000000 to 70000000
      } else {
          height = 70000000; // Set height for zoom level 0
      }

        const xInput = longitude; // Set x from current longitude
        const yInput = latitude;  // Set y from current latitude
        const zInput = height;

        const x = parseFloat(xInput);
        const y = parseFloat(yInput);
        const z = parseFloat(zInput);

        // Validate input
        if (isNaN(x) || isNaN(y) || isNaN(z)) {
            console.error('Invalid coordinates: X, Y, Z must be numbers');
            alert('Please enter valid numbers for X, Y, Z');
            return;
        }

        coordinates = { x, y, z };
    }
        // Add this code to set up the interval for updating coordinates
        setInterval(() => {
        updateCoordinates(); // Call the function to update coordinates
    }, 5000); // 500 milliseconds interval



    function startHeartbeat() {
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ action: 'heartbeat', peer_id: peerId }));
            }
        }, 10000); // Send every 10 seconds
    }


let globalPeers = [];

function cleanUpModels() {

    for (let i = models.length - 1; i >= 0; i--) {
        if (!globalPeers.includes(models[i].peer_id)) {
            models.splice(i, 1);
        }
    }
}


function connectToBootstrapServer() {
    ws = new WebSocket('wss://serverws-9avk.onrender.com');
    ws.onopen = () => {
        console.log('Connected to bootstrap server');
        ws.send(JSON.stringify({ action: 'register', peer_id: peerId }));
        startHeartbeat(); // Start sending heartbeats
    };

    ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        if (message.action === 'peer_list') {
            const peers = message.peers;
            globalPeers = peers; // Store the peers in the global array
            await setupWebRTCConnections(peers);
            startGossip();
        } else if (message.action === 'offer') {
            await handleOffer(message.peer_id, message.data);
        } else if (message.action === 'answer') {
            await handleAnswer(message.peer_id, message.data);
        } else if (message.action === 'candidate') {
            await handleCandidate(message.peer_id, message.data);
        }
    };
}

    // Add peer list request interval (every 300 seconds)
    peerListRequestInterval = setInterval(() => {
        requestPeerList();
        cleanUpModels();
    }, 300000); // Request every 300 seconds

async function setupWebRTCConnections(peerIds) {
    for (let remotePeerId of peerIds) {
        if (remotePeerId === peerId || knownPeers.has(remotePeerId)) continue;

        const pc = new RTCPeerConnection({
          iceServers: [
      {
        urls: "stun:stun.relay.metered.ca:80",
      },
      {
        urls: "turn:standard.relay.metered.ca:80",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turn:standard.relay.metered.ca:80?transport=tcp",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turn:standard.relay.metered.ca:443",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turns:standard.relay.metered.ca:443?transport=tcp",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
  ],
        });
        knownPeers.set(remotePeerId, pc);
        monitorWebRTCConnection(remotePeerId, pc);

        const dc = pc.createDataChannel('gossip');
        dataChannels.set(remotePeerId, dc);
        dc.onopen = () => {
            setTimeout(() => sendGossipMessage(remotePeerId), 1000);
        };
        dc.onmessage = (event) => handleGossipMessage(remotePeerId, event.data);
        dc.onclose = () => {
            console.log(`Data channel closed with ${remotePeerId}`);
            dataChannels.delete(remotePeerId);
        };

        pc.ondatachannel = (event) => {
            const incomingDc = event.channel;
            dataChannels.set(remotePeerId, incomingDc);
            incomingDc.onmessage = (event) => handleGossipMessage(remotePeerId, event.data);
            incomingDc.onclose = () => {
                dataChannels.delete(remotePeerId);
            };
        };

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                ws.send(JSON.stringify({
                    action: 'candidate',
                    peer_id: peerId,
                    target_peer_id: remotePeerId,
                    data: event.candidate
                }));
            }
        };

        try {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            ws.send(JSON.stringify({
                action: 'offer',
                peer_id: peerId,
                target_peer_id: remotePeerId,
                data: pc.localDescription
            }));
        } catch (error) {
            console.error(`Failed to create offer for ${remotePeerId}:`, error);
        }
    }
}

function sendGossipMessage(peerId) {
    const dc = dataChannels.get(peerId);
    if (dc && dc.readyState === 'open') {
        const message = { /* your message data */ };
        dc.send(JSON.stringify(message));
    } else {
        console.log(`Cannot send to ${peerId}: Data channel not open`);
    }
}

// Store pending ICE candidates
const pendingCandidates = new Map();

async function handleOffer(senderPeerId, offer) {
    if (knownPeers.has(senderPeerId)) return;

    const pc = new RTCPeerConnection({
      iceServers: [
      {
        urls: "stun:stun.relay.metered.ca:80",
      },
      {
        urls: "turn:global.relay.metered.ca:80",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turn:global.relay.metered.ca:80?transport=tcp",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turn:global.relay.metered.ca:443",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turns:global.relay.metered.ca:443?transport=tcp",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
  ],
    });
    knownPeers.set(senderPeerId, pc);
    monitorWebRTCConnection(senderPeerId, pc);

    pc.onicecandidate = (event) => {
        if (event.candidate) {
            ws.send(JSON.stringify({
                action: 'candidate',
                peer_id: peerId,
                target_peer_id: senderPeerId,
                data: event.candidate
            }));
        }
    };

    pc.ondatachannel = (event) => {
        const dc = event.channel;
        dataChannels.set(senderPeerId, dc);
        dc.onmessage = (event) => handleGossipMessage(senderPeerId, event.data);
        dc.onclose = () => {
            dataChannels.delete(senderPeerId);
        };
    };

    try {
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws.send(JSON.stringify({
            action: 'answer',
            peer_id: peerId,
            target_peer_id: senderPeerId,
            data: pc.localDescription
        }));

        // Process any queued ICE candidates
        if (pendingCandidates.has(senderPeerId)) {
            const candidates = pendingCandidates.get(senderPeerId);
            candidates.forEach(candidate => pc.addIceCandidate(candidate));
            pendingCandidates.delete(peerId);
        }
    } catch (error) {
        console.error(`Failed to handle offer from ${senderPeerId}:`, error);
    }
}

    async function handleAnswer(senderPeerId, answer) {
        const pc = knownPeers.get(senderPeerId);
        if (!pc) return;

        try {
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
        } catch (error) {
            console.error(`Failed to handle answer from ${senderPeerId}:`, error);
        }
    }


    async function handleCandidate(peerId, candidate) {
    const pc = knownPeers.get(peerId);
    if (!pc) return;

    try {
        if (pc.remoteDescription && pc.remoteDescription.type) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } else {
            // Queue the candidate if the remote description is not set
            if (!pendingCandidates.has(peerId)) {
                pendingCandidates.set(peerId, []);
            }
            pendingCandidates.get(peerId).push(candidate);
        }
    } catch (error) {
        console.error(`Failed to handle candidate from ${peerId}:`, error);
    }
}

function monitorWebRTCConnection(peerId, pc) {
    pc.oniceconnectionstatechange = () => {
        if (pc.iceConnectionState === 'connected') {
        } else if (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed') {
            retryWebRTCConnection(peerId);
        }
    };
}

function retryWebRTCConnection(peerId) {
    const attempts = retryAttempts.get(peerId) || 0;
    if (attempts >= maxRetries) {
        knownPeers.delete(peerId);
        dataChannels.delete(peerId);
        retryAttempts.delete(peerId);
        return;
    }

    retryAttempts.set(peerId, attempts + 1);
    knownPeers.delete(peerId);
    dataChannels.delete(peerId);
    setupWebRTCConnections([peerId]);
}

    async function handleGossipMessage(senderPeerId, data) {
        const message = JSON.parse(data);
        const { peer_id, coordinates, ttl, timestamp, messageId, metadata, scaleFactorNFT } = message;

        // Check for duplicates
        if (seenMessages.has(messageId)) {
            return;
        }
        seenMessages.add(messageId);


        const existing = receivedCoords.get(peer_id);
        if (!existing || new Date(timestamp) > new Date(existing.timestamp)) {
            receivedCoords.set(peer_id, { ...coordinates, timestamp });
        }

          // Load URL using the peer ID
  const url = await loadProfileObjectUrl(peer_id);

    // Check if a model from this peer_id already exists
    const modelIndex = models.findIndex(model => model.peer_id === peer_id);

    if (modelIndex !== -1) {
        // Update the existing model
        models[modelIndex] = {
            peer_id: peer_id,
            url: url || 'https://kiloscribe.com/api/inscription-cdn/0.0.8392276',
            origin: [coordinates.x, coordinates.y],
            altitude: coordinates.z,
            scaleFactorNFT: scaleFactorNFT
        };
    } else {
        // Append new message to models array
        models.push({
            peer_id: peer_id,
            url: url || 'https://kiloscribe.com/api/inscription-cdn/0.0.8392276',
            origin: [coordinates.x, coordinates.y],
            altitude: coordinates.z,
            scaleFactorNFT: scaleFactorNFT
        });
    }
        if (ttl > 0) {
            message.ttl -= 1;
            message.metadata.hopCount += 1; // Increment hop count
            forwardGossipMessage(message);
        }
    }
    function startGossip() {
        setTimeout(() => {
            setInterval(() => {
                if (knownPeers.size === 0) {
                    return;
                }
                const message = {
                    peer_id: peerId,
                    coordinates: coordinates,
                    scaleFactorNFT: finalScaleForModel,
                    ttl: 3,
                    timestamp: new Date().toISOString(),
                    messageId: generateMessageId(),
                    metadata: {
                        hopCount: 0,
                        lastUpdated: new Date().toISOString()
                    }
                };
                const fanout = Math.max(1, Math.floor(Math.sqrt(knownPeers.size))); // Dynamic fanout
                const targetPeers = Array.from(knownPeers.entries())
                    .sort(() => Math.random() - 0.5)
                    .slice(0, fanout);
                for (let [peerId, pc] of targetPeers) {
                    const dc = dataChannels.get(peerId);
                    if (dc && dc.readyState === 'open') {
                        dc.send(JSON.stringify(message));
                    } else {
                        retryWebRTCConnection(peerId);
                    }
                }
            }, 1000);
        }, 5000);
    }
    function forwardGossipMessage(message) {
        const fanout = Math.max(1, Math.floor(Math.sqrt(knownPeers.size))); // Dynamic fanout
        const targetPeers = Array.from(knownPeers.entries())
            .sort(() => Math.random() - 0.5)
            .slice(0, fanout);
        for (let [peerId, pc] of targetPeers) {
            const dc = dataChannels.get(peerId);
            if (dc && dc.readyState === 'open') {
                dc.send(JSON.stringify(message));
            } else {
                console.log(`Cannot forward to ${peerId}: Data channel not open`);
            }
        }
    }
                  async function loadProfileObjectUrl(payerId) {
                  if (!payerId) {
                  console.error("payerId is undefined");
                  return null;
                  }
                  // Remove 'peer-' prefix if present
                  const cleanPayerId = payerId.split('-')[1];
                  const topicId = "0.0.9609898";
                  const accountUrl = []; // Initialize an empty array to store account URLs
                  try {
                  const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
                  // Check if result exists and has messages
                  if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
                    console.log("No profile object found, using defaults");
                    return null; // Return null if no messages
                  }
                  // Filter messages to find those from the current user
                  const userMessages = result.messages.filter(message => message.payer === cleanPayerId);
                  // Get the last message from the filtered user messages
                  const lastMessage = userMessages[userMessages.length - 1];
                  // Check if the last message has valid data
                  if (lastMessage && lastMessage.data && lastMessage.data.urls && lastMessage.data.urls.length > 0) {
                    return lastMessage.data.urls[0]; // Return the first URL
                  }
                  return null; // Return null if no valid URL found
                  } catch (error) {
                  console.log("Error in loadProfileObject:", error);
                  return null; // Return null instead of throwing error
                  }
                  }
                    }
                    async function cleanup() {
        console.log('[Client] Cleaning up connections and state');
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.close();
            console.log('[Client] Closed WebSocket connection');
        }
        ws = null;
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
            console.log('[Client] Cleared heartbeat interval');
        }
        if (gossipInterval) {
            clearInterval(gossipInterval);
            gossipInterval = null;
            console.log('[Client] Cleared gossip interval');
        }
        if (peerListRequestInterval) {
            clearInterval(peerListRequestInterval);
            peerListRequestInterval = null;
            console.log('[Client] Cleared peer list request interval');
        }
        for (const [peerId, pc] of knownPeers.entries()) {
            pc.close();
            const dc = dataChannels.get(peerId);
            if (dc) {
                dc.close();
            }
            console.log(`[Client] Closed WebRTC connection with ${peerId}`);
        }
        knownPeers.clear();
        dataChannels.clear();
        receivedCoords.clear();
        retryAttempts.clear();
        seenMessages.clear();
        peerId = null;
        coordinates = null;
        models.length = 0;
        console.log('[Client] Cleared all state');
    }
    loader.updateProgress();
      }}
 </script>
  <script src="script.js"></script>
  </body>
</html>

