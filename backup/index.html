<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no" />
  <title>Meritocracy</title>
  <link rel="stylesheet" href="main.css">


  <div class="loader-container" id="loaderContainer">
    <div>
      <div class="spinner"></div>
      <div class="loader">
        <div class="progress" id="progressBar"></div>
      </div>
      <div class="percentage" id="percentageText">0%</div>
    </div>
  </div>

  <script data-hcs-config="" data-hcs-cdn-url="https://kiloscribe.com/api/inscription-cdn/" data-hcs-network="mainnet"
    data-hcs-debug="true" data-hcs-retry-attempts="5" data-hcs-retry-backoff="500"
    data-hcs-show-loading-indicator="false" data-hcs-loading-callback-name="setLoadingIndicator"
    type="e5a3c1b79eab779120034ec1-text/javascript"></script>

  <link data-src="hcs://1/0.0.8287094" data-script-id="map css" />

  <script data-src="hcs://1/0.0.8269272" data-script-id="maplibre"></script>

  <script data-src="hcs://1/0.0.8269285" data-script-id="supercluster"></script>

  <script data-src="hcs://1/0.0.8355670" data-script-id="threejs 137 + GLTFLoader"></script>

  <script data-src="hcs://1/0.0.9740486" data-script-id="walletconnect"></script>

  <script data-src="hcs://1/0.0.9678314" data-script-id="DRACOLoader"></script>

  <script data-src="hcs://1/0.0.9705945" data-script-id="dracoBase64"></script>

  <script data-src="hcs://1/0.0.9961904" data-script-id="helia@5.5.1"></script>

  <script data-src="hcs://1/0.0.9961944" data-script-id="unixfs@5.1.0"></script>

  <script data-src="hcs://1/0.0.9966383" data-script-id="libp2p.bundle"></script>

  <script data-src="hcs://1/0.0.10013779" data-script-id="multiformats@13.4.1"></script>

  <script data-src="hcs://1/0.0.10013806" data-script-id="delegated-peer-routing@4.0.14"></script>

  <script data-src="hcs://1/0.0.10013810" data-script-id="kubo-rpc-client@latest"></script>

  <script data-src="hcs://1/0.0.10013813" data-script-id="libp2p-noise@17.0.0"></script>

  <script data-src="hcs://1/0.0.10015601" data-script-id="helia-verified-fetch@3.2.3"></script>

  <script data-src="hcs://1/0.0.10017498" data-script-id="helia-bitswap@3.0.3"></script>

  <script data-src="hcs://1/0.0.10034692" data-script-id="HeliaBlockBrokers"></script>

  <script data-src="hcs://1/0.0.10040862" data-script-id="sodium"></script>


</head>

<body>

  <div class="app-container">
    
    <!-- Left Sidebar Panel -->
    <div class="sidebar-panel" id="sidebarPanel">
      <div class="sidebar-header">
        <h3 class="sidebar-title">Menu</h3>
        <button class="sidebar-toggle" id="sidebarToggle">
          <span class="toggle-icon">←</span>
        </button>
      </div>
      
      <div class="sidebar-content">
        <div class="sidebar-section">
          <h4 class="section-title">Wallet</h4>
          <button class="modern-btn modern-btn-primary" id="modernConnectWallet">
            Connect Wallet
          </button>
          <button class="modern-btn modern-btn-secondary" id="modernDisconnectWallet" style="display: none;">
            Disconnect
          </button>
          <div class="account-display" id="modernAccountId"></div>
        </div>
      </div>
    </div>

    <!-- Main View Panel -->
    <div class="view-panel" id="viewPanel">
      <div id="map"></div>
      <div id="three-container"></div>
      
      <input id="coordinates-display" value="Coordinates:" />
      <button id="copy-coordinates" class="copy-coordinates"></button>
      <div id="crosshair"></div>
    </div>

    <!-- Right Sidebar Panel -->
    <div class="sidebar-panel right-sidebar-panel" id="rightSidebarPanel">
      <div class="sidebar-header">
        <h3 class="sidebar-title">Tools</h3>
        <button class="sidebar-toggle" id="rightSidebarToggle">
          <span class="toggle-icon">→</span>
        </button>
      </div>
      
      <div class="sidebar-content">
        <div class="sidebar-section">
          <h4 class="section-title">Controls</h4>
          <button class="modern-btn modern-btn-secondary" id="rightToggleControls">
            Show Controls
          </button>
          <button class="modern-btn modern-btn-secondary" id="rightToggleVisibility">
            Visibility
          </button>
        </div>
        
        <div class="sidebar-section">
          <h4 class="section-title">3D View</h4>
          <button class="modern-btn modern-btn-secondary" id="rightToggleFov">
            Your POV
          </button>
          <button class="modern-btn modern-btn-secondary" id="rightToggleModels">
            Model Settings
          </button>
        </div>
      </div>
    </div>

  <!-- Sidebar Toggle Buttons (when collapsed) -->
  <button class="sidebar-opener" id="sidebarOpener" style="display: none;">
    <span class="opener-icon">→</span>
  </button>
  
  <button class="sidebar-opener right-sidebar-opener" id="rightSidebarOpener" style="display: none;">
    <span class="opener-icon">←</span>
  </button>

  <!-- Original menu buttons - repositioned within view panel -->
  <div class="original-menu-container">
    <button id="main-toggle-btn" class="options-and-topic">OPTIONS</button>
    <button id="toggle-toolbar-btn-btn" class="options-and-topic" style="display: none;">TOOLBAR</button>
    <button id="toggle-your-fov-btn-btn" class="options-and-topic" style="display: none;">YOUR POV</button>
    <button id="topic-chat-btn" class="options-and-topic">TOPIC CHAT</button>
  </div>


  <!-- Left menu buttons - restored individual positioning -->
  <button id="toggle-controls-btn" class="menu_buttons menu-btn-1">CONTROLS</button>
  <button id="toggle-your-fov-btn" class="menu_buttons menu-btn-2">YOUR POV</button>
  <button id="toggle-visibility-controls-btn" class="menu_buttons menu-btn-3">VISIBILITY</button>
  <button id="toggle-toolbar-btn" class="menu_buttons menu-btn-4">TOOLBAR</button>
  <button id="toggle-encrypted-chat-btn" class="menu_buttons menu-btn-5">E2ECHAT</button>

  <div id="toolbar" class="toolbar" style="display: none; flex-direction: column;">
    <div class="toolbar-column" id="Edit_Profile">Edit
    </div>
    <div class="toolbar-column" id="Load_Everything">Load
    </div>
    <div class="toolbar-column" id="Upload_To_IPFS">Upload
    </div>
    <div class="toolbar-column" id="Create_New_Topic">Create
    </div>
    <div class="toolbar-column" id="Create_Marker">Marker
    </div>
    <div class="toolbar-column" id="Create_Polygon">Polygon
    </div>
    <div class="toolbar-column" id="Set_Rules">Set Rules
    </div>
    <div class="toolbar-column" id="NFT-utility">NFT Utility
    </div>
    <div class="toolbar-column" id="Change_Memo">Update Topic
    </div>
    <div class="toolbar-column" id="Stack_topic_IDs">Stack topic IDs
    </div>
  </div>

  <div id="Edit_Profile-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
    <div id="Edit_Profile-column-container" class="toolbar-containers" onclick="event.stopPropagation();">

      <textarea type="text" id="toolbar-input" placeholder="URL/Name/Domain" class="toolbar-column"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <div style="display: flex; flex-direction: row; width: 100%;">
        <button class="toolbar-column-btns" id="button1" style="display: block;">Picture
        </button>
        <button class="toolbar-column-btns" id="button2" style="display: block; margin-left: 1vw;">Username
        </button>
        <button class="toolbar-column-btns" id="button_for_click_url"
          style="display: block; margin-left: 1vw;">CLICK2LINK
        </button>
      </div>

      <textarea type="text" id="Edit_Profile-topic-id" placeholder="Topic ID" class="toolbar-column"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <div style="display: flex; flex-direction: row; width: 100%;">
        <button class="toolbar-column-btns" id="button3">TopicID name
        </button>
        <button class="toolbar-column-btns" id="button_for_topic2pic" style="margin-left: 1vw;">TOPIC2PIC
        </button>
      </div>

      <textarea type="text" id="domain-time-left" placeholder="Domain Time Left" class="toolbar-column"
        onclick="event.stopPropagation();" readonly>
    </textarea>

      <button class="toolbar-column-btns" id="button4">Check Domain Availability
      </button>

      <label for="domain-time-left" style="font-size: 2vh;">1 USDC
        (<span style="cursor: pointer; color: rgb(255, 255, 255); text-decoration: underline;" onclick="navigator.clipboard.writeText('0.0.456858')
    .then(() => alert('Copied to clipboard: 0.0.456858'))
    .catch(err => console.error('Failed to copy: ', err));">0.0.456858</span>):
      </label>
      <button class="toolbar-column-btns" id="button5" style="margin-top: 0.5vh;">Add 28 days to domain
      </button>

    </div>
  </div>

  <div id="load-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
    <div id="load-column-container" class="toolbar-containers" onclick="event.stopPropagation();">

      <textarea class="toolbar-column" type="text" id="input-field" placeholder="Domain/Topic ID"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <button id="toolbar-load" class="toolbar-column-btns">Load Data
      </button>

      <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topics with names not domains:
      </label>

      <div class="toolbar-column" style="user-select: text;" id="loaded-topics" placeholder="Loaded Topics"
        onclick="event.stopPropagation();"></div>

      <textarea class="toolbar-column" type="text" id="load-msgs-from-ids"
        placeholder="user ID or IDs separated by comma" onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <button id="load-msgs-from-ids-button" class="toolbar-column-btns">Load Messages From
      </button>

    </div>
  </div>

  <div id="upload-to-ipfs-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
    <div id="upload-to-ipfs-column-container" class="toolbar-containers" onclick="event.stopPropagation();">

      <label for="fileInput" style="font-size: 2vh; padding: 0px;">Currentlly work in progress, once finished u will be
        able to upload imgs/videos/files
      </label>

      <input type="file" class="toolbar-column" id="fileInput" />
      <button id="upload-to-ipfs-button" class="toolbar-column-btns">Upload to IPFS</button>
      <textarea class="toolbar-column" id="cid-output" placeholder="CID" readonly></textarea>

      <textarea class="toolbar-column" id="cid-input" type="text" placeholder="Enter CID"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <!-- ADD THIS: Content type selector for fetch -->
      <select class="toolbar-column" id="content-type">
        <option value="image">Image/GIF</option>
        <option value="video">Video</option>
      </select>

      <button class="toolbar-column-btns" id="fetch-from-ipfs-button">Fetch from IPFS</button>
      <div id="cid-output"></div> <!-- Note: You have two #cid-output elements; consider consolidating to one -->
      <div id="image-container"></div>

      <button class="toolbar-column-btns" id="copy-share-link" style="display: none;">Copy Share Link</button>

    </div>
  </div> <!-- Close the div properly -->

  <div id="create-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
    <div id="create-column-container" class="toolbar-containers" onclick="event.stopPropagation();">
      <div class="toolbar-group">
        <textarea class="toolbar-column" type="text" id="input-field-5-1" placeholder="Admins 0.0.1,0.0.2.."
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

        <textarea class="toolbar-column" type="text" id="input-field-5-2" placeholder="Use Private Key here"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

        <label for="public-key-label" style="font-size: 2vh; padding: 0px; user-select: text;">If it doesnt load go to
          hashscan.io or app.dragonglass.me and input your acc id:
        </label>

        <input class="toolbar-column" type="text" id="input-field-5" placeholder="Generated Topic ID"
          onclick="event.stopPropagation();" readonly />

        <!-- <label for="public-key-label"style="font-size: 2vh; padding: 0px;">Set fee for each message:</label>
      <textarea
      class="toolbar-column"
      type="text"
      id="input-field-5-3"
      placeholder="Set amount of fee"
      style="
        background-color: transparent;
        overflow: hidden; /* Hide scrollbars */
        resize: none; /* Prevent manual resizing */
      "
      onclick="event.stopPropagation();"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea
      class="toolbar-column"
      type="text"
      id="input-field-5-4"
      placeholder="Set token id of fee"
      style="
        background-color: transparent;
        overflow: hidden; /* Hide scrollbars */
        resize: none; /* Prevent manual resizing */
      "
      onclick="event.stopPropagation();"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea
      class="toolbar-column"
      type="text"
      id="input-field-5-5"
      placeholder="Set royalty account"
      style="
        background-color: transparent;
        overflow: hidden; /* Hide scrollbars */
        resize: none; /* Prevent manual resizing */
      "
      onclick="event.stopPropagation();"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea> -->

        <button id="submit-button-Create_New_Topic" class="toolbar-column-btns" style="display: block;">Create
        </button>
      </div>

      <label for="public-key-label" style="font-size: 2vh; padding: 0px;">Public Key:
      </label>
      <textarea class="toolbar-column" id="generated-public-key" placeholder="Generated Public Key" readonly
        onclick="event.stopPropagation();"></textarea>

      <label for="private-key-label" style="font-size: 2vh; padding: 0px;">Private Key:
      </label>

      <textarea class="toolbar-column" id="generated-private-key" placeholder="Generated Private Key"
        onclick="event.stopPropagation();" readonly></textarea>

      <button id="generate-private-and-public-key" class="toolbar-column-btns" style="display: block;">Generate
      </button>

    </div>
  </div>


  <div id="marker-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
    <div id="marker-column-container" class="toolbar-containers" onclick="event.stopPropagation();">
      <div class="toolbar-group">
        <textarea class="toolbar-column" type="text" id="input-field-2-0" placeholder="Domain/Topic ID"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <textarea class="toolbar-column" type="text" id="input-field-number-of-marker" placeholder="Number of marker"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <textarea class="toolbar-column" type="text" id="input-field-2-3" placeholder="Coordinates long,lat"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
          onclick="event.stopPropagation();"></textarea>
      </div>

      <textarea class="toolbar-column" type="text" id="input-field-coverimage-marker" placeholder="Cover Image URL"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
        onclick="event.stopPropagation();"></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-2-1" placeholder="Title"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-image-marker" placeholder="Image URL"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <div style="position: relative;">
        <textarea class="toolbar-column" type="text" id="input-field-2-2" placeholder="Message" maxlength="256"
          onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';
      document.getElementById('char-counter-marker').textContent = this.value.length + '/256';"></textarea>
        <div id="char-counter-marker"
          style="position: absolute; bottom: 5px; right: 10px; font-size: 2vh; color: #666;">0/256
        </div>
      </div>

      <button id="submit-button-Create_Marker" class="toolbar-column-btns">
        Submit
      </button>

      <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topic Rules:</label>

      <div class="toolbar-column" type="text" style="user-select: text;" id="loaded-topic-rules-for-marker"
        placeholder="Loaded Topic Rules" onclick="event.stopPropagation();"></div>
      <button id="load-topic-rules-for-marker" class="toolbar-column-btns">
        Load Topic Rules
      </button>

      <div style="display: flex; flex-direction: row; width: 100%;">
        <textarea class="toolbar-column" type="text" id="input-field-delete-marker-number"
          placeholder="Number of marker"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <button id="delete-marker-number" class="toolbar-column-btns">
          Delete marker number
        </button>
      </div>

    </div>
  </div>

  <div id="polygon-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
    <div id="polygon-column-container" class="toolbar-containers" onclick="event.stopPropagation();">
      <div class="toolbar-group">
        <textarea class="toolbar-column" type="text" id="input-field-3-0" placeholder="Domain/Topic ID"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <textarea class="toolbar-column" type="text" id="input-field-number-of-polygon" placeholder="Number of polygon"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <textarea class="toolbar-column" type="text" id="input-field-3-3" placeholder="TOP LEFT long,lat"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <textarea class="toolbar-column" type="text" id="input-field-3-5" placeholder="BOTTOM RIGHT long,lat"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      </div>

      <textarea class="toolbar-column" type="text" id="input-field-coverimage-polygon" placeholder="Cover Image URL"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-3-1" placeholder="Title"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      <textarea class="toolbar-column" type="text" id="input-field-image-polygon" placeholder="Image URL"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <div style="position: relative;">
        <textarea class="toolbar-column" id="input-field-3-2" placeholder="Message" maxlength="256"
          onclick="event.stopPropagation();" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';
      document.getElementById('char-counter-polygon').textContent = this.value.length + '/256';"></textarea>
        <div id="char-counte-polygon"
          style="position: absolute; bottom: 5px; right: 10px; font-size: 2vh; color: #666;">0/256
        </div>
      </div>


      <button id="submit-button-Create_Polygon" class="toolbar-column-btns" style="display: block;">Submit
      </button>
      <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topic Rules:</label>
      <div class="toolbar-column" type="text" style="user-select: text;" id="loaded-topic-rules-for-polygon"
        placeholder="Loaded Topic Rules" onclick="event.stopPropagation();"></div>
      <button id="load-topic-rules-for-polygon" class="toolbar-column-btns">Load Topic Rules
      </button>

      <div style="display: flex; flex-direction: row; width: 100%;">
        <textarea class="toolbar-column" type="text" id="input-field-delete-polygon-number"
          placeholder="Number of polygon"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <button id="delete-polygon-number" class="toolbar-column-btns">
          Delete polygon number
        </button>
      </div>

    </div>
  </div>

  <div id="rules-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
    <div id="rules-column-container" class="toolbar-containers" onclick="event.stopPropagation();">

      <textarea class="toolbar-column" type="text" id="input-field-topic-id-for-rules" placeholder="Domain/Topic ID"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topic Rules:
      </label>
      <div class="toolbar-column" style="user-select: text;" id="loaded-topic-rules-for-topic"
        placeholder="Loaded Topic Rules" onclick="event.stopPropagation();"></div>
      <button id="load-topic-rules-for-topic" class="toolbar-column-btns">Load Topic Rules
      </button>
      <label for="input-field-rules-for-polygons" style="font-size: 2vh; padding: 0px;">These come in pair and they
        overwrite last set:
      </label>

      <div class="toolbar-group">
        <div style="margin-bottom: 0px;">
          <label for="input-field-rules-for-polygons" style="font-size: 2vh; padding: 0px;">For polygons:
          </label>
          <textarea class="toolbar-column" type="text" id="input-field-topic-id-for-polygons"
            placeholder="NFT ID (set to zero to allow all)" onclick="event.stopPropagation();"
            oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        </div>

        <textarea class="toolbar-column" type="text" id="input-field-messages-per-nft-for-polygons"
          placeholder="how many polygons per NFT" onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

        <textarea class="toolbar-column" type="text" id="input-field-messages-size-for-polygons"
          placeholder="max size = (360,180) / (number)" onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

        <div style="margin-bottom: 10px;">
          <label for="input-field-add-rules" style=" font-size: 2vh;padding: 0px;">For markers:
          </label>
          <textarea class="toolbar-column" type="text" id="input-field-topic-id-for-markers"
            placeholder="NFT ID (set to zero to allow all)" onclick="event.stopPropagation();"
            oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        </div>

        <textarea class="toolbar-column" type="text" id="input-field-messages-per-nft-for-markers"
          placeholder="how many markers per NFT" onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <button id="submit-button-Set_Rules" class="toolbar-column-btns" style="display: block;">Submit
        </button>
        <div style="margin-bottom: 10px;"></div>
      </div>

    </div>
  </div>

  <div id="utility-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
    <div id="utility-column-container" class="toolbar-containers" onclick="event.stopPropagation();">

      <textarea class="toolbar-column" type="text" id="input-field-topic-id-for-utility" placeholder="Domain/Topic ID"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topic Logic:
      </label>
      <div class="toolbar-column" style="user-select: text;" id="loaded-topic-rules-for-utility"
        placeholder="Loaded Topic Rules" onclick="event.stopPropagation();"></div>
      <button id="load-topic-rules-for-utility" class="toolbar-column-btns">Load Topic Rules
      </button>

      <label for="input-field-add-remove-NFT-for-model" style=" font-size: 2vh;padding: 0px;"> Model sharing:
      </label>
      <textarea class="toolbar-column" type="text" id="input-field-add-remove-NFT-for-model"
        placeholder="NFT ID (or IDs seperated by commas)" onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <div class="button-group" style="display: flex; flex-direction: row; align-items: center;">
        <button id="submit-button-add-NFT-for-model" class="toolbar-column-btns">Add
        </button>
        <button id="submit-button-remove-NFT-for-model" class="toolbar-column-btns" style="margin-left: 8vw;">Remove
        </button>
      </div>

      <label for="input-field-add-remove-scale-for-model" style=" font-size: 2vh;padding: 0px;">Model scale factor:
      </label>
      <textarea class="toolbar-column" type="text" id="input-field-add-remove-scale-for-model"
        placeholder="scale (only one NFT at a time)" onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <div class="button-group" style="display: flex; flex-direction: row; align-items: center;">
        <button id="submit-button-add-scale-for-model" class="toolbar-column-btns">Add
        </button>
        <button id="submit-button-remove-scale-for-model" class="toolbar-column-btns" style="margin-left: 8vw;">Remove
        </button>
      </div>


      <label for="input-field-add-remove-topic-chat" style=" font-size: 2vh;padding: 0px;">Topic Chat:
      </label>
      <textarea class="toolbar-column" type="text" id="input-field-add-remove-topic-chat"
        placeholder="NFT ID (or IDs seperated by commas)" onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <div class="button-group" style="display: flex; flex-direction: row; align-items: center;">
        <button id="submit-button-add-topic-chat" class="toolbar-column-btns">Add
        </button>
        <button id="submit-button-remove-topic-chat" class="toolbar-column-btns" style="margin-left: 8vw;">Remove
        </button>
      </div>

    </div>
  </div>

  <div id="memo-column" style="display: none; position: absolute; z-index: 1002; top:10vh;">
    <div id="memo-column-container" class="toolbar-containers" onclick="event.stopPropagation();">

      <div class="toolbar-group">
        <textarea class="toolbar-column" type="text" id="input-field-topic-id" placeholder="Domain/Topic ID"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <textarea class="toolbar-column" type="text" id="input-field-admin-key" placeholder="public key"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <textarea class="toolbar-column" type="text" id="input-field-memo" placeholder="Admins 0.0.1,0.0.2.."
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      </div>

      <label for="public-key-label" style="font-size: 2vh; padding: 0px;">Optional fee for each message:
      </label>

      <div class="toolbar-group">
        <textarea class="toolbar-column" type="text" id="input-field-fee" placeholder="Set amount of fee"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <textarea class="toolbar-column" type="text" id="input-field-fee-token" placeholder="Set token id of fee"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
        <textarea class="toolbar-column" type="text" id="input-field-royal-acc" placeholder="Set royalty account"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      </div>

      <button id="submit-button-Change_Memo" class="toolbar-column-btns" style="display: block;">Submit
      </button>

    </div>
  </div>

  <div id="stack-topic-ids" style="display: none; position: absolute; z-index: 1002; top:10vh;">
    <div id="stack-topic-ids-container" class="toolbar-containers" onclick="event.stopPropagation();">

      <textarea class="toolbar-column" type="text" id="stack-topic-ids-topic" placeholder="Domain/Topic ID"
        click="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      <textarea class="toolbar-column" type="text" id="stack-topic-add-topic" placeholder="0.0.1,0.0.2.."
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      <button id="add-topic-id" class="toolbar-column-btns" style="display: block;">Stack
      </button>
      <textarea class="toolbar-column" type="text" id="stack-topic-remove-topic" placeholder="0.0.1,0.0.2.."
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      <button id="remove-topic-id" class="toolbar-column-btns" style="display: block;">Remove
      </button>

    </div>
  </div>

  <!-- Old wallet buttons - hidden since we have modern ones -->
  <div class="flex-container" style="display: none;">
    <div id="wallet-section">
      <button id="connect-wallet-btn">Connect Wallet
      </button>
      <button id="disconnect-wallet-btn">Disconnect
      </button>
      <div class="account-info">
        <div id="account-id" style="margin-left: 0.3vh;"></div>
      </div>
    </div>
  </div>

  <div id="left-dpad" class="button-container">
    <button class="touch-button"></button>
    <button id="left-up" class="touch-button"></button>
    <button class="touch-button"></button>
    <button id="left-left" class="touch-button"></button>
    <button class="touch-button"></button>
    <button id="left-right" class="touch-button"></button>
    <button class="touch-button"></button>
    <button id="left-down" class="touch-button"></button>
    <button class="touch-button"></button>
  </div>

  <div id="right-dpad" class="button-container">
    <button class="touch-button"></button>
    <button id="right-up" class="touch-button"></button>
    <button class="touch-button"></button>
    <button id="right-left" class="touch-button"></button>
    <button class="touch-button"></button>
    <button id="right-right" class="touch-button"></button>
    <button class="touch-button"></button>
    <button id="right-down" class="touch-button"></button>
    <button class="touch-button"></button>
  </div>

  <div id="zoom-controls">
    <button id="zoom-in" class="zoom-button">+</button>
    <button id="zoom-out" class="zoom-button">-</button>
  </div>

  <input type="range" id="speed-slider" min="0.1" max="5" step="0.01" value="1" style="display: none;" />


  <div id="topic-chat-container" class="topic-chat-container"
    style="display: none; position: absolute; z-index: 1002; top: 10vh;">
    <div class="chat-topic-chat-container" onclick="event.stopPropagation();">

      <div style="display: flex; align-items: center;">

        <textarea class="toolbar-column" type="text" id="topic-chat-topic-id" placeholder="Domain/Topic ID"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

        <div style="display: flex; align-items: center;">
          <button id="load-msgs-from" class="toolbar-column-btns" style="margin-left: 1vw; width: 20vw;">Load
          </button>
          <button id="show-options-from-topic-chat" class="toolbar-column-btns"
            style="margin-left: 1vw; width: 20vw;">Options
          </button>
          <button id="show-options-from-topic-chat-btn" display: none; class="toolbar-column-btns"
            style="margin-left: 1vw; width: 20vw;">Hide
          </button>
        </div>
      </div>

      <div id="options-from-topic-chat" style="display: none;">

        <label for="from-mmddyyyy-encrypted-chat" style="font-size: 2vh; padding-bottom: 0.5vh;">Month Day Year:
          <div style="display: flex; align-items: center;">
            <input type="number" id="from-mmddyyyy" class="toolbar-column" step="1" placeholder="MMDDYYYY" />
            <input type="number" id="to-mmddyyyy" class="toolbar-column" step="1" placeholder="MMDDYYYY"
              style="margin-left: 1vw;" />
            <button id="topic-msgs-filter" class="toolbar-column-btns" style="width: 50vw; margin-left: 1vw;">Filter
            </button>
          </div>
        </label>

        <label for="from-mmddyyyy-encrypted-chat" style="font-size: 2vh; padding-bottom: 0.5vh;">Hour Minute Second:
          <div style="display: flex; align-items: center;">
            <input type="number" id="from-hhmmss" class="toolbar-column" step="1" placeholder="HHMMSS" />
            <input type="number" id="to-hhmmss" class="toolbar-column" step="1" placeholder="HHMMSS"
              style="margin-left: 1vw;" />
            <button id="topic-msgs-filter-time" class="toolbar-column-btns"
              style="width: 50vw; margin-left: 1vw;">Filter
            </button>
          </div>
        </label>

      </div>

      <div class="chat-container" id="messages-from-topic-chat" onclick="event.stopPropagation();">
        <textarea style="
      width: 100%;
      height: 100px;
      resize: none; /* Prevent manual resizing */
      overflow: auto; /* Enable scrolling */
      background-color: transparent;
      border: none;
      " onfocus="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      </div>

      <div style="position: relative;">
        <textarea class="toolbar-column" type="text" id="user-write-message"
          placeholder="Write a message (max 256 characters)" style="
      max-height: 50vh;
      overflow: auto;
      " onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px'; document.getElementById('char-counter').textContent = this.value.length + '/256';"
          maxlength="256"></textarea>
        <div id="char-counter" style="position: absolute; bottom: 5px; right: 10px; font-size: 2vh; color: #666;">0/256
        </div>
      </div>

      <div style="display: flex; align-items: center;">
        <button id="go-to-top-msgs" class="toolbar-column-btns">Go to the top
        </button>
        <button id="post-msg" class="toolbar-column-btns" style="margin-left: 1vw ">Submit Message
        </button>
      </div>

    </div>
  </div>


  <div id="encrypted-chat-container" class="topic-chat-container"
    style="display: none; position: absolute; z-index: 1002; top: 10vh;">
    <div class="chat-encrypted-chat-container" onclick="event.stopPropagation();">

      <textarea class="toolbar-column" type="text" id="encrypted-chat-private-key" placeholder="Private Key"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <div style="display: flex; align-items: center;">

        <textarea class="toolbar-column" type="text" id="encrypted-chat-topic-id" placeholder="Domain/Topic ID"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

        <div style="display: flex; align-items: center;">
          <button id="load-msgs-from-encrypted-chat" class="toolbar-column-btns"
            style="margin-left: 1vw; width: 20vw;">Load
          </button>
          <button id="show-options-from-encrypted-chat" class="toolbar-column-btns"
            style="margin-left: 1vw; width: 20vw;">Options
          </button>
          <button id="show-options-from-encrypted-chat-btn" display: none; class="toolbar-column-btns"
            style="margin-left: 1vw; width: 20vw;">Hide
          </button>
        </div>
      </div>

      <div id="options-from-encrypted-chat" style="display: none;">

        <label for="from-mmddyyyy-encrypted-chat" style="font-size: 2vh; padding-bottom: 0.5vh;">Month Day Year:
          <div style="display: flex; align-items: center;">
            <input type="number" id="from-mmddyyyy-encrypted-chat" class="toolbar-column" step="1"
              placeholder="MMDDYYYY" />
            <input type="number" id="to-mmddyyyy-encrypted-chat" class="toolbar-column" step="1" placeholder="MMDDYYYY"
              style="margin-left: 1vw;" />
            <button id="topic-msgs-filter-encrypted-chat" class="toolbar-column-btns"
              style="width: 50vw; margin-left: 1vw;">Filter
            </button>
          </div>
        </label>

        <label for="from-mmddyyyy-encrypted-chat" style="font-size: 2vh; padding-bottom: 0.5vh;">Hour Minute Second:
          <div style="display: flex; align-items: center;">
            <input type="number" id="from-hhmmss-encrypted-chat" class="toolbar-column" step="1" placeholder="HHMMSS" />
            <input type="number" id="to-hhmmss-encrypted-chat" class="toolbar-column" step="1" placeholder="HHMMSS"
              style="margin-left: 1vw;" />
            <button id="topic-msgs-filter-time-encrypted-chat" class="toolbar-column-btns"
              style="width: 50vw; margin-left: 1vw;">Filter
            </button>
          </div>
        </label>

        <textarea class="toolbar-column" style="text-align: center; padding-top: 2vh;" type="text"
          id="load-msgs-from-ids-encrypted-chat" placeholder="User ID or IDs separated by comma"
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

        <button id="load-msgs-from-ids-encrypted-chat-button" class="toolbar-column-btns">^ Load Messages From ^
        </button>

      </div>

      <div class="chat-container" id="messages-from-encrypted-chat" onclick="event.stopPropagation();">
        <textarea style="
      width: 100%;
      height: 100px;
      resize: none; /* Prevent manual resizing */
      overflow: auto; /* Enable scrolling */
      background-color: transparent;
      border: none;
      " onfocus="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
      </div>

      <textarea class="toolbar-column" type="text" id="encrypted-chat-public-key" placeholder="Public Key"
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>

      <div style="position: relative;">
        <textarea class="toolbar-column" type="text" id="user-write-message-encrypted-chat"
          placeholder="Write a message (max 256 characters)" style="
      max-height: 50vh;
      overflow: auto;
      " onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px'; document.getElementById('char-counter').textContent = this.value.length + '/256';"
          maxlength="256"></textarea>
        <div id="char-counter" style="position: absolute; bottom: 5px; right: 10px; font-size: 2vh; color: #666;">0/256
        </div>
      </div>

      <div style="display: flex; align-items: center;">
        <button id="go-to-top-msgs-encrypted-chat" class="toolbar-column-btns">Go to the top
        </button>
        <button id="post-msg-encrypted-chat" class="toolbar-column-btns" style="margin-left: 1vw ">Submit Message
        </button>
      </div>

    </div>
  </div>




  <div id="rotation-controls" class='rotation-controls' onclick="event.stopPropagation();">
    <div class="toolbar-column" id="change-model-settings">Model Settings
    </div>
    <div class="toolbar-column" id="change-crosshair-settings">Crosshair Settings
    </div>
    <div class="toolbar-column" id="change-color-of-main-buttons">Color of Main Buttons
    </div>
    <div class="toolbar-column" id="change-marker-options">Marker Options
    </div>
    <div class="toolbar-column" id="change-button-input-settings">Button/Input Settings
    </div>
    <div class="toolbar-column" id="change-topic-chat-options">Topic chat Colors
    </div>
  </div>




  <div id="visibility-controls"
    style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
    <div class="chat-topic-chat-container" onclick="event.stopPropagation();">

      <div style="display: flex; align-items: center; margin-bottom: 1vh;">
        <label for="time-input"
          style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">Enter a time of
          update in milliseconds:
        </label>
      </div>

      <div style="display: flex; align-items: center; margin-bottom: 1vh;">
        <input type="number" id="time-input" class="toolbar-column-btns" />
        <button id="update-loop" class="toolbar-column-btns"
          style="width: 50vw;  margin-left: 1vw; color: white; text-shadow: 0 0 0.5vh black;">Update time
        </button>
      </div>

      <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
        <label for="raster-opacity-slider"
          style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">Polygon
          transparency:
        </label>
        <input type="range" id="raster-opacity-slider" class="model_sliders" min="0" max="1" step="0.01" value="1">
      </div>

      <div style="display: flex; align-items: center; margin-bottom: 1vh;">
        <span id="polygon-visibility-value"
          style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
        </span>
        <button id="toggle-polygon-visibility" class="toolbar-column-btns"
          style="color: white; text-shadow: 0 0 0.5vh black;">Show polygons:
        </button>
        <span id="polygon-visibility-value2"
          style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
        </span>
      </div>

      <div style="display: flex; align-items: center; margin-bottom: 1vh;">
        <span id="marker-visibility-value"
          style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
        </span>
        <button id="toggle-marker-visibility" class="toolbar-column-btns"
          style="color: white; text-shadow: 0 0 0.5vh black;">Show markers
        </button>
        <span id="marker-visibility-value2"
          style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
        </span>
      </div>

      <div style="display: flex; align-items: center; margin-bottom: 1vh;">
        <span id="3d-model-visibility-value"
          style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
        </span>
        <button id="toggle-3d-model-visibility" class="toolbar-column-btns"
          style="color: white; text-shadow: 0 0 0.5vh black;">Show 3D models
        </button>
        <span id="3d-model-visibility-value2"
          style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
        </span>
      </div>

      <div style="display: flex; align-items: center; margin-bottom: 1vh;">
        <span id="updates-value"
          style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
        </span>
        <button id="toggle-updates" class="toolbar-column-btns"
          style="color: white; text-shadow: 0 0 0.5vh black;">model updates
        </button>
        <span id="updates-value2"
          style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On
        </span>
      </div>

      <div style="display: flex; align-items: center; margin-bottom: 1vh;">
        <button id="update-map-layer-btn" class="toolbar-column-btns"
          style="color: white; text-shadow: 0 0 0.5vh black;">Update Map
        </button>
      </div>

    </div>
  </div>

  <div id="model-column" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
    <div id="model-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

      <input type="text" class="toolbar-column" id="object-input" placeholder="Enter URL" style="text-align: center;"
        onclick="event.stopPropagation();" />
      <button id="buttonforobject" class="toolbar-column-btns"
        style="text-shadow: 0 0 0.5vh black; margin-top: 1vh;">Change object
      </button>

      <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh; padding-top: 1vh;">
        <label for="rotation-x" class="toolbar-column">Rotation X:
        </label>
        <input type="range" class="model_sliders" id="rotation-x" min="0" max="360" value="0" />
        <input type="number" class="toolbar-column" style="text-align: center;" id="rotation-x-value" value="0"
          onchange="document.getElementById('rotation-x').value = this.value;" />
      </div>

      <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
        <label for="rotation-y" class="toolbar-column">Rotation Y:
        </label>
        <input type="range" class="model_sliders" id="rotation-y" min="0" max="360" value="0" />
        <input type="number" class="toolbar-column" style="text-align: center;" id="rotation-y-value" value="0"
          onchange="document.getElementById('rotation-y').value = this.value;" />
      </div>

      <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
        <label for="rotation-z" class="toolbar-column">Rotation Z:
        </label>
        <input type="range" class="model_sliders" id="rotation-z" min="0" max="360" value="0" />
        <input type="number" class="toolbar-column" style="text-align: center;" id="rotation-z-value" value="0"
          onchange="document.getElementById('rotation-z').value = this.value;" />
      </div>

      <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
        <label for="position-x" class="toolbar-column">Position X:
        </label>
        <input type="range" class="model_sliders" id="position-x" min="-100" max="100" step="0.1" value="0" />
        <input type="number" class="toolbar-column" style="text-align: center;" id="position-x-value" value="0"
          onchange="document.getElementById('position-x').value = this.value;" />
      </div>

      <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
        <label for="position-y" class="toolbar-column">Position Y:
        </label>
        <input type="range" class="model_sliders" id="position-y" min="-100" max="100" step="0.1" value="0" />
        <input type="number" class="toolbar-column" style="text-align: center;" id="position-y-value" value="0"
          onchange="document.getElementById('position-y').value = this.value;" />
      </div>

      <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
        <label for="position-z" class="toolbar-column">Position Z:
        </label>
        <input type="range" class="model_sliders" id="position-z" min="-100" max="100" step="0.1" value="0" />
        <input type="number" class="toolbar-column" style="text-align: center;" id="position-z-value" value="0"
          onchange="document.getElementById('position-z').value = this.value;" />
      </div>

      <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
        <label for="scale-factor" class="toolbar-column">Scale Factor:
        </label>
        <input type="range" class="model_sliders" id="scale-factor" step="0.000001" value="1" />
        <input type="number" class="toolbar-column" style="text-align: center;" id="scale-factor-value" value="1"
          onchange="document.getElementById('scale-factor').value = this.value;" />
      </div>

    </div>
  </div>

  <div id="model-column-save"
    style="position: fixed; bottom: 2.5vh; left: 0; width: 100vw; z-index: 1002; max-height: 50vh; overflow-y: auto;">
    <div id="model-column-container-save" class="yourfovcontainer" style="display: none; flex-direction: column;"
      onclick="event.stopPropagation();">

      <div id="savesettings" class="toolbar-column-btns"
        style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save settings
      </div>

    </div>
  </div>


  <div id="crosshair-column"
    style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
    <div id="crosshair-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

      <div>
        <label style="font-size: 1.5vh;">Crosshair Color:</label>
        <input type="color" id="crosshair-color" class="yourfov" value="#000000">
      </div>

      <div style="display: flex; align-items: center; padding-bottom: 1vh;">
        <label for="crosshair-before-after" class="yourfov">Length:
        </label>
        <input type="range" class="model_sliders" id="crosshair-before-after" min="0" max="100" value="20" />
        <input type="number" id="crosshair-before-after-value" class="yourfov" value="20"
          onchange="document.getElementById('crosshair-before-after').value = this.value;" />
      </div>

      <div style="display: flex; align-items: center; padding-bottom: 1vh;">
        <label for="crosshair-after-before" class="yourfov">Thickness:
        </label>
        <input type="range" class="model_sliders" id="crosshair-after-before" min="0" max="10" value="2" />
        <input type="number" id="crosshair-after-before-value" class="yourfov" value="2"
          onchange="document.getElementById('crosshair-after-before').value = this.value;" />
      </div>

    </div>
  </div>

  <div id="crosshair-column-save"
    style="position: fixed; bottom: 2.5vh; left: 0; width: 100vw; z-index: 1002; max-height: 50vh; overflow-y: auto;">
    <div id="crosshair-column-container-save" class="yourfovcontainer" style="display: none; flex-direction: column;"
      onclick="event.stopPropagation();">

      <div id="savecrosshair" class="toolbar-column-btns"
        style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save settings
      </div>

    </div>
  </div>


  <div id="popup-column-2" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
    <div id="popup-column-container-2" class="yourfovcontainer" onclick="event.stopPropagation();">

      <div style="top:10vh">
        <div style="display: flex; align-items: center; padding-bottom: 1vh;">
          <div id="popup-column-2-border" class="toolbar-column-btns"
            style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Border
          </div>
          <div id="popup-column-2-number" class="toolbar-column-btns"
            style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh; margin-left: 1vw;">Number
          </div>
          <div id="popup-column-2-close" class="toolbar-column-btns"
            style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh; margin-left: 1vw;">Close
          </div>
          <div id="popup-column-2-accid" class="toolbar-column-btns"
            style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh; margin-left: 1vw;">AccID
          </div>
        </div>
        <div style="display: flex; align-items: center; padding-bottom: 1vh;">
          <div id="popup-column-2-username" class="toolbar-column-btns"
            style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Username
          </div>
          <div id="popup-column-2-titles" class="toolbar-column-btns"
            style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh; margin-left: 1vw;">Title
          </div>
          <div id="popup-column-2-text" class="toolbar-column-btns"
            style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh; margin-left: 1vw;">Text
          </div>
          <div id="popup-column-2-font" class="toolbar-column-btns"
            style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh; margin-left: 1vw;">Font
          </div>
        </div>
      </div>

    </div>
  </div>

  <div id="popup-column-3"
    style="position: fixed; bottom: 2.5vh; left: 0; width: 100vw; z-index: 1002; max-height: 50vh; overflow-y: auto;">
    <div id="popup-column-container-3" class="yourfovcontainer" style="display: none; flex-direction: column;"
      onclick="event.stopPropagation();">

      <div id="popup-column-3-border" style="display: none; align-items: center;">
        <label style="font-size: 1.5vh;">Border:</label>
        <input type="color" id="color-picker-popup-border" class="yourfov" value="#ffffff">
      </div>

      <div id="popup-column-3-number" style="display: none; align-items: center;">
        <label style="font-size: 1.5vh;">Number:</label>
        <input type="color" id="color-picker-popup-number" class="yourfov" value="#ffffff">
      </div>

      <div id="popup-column-3-close" style="display: none; align-items: center;">
        <label style="font-size: 1.5vh;">Close:</label>
        <input type="color" id="color-picker-popup-close" class="yourfov" value="#ffffff">
      </div>

      <div id="popup-column-3-accid" style="display: none; align-items: center;">
        <label style="font-size: 1.5vh;">AccID:</label>
        <input type="color" id="color-picker-popup-accid" class="yourfov" value="#800080">
      </div>

      <div id="popup-column-3-username" style="display: none; align-items: center;">
        <label style="font-size: 1.5vh;">Username:</label>
        <input type="color" id="color-picker-popup-username" class="yourfov" value="#ffffff">
      </div>

      <div id="popup-column-3-titles" style="display: none; align-items: center;">
        <label style="font-size: 1.5vh;">Title:</label>
        <input type="color" id="color-picker-popup-titles" class="yourfov" value="#ffffff">
      </div>

      <div id="popup-column-3-text" style="display: none; align-items: center;">
        <label style="font-size: 1.5vh;">Text:</label>
        <input type="color" id="color-picker-popup-text" class="yourfov" value="#ffffff">
      </div>

      <div id="popup-column-3-font" style="display: none; align-items: center;">
        <label style="font-size: 1.5vh;">Font:</label>
        <div style="display: flex; align-items: center;">
          <input type="number" id="popup-font-size" class="yourfov" style="margin-left: 1vw;" value='2' max="255" />
        </div>
      </div>

      <div></div>
      <div id="savepopup3" class="toolbar-column-btns"
        style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save popup
      </div>

    </div>
  </div>

  <div id="main-button-column"
    style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
    <div id="main-button-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

      <div>
        <label style="font-size: 1.5vh;">Connect/Disconnect Button Color:</label>
        <input type="color" id="disconnect-button-color" class="yourfov" value="#ffc107">
      </div>

      <div>
        <label style="font-size: 1.5vh;">Main Buttons Color:</label>
        <input type="color" id="main-button-color" class="yourfov" value="#007bff">
      </div>

    </div>
  </div>

  <div id="main-button-column-save"
    style="position: fixed; bottom: 2.5vh; left: 0; width: 100vw; z-index: 1002; max-height: 50vh; overflow-y: auto;">
    <div id="main-button-column-container-save" class="yourfovcontainer" style="display: none; flex-direction: column;"
      onclick="event.stopPropagation();">

      <div id="save-main-button" class="toolbar-column-btns"
        style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save Settings
      </div>

    </div>
  </div>

  <div id="marker-options-column"
    style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
    <div id="marker-options-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

      <div style="display: flex; align-items: center; padding-bottom: 1vh;">
        <label for="color-green" class="yourfov">Size:
        </label>
        <input type="number" id="Marker-Size" class="yourfov" style="margin-left: 1vw;" max="255" value="5" />
      </div>

    </div>
  </div>

  <div id="marker-column-save"
    style="position: fixed; bottom: 2.5vh; left: 0; width: 100vw; z-index: 1002; max-height: 50vh; overflow-y: auto;">
    <div id="marker-column-container-save" class="yourfovcontainer" style="display: none; flex-direction: column;"
      onclick="event.stopPropagation();">

      <div id="save-marker-settings" class="toolbar-column-btns"
        style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save Settings
      </div>

    </div>
  </div>

  <div id="button-input-column"
    style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
    <div id="button-input-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

      <div style="display: flex; align-items: center; padding-bottom: 1vh;">
        <label for="color-green" class="yourfov">Font Size:
        </label>
        <input type="number" id="font-for-button-input" class="yourfov" style="margin-left: 1vw;" max="255"
          placeholder="Size" value="2" />
      </div>

      <div style="display: flex; align-items: center; padding-bottom: 1vh;">
        <label for="color-green" class="yourfov">Transparency:
        </label>
        <input type="number" id="transparency-button-input" class="yourfov" style="margin-left: 1vw;" min='0.5'
          step="0.01" max="1" placeholder="Opacity" value="1" />
      </div>

      <div>
        <label style="font-size: 1.5vh;">Input Border Color:</label>
        <input type="color" id="input-border-color" class="yourfov" value="#007bff">
      </div>

      <div>
        <label style="font-size: 1.5vh;">Input Font Color:</label>
        <input type="color" id="input-font-color" class="yourfov" value="#ffffff">
      </div>

      <div>
        <label style="font-size: 1.5vh;">Button Border Color:</label>
        <input type="color" id="button-border-color" class="yourfov" value="#007bff">
      </div>

      <div>
        <label style="font-size: 1.5vh;">Button Font Color:</label>
        <input type="color" id="button-font-color" class="yourfov" value="#ffffff">
      </div>

      <div>
        <label style="font-size: 1.5vh;">OnHover Button Color:</label>
        <input type="color" id="onhover-button-color" class="yourfov" value="#007bff">
      </div>

    </div>
  </div>

  <div id="button-input-column-save"
    style="position: fixed; bottom: 2.5vh; left: 0; width: 100vw; z-index: 1002; max-height: 50vh; overflow-y: auto;">
    <div id="button-input-column-container-save" class="yourfovcontainer" style="display: none; flex-direction: column;"
      onclick="event.stopPropagation();">

      <div id="save-button-button-input" class="toolbar-column-btns"
        style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save Settings
      </div>

    </div>
  </div>


  <div id="topic-chat-column"
    style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
    <div id="topic-chat-column-container" class="yourfovcontainer" onclick="event.stopPropagation();">

      <div>
        <label style="font-size: 1.5vh;">AccID Color:</label>
        <input type="color" id="accid-topic-chat-color" class="yourfov" value="#800080">
      </div>

      <div>
        <label style="font-size: 1.5vh;">Username Color:</label>
        <input type="color" id="username-topic-chat-color" class="yourfov" value="#ffffff">
      </div>

      <div>
        <label style="font-size: 1.5vh;">Text Color:</label>
        <input type="color" id="text-topic-chat-color" class="yourfov" value="#ffffff">
      </div>

      <div>
        <label style="font-size: 1.5vh;">Text Container Color:</label>
        <input type="color" id="text-container-topic-chat-color" class="yourfov" value="#ffffff">
      </div>

    </div>
  </div>

  <div id="topic-chat-save"
    style="position: fixed; bottom: 2.5vh; left: 0; width: 100vw; z-index: 1002; max-height: 50vh; overflow-y: auto;">
    <div id="topic-chat-container-save" class="yourfovcontainer" style="display: none; flex-direction: column;"
      onclick="event.stopPropagation();">

      <div id="save-topic-chat-settings" class="toolbar-column-btns"
        style="text-shadow: 0 0 0.5vh black; text-align: center; padding-top: 1vh;">Save Settings
      </div>

    </div>
  </div>

</body>

<script>


  const APP_METADATA = {
    name: "Meritocracy",
    description: "A Hashinals application using WalletConnect via Kiloscribe.com",
    url: "https://kiloscribe.com/",
    icons: ["https://kiloscribe.com/api/inscription-cdn/0.0.4819119"],
  };

  const PROJECT_ID = "fdd65bec25e85908fecf7561fe42b41f";

  let globalAccountId; // Declare an external variable to hold the accountId

  class Loader {
    constructor(totalCheckpoints) {
      this.totalCheckpoints = totalCheckpoints;
      this.currentCheckpoint = 0;
      this.progressBar = document.getElementById('progressBar');
      this.percentageText = document.getElementById('percentageText');
      this.loaderContainer = document.getElementById('loaderContainer');
      this.mainContent = document.getElementById('mainContent');
    }

    updateProgress() {
      this.currentCheckpoint++;
      const progress = Math.round((this.currentCheckpoint / this.totalCheckpoints) * 100);
      this.progressBar.style.width = progress + '%';
      this.percentageText.textContent = progress + '%';

      if (this.currentCheckpoint >= this.totalCheckpoints) {
        setTimeout(() => {
          this.loaderContainer.classList.add('hidden');
        }, 500); // Small delay for smooth transition
      }
    }
  }

  const loader = new Loader(10); // Set to number of checkpoints you want


  // Simulate your code with checkpoints
  window.onload = () => {
    loader.updateProgress();





    window.HCSReady = async function () {

      const sdk = window.HashinalsWalletConnectSDK;
      const maplibregl = window.maplibregl;
      const Supercluster = window.Supercluster;
      const THREE = window.THREE;
      const scene = new THREE.Scene();


      async function ensureDracoLoaderReady() {
        for (let attempt = 1; attempt <= 5; attempt++) {
          if (typeof THREE !== 'undefined' && typeof THREE.DRACOLoader !== 'undefined') {
            try {
              new THREE.DRACOLoader();
              return true;
            } catch (e) {
            }
          }
          await new Promise(resolve => setTimeout(resolve, 200));
        }
      }

      await ensureDracoLoaderReady();

      // Global variables
      let initialTopicId = ''; // Will be set by extractTopicId
      const defaultTopicId = '0.0.9609912';

      // Async function to extract topic ID from URL
      async function extractTopicId() {
        const path = window.location.pathname;
        const userInput = path && path !== '/' ? path.slice(1) : '';

        let topicId;
        if (userInput.startsWith('0.0.')) {
          topicId = userInput; // Use the URL path directly if it starts with '0.0.'
        } else {
          // Search for userInput in loadedDomains
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic; // Use topic from lastMessage
          } else {
            topicId = defaultTopicId; // Fallback to defaultTopicId if no match
          }
        }

        const loadColumn = document.getElementById("load-column");
        loadColumn.style.display = "block";
        const inputarea = document.getElementById("input-field");
        inputarea.value = '';
        inputarea.value = topicId;
        adjustTextareaHeight(inputarea);

        initialTopicId = topicId; // Set global variable
        return initialTopicId; // Return for use in async flows
      }


      // Define SelfContainedDRACOLoader inside HCSReady with explicit prototype binding
      function SelfContainedDRACOLoader() {


        // Create a base instance and extend it
        const baseLoader = Object.create(THREE.DRACOLoader.prototype);
        THREE.DRACOLoader.call(baseLoader);

        for (let prop in baseLoader) {
          if (baseLoader.hasOwnProperty(prop)) {
            this[prop] = baseLoader[prop];
            console.log(`Copied property ${prop} to this:`, this[prop]);
          }
        }

        this.decoderType = 'wasm';
        this.wasmBinary = null;
        this.jsWrapperBlob = null;
        this.jsWrapperUrl = null;
        this.jsDecoderBlob = null;
        this.jsDecoderUrl = null;

        this.initBlobs();
      }

      // Ensure prototype is correctly set
      if (!THREE.DRACOLoader.prototype) {
        throw new Error('THREE.DRACOLoader prototype is undefined.');
      }

      SelfContainedDRACOLoader.prototype = Object.create(THREE.DRACOLoader.prototype);
      SelfContainedDRACOLoader.prototype.constructor = SelfContainedDRACOLoader;

      SelfContainedDRACOLoader.prototype.initBlobs = function () {
        console.log('initBlobs method called on:', this);

        if (window.DRACO_WASM_BASE64) {
          const binaryString = atob(window.DRACO_WASM_BASE64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
          this.wasmBinary = bytes.buffer;
          console.log('WASM binary set, length:', bytes.length);
        }

        if (window.DRACO_JS_BASE64) {
          const jsText = atob(window.DRACO_JS_BASE64.split(',')[1]);
          this.jsWrapperBlob = new Blob([jsText], { type: 'application/javascript' });
          this.jsWrapperUrl = URL.createObjectURL(this.jsWrapperBlob);
          this.jsDecoderBlob = this.jsWrapperBlob;
          this.jsDecoderUrl = this.jsWrapperUrl;
          console.log('JS wrapper URL created:', this.jsWrapperUrl);
        } else {
          this.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
        }
      };

      SelfContainedDRACOLoader.prototype.setDecoderPath = function (path) {
        console.log('setDecoderPath called with path:', path);
        this.decoderPath = path;
      };

      SelfContainedDRACOLoader.prototype.getDecoderModule = function () {
        console.log('getDecoderModule called on:', this);
        if (this.decoderModule) {
          console.log('Returning cached decoder module');
          return Promise.resolve(this.decoderModule);
        }

        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = this.decoderType === 'wasm' ? this.jsWrapperUrl : this.jsDecoderUrl || `${this.decoderPath}draco_wasm_wrapper.js`;
          console.log('Loading decoder script from:', script.src);
          script.onload = () => {
            console.log('Decoder script loaded');
            if (typeof DracoDecoderModule !== 'undefined') {
              const moduleConfig = this.decoderType === 'wasm' ? { wasmBinary: this.wasmBinary } : {};
              DracoDecoderModule(moduleConfig).then((module) => {
                this.decoderModule = module;
                console.log('Decoder module initialized:', module);
                resolve(module);
              }).catch(reject);
            } else {
              console.error('DracoDecoderModule not exposed');
              reject(new Error('DracoDecoderModule not exposed'));
            }
          };
          script.onerror = (e) => {
            console.error('Failed to load decoder script:', e);
            reject(e);
          };
          document.head.appendChild(script);
        });
      };

      SelfContainedDRACOLoader.prototype.dispose = function () {
        console.log('dispose called on:', this);
        if (typeof THREE.DRACOLoader.prototype.dispose === 'function') {
          THREE.DRACOLoader.prototype.dispose.call(this);
          console.log('Base dispose called');
        }
        if (this.jsWrapperUrl) {
          URL.revokeObjectURL(this.jsWrapperUrl);
          console.log('Revoked jsWrapperUrl');
        }
        if (this.jsDecoderUrl && this.jsDecoderUrl !== this.jsWrapperUrl) {
          URL.revokeObjectURL(this.jsDecoderUrl);
          console.log('Revoked jsDecoderUrl');
        }
      };

      // Expose globally, but only if not already defined
      if (!window.SelfContainedDRACOLoader) {
        window.SelfContainedDRACOLoader = SelfContainedDRACOLoader;
      }

      let dracoLoader;
      try {
        dracoLoader = new SelfContainedDRACOLoader();
      } catch (e) {
        dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
      }

      const ufoLoader = new THREE.GLTFLoader();
      ufoLoader.setDRACOLoader(dracoLoader);
      let currentUfoModel = null;
      let timeoutForToolbarLoad = true;

      async function updateAccountInfo(accountId, balance) {
        document.getElementById("connect-wallet-btn").style.display = "block";
        document.getElementById("disconnect-wallet-btn").style.display = "none";
        document.getElementById("account-id").textContent = ``;
        document.getElementById("crosshair").style.display = "block";
        document.getElementById("connect-wallet-btn").addEventListener("click", () => {
          document.getElementById("crosshair").style.display = "none";
          setTimeout(() => {
            document.getElementById("crosshair").style.display = "block";
          }, 15000);
        });
        connectWallet();
        extractTopicId();
        handleAllMessages();
        const toolbarLoad = document.getElementById("toolbar-load");
        toolbarLoad.replaceWith(toolbarLoad.cloneNode(true));
        const newToolbarLoad = document.getElementById("toolbar-load");
        newToolbarLoad.addEventListener("click", debounce(async () => {
          await handleAllMessages();
        }, 500));
        return;
      };

      async function loadProfile(accountId, balance) {
        document.getElementById("account-id").textContent = `Acc: ${accountId}`;
        document.getElementById("connect-wallet-btn").style.display = "none";
        document.getElementById("disconnect-wallet-btn").style.display = "block";
        document.getElementById("crosshair").style.display = "block";
        globalAccountId = accountId;
        const profileObjectUrl = await loadProfileObject();
        const profileObjectCrosshair = await loadProfileCrosshair();
        const profileObjectSettings = await loadProfileSettings();
        const profileObjectPopup = await loadProfilePopup();
        const profileMainButton = await loadMainButtonSettings();
        const profileMarker = await loadMarkerSettings();
        const profileButtonInput = await loadButtonInputSettings();
        const profileTopicChat = await loadTopicChatSettings();
        const modelUrl = profileObjectSettings.length > 0 && profileObjectSettings[0].urls && profileObjectSettings[0].urls.length > 0
          ? profileObjectSettings[0].urls[0]
          : defaultModelUrl;
        debounce(async () => {
          extractTopicId();
          await loadUfoModel(modelUrl); // Load the model using the determined URL
          confirmNFTFunction(accountId);
        }, 1000);
        const toolbarLoad = document.getElementById("toolbar-load");
        toolbarLoad.replaceWith(toolbarLoad.cloneNode(true));
        const newToolbarLoad = document.getElementById("toolbar-load");
        newToolbarLoad.addEventListener("click", debounce(async () => {
          await confirmNFTFunction(accountId);
        }, 500));
        await extractAccountId();
      };

      loader.updateProgress();


      const sodium = window.sodium;

      function hexToBytes(hex) {
        const bytes = new Uint8Array(hex.length / 2);
        for (let i = 0; i < hex.length; i += 2) {
          bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
        }
        return bytes;
      }

      function parsePublicKey(derHex) {
        const derBytes = hexToBytes(derHex);
        return derBytes.slice(derBytes.length - 32);
      }

      function parsePrivateKey(derHex) {
        const derBytes = hexToBytes(derHex);
        const seed = derBytes.slice(derBytes.length - 32);
        const keyPair = sodium.crypto_sign_seed_keypair(seed);
        return keyPair.privateKey;
      }

      async function encryptMessage(message, recipientPublicKey) {
        await sodium.ready;
        const recipientX25519Public = sodium.crypto_sign_ed25519_pk_to_curve25519(recipientPublicKey);
        const ciphertext = sodium.crypto_box_seal(message, recipientX25519Public);

        return {
          ciphertext: sodium.to_base64(ciphertext)
        };
      }

      async function decryptMessage(encryptedData, recipientPrivateKey) {
        await sodium.ready;
        const recipientPublicKey = recipientPrivateKey.slice(32);
        const recipientX25519Private = sodium.crypto_sign_ed25519_sk_to_curve25519(recipientPrivateKey);
        const recipientX25519Public = sodium.crypto_sign_ed25519_pk_to_curve25519(recipientPublicKey);

        const ciphertext = sodium.from_base64(encryptedData.ciphertext);
        const decrypted = sodium.crypto_box_seal_open(ciphertext, recipientX25519Public, recipientX25519Private);

        return sodium.to_string(decrypted);
      }

      async function a() {
        try {
          const publicKeyHex = '302a300506032b65700321009eac2996306ae12c68a876a88cbea209e69d60ffddc3386738157bd526d2fd1d';
          const privateKeyHex = '302e020100300506032b65700422042058110c84febccc97ec4eb34995690a1b9f20f7e743e45cdf1bbea6b2420a59fc';

          const publicKey = parsePublicKey(publicKeyHex);
          const privateKey = parsePrivateKey(privateKeyHex);

          const message = 'Secret message!';

          const encrypted = await encryptMessage(message, publicKey);
          console.log('Encrypted:', encrypted);

          const decrypted = await decryptMessage(encrypted, privateKey);
          console.log('Decrypted:', decrypted);
        } catch (error) {
          console.error('Error:', error.message);
        }
      }

      a();


      document.getElementById("post-msg-encrypted-chat").addEventListener("click", async () => {
        try {
          let userInput = document.getElementById("encrypted-chat-topic-id").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          const PublicKey = parsePublicKey(document.getElementById("encrypted-chat-public-key").value);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput;
          }

          const message = document.getElementById("user-write-message-encrypted-chat").value;
          const encryptedMessage = await encryptMessage(message, PublicKey);



          const meesageobject = {
            encryptedMessage: encryptedMessage
          };

          const newMeesage = JSON.stringify(meesageobject);
          console.log('New Meesage:', newMeesage);
          const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, newMeesage);
          console.log('Reciept:', reciept);
        } catch (error) {
          console.error('Error:', error.message);
        }
      });


      document.getElementById("load-msgs-from-encrypted-chat").addEventListener("click", async () => {
        try {
          let userInput = document.getElementById("encrypted-chat-topic-id").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          const PrivateKey = parsePrivateKey(document.getElementById("encrypted-chat-private-key").value);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput;
          }


          const messagesContainer = document.getElementById("messages-from-encrypted-chat");
          const topicSpinnerChat = `
    <div style="display: flex; justify-content: left; align-items: left; height: 100%;  padding-top: 1vh; padding-bottom: 1vh;">
      <div id="topicspinnerchat"></div>
       <span style="margin-left: 1vw;">Loading messages from ${topicId}</span>
      </div>`;
          messagesContainer.innerHTML = topicSpinnerChat;
          adjustTextareaHeight(messagesContainer);

          try {
            const topicInfo = await sdk.getTopicInfo(topicId);
            const topicAdmin = [];
            const memo = topicInfo.memo;

            // Split the memo by commas
            const parts = memo.split(',');

            // Iterate over each part
            parts.forEach(part => {
              // Check if the part starts with "0.0."
              if (part.startsWith("0.0.")) {
                // Add it to the topicAdmin array
                topicAdmin.push(part);
              }
            });
          } catch (error) {
            const messagesContainer = document.getElementById("messages-from-encrypted-chat");
            const topicSpinnerChat = `
      <div style="display: flex; justify-content: left; align-items: left; height: 100%;  padding-top: 1vh; padding-bottom: 1vh;">
        <span style="margin-left: 1vw;">Invalid Topic ID</span>
      </div>`;
            messagesContainer.innerHTML = topicSpinnerChat;
            adjustTextareaHeight(messagesContainer);
            console.error("Error getting topic info:", error);
            return;
          }

          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          if (!result || !Array.isArray(result.messages)) {
            console.log("No messages found or result is not an array.");
            return [];
          }

          const profilePictures = await loadProfilePicture(); // Load profile pictures
          const usernames = await loadUsername(); // Load usernames
          const click2url = await loadCLICK2URL();
          const topic2pic = await loadTOPIC2PIC();


          let allMessages = ''; // Initialize an empty string to hold all messages

          let previousPayer = null; // Track the previous payer

          const topicActions = new Map();

          const loadedNFTsForTopicChat = [];



          for (let index = 0; index < result.messages.length; index++) {
            const message = result.messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
              const timestamp = message.timestamp || Date.now(); // Use message timestamp or current time

              if (parsedMessage.addTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const nfts = parsedMessage.addTopicChatNFT.split(',').map(nft => nft.trim());
                nfts.forEach(nft => {
                  if (nft.startsWith("0.0.") && !loadedNFTsForTopicChat.includes(nft)) { // Check if NFT starts with "0.0."
                    loadedNFTsForTopicChat.push(nft);
                  }
                });
              }

              if (parsedMessage.removeTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const nft = parsedMessage.removeTopicChatNFT.trim();
                if (nft.startsWith("0.0.")) { // Check if NFT starts with "0.0."
                  const index = loadedNFTsForTopicChat.indexOf(nft);
                  if (index !== -1) {
                    loadedNFTsForTopicChat.splice(index, 1);
                  }
                }
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }


          if (loadedNFTsForTopicChat.length > 0) {
            console.log("loadedNFTsForTopicChat", loadedNFTsForTopicChat);
          }

          // Process messages
          for (let index = 0; index < result.messages.length; index++) {
            const message = result.messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }

              const payer = parsedMessage.payer || 'Unknown';

              // Check if the payer owns any NFT from loadedNFTsForTopicChat
              let payerHasNFT = false;
              if (loadedNFTsForTopicChat.length > 0) {
                for (const item of loadedNFTsForTopicChat) {
                  const checkIfUserHasNFT = await sdk.getAccountNFTs(payer, item);
                  if (checkIfUserHasNFT.length > 0) {
                    payerHasNFT = true;
                    break;
                  }
                }
              } else {
                payerHasNFT = true; // If no NFTs to check, allow all messages
              }

              if (payerHasNFT && parsedMessage.encryptedMessage) {
                const userMessage = parsedMessage.encryptedMessage;

                let decryptedMessage = null;
                try {
                  decryptedMessage = await decryptMessage(userMessage, PrivateKey);
                } catch (error) {
                  const messagesContainer = document.getElementById("messages-from-encrypted-chat");
                  const topicSpinnerChat = `
        <div style="display: flex; justify-content: left; align-items: left; height: 100%;  padding-top: 1vh; padding-bottom: 1vh;">
          <span style="margin-left: 1vw;">Invalid Private Key</span>
        </div>`;
                  messagesContainer.innerHTML = topicSpinnerChat;
                  adjustTextareaHeight(messagesContainer);
                  console.error("Error decrypting message:", error);
                  continue;
                }

                const payerImage = profilePictures[payer]?.url || 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';

                // Function to validate URL
                function isValidUrl(string) {
                  try {
                    new URL(string);
                    return true;
                  } catch (_) {
                    return false;
                  }
                }

                // Check if payerImage is valid, if not use fallback
                const validPayerImage = isValidUrl(payerImage) ? payerImage : 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';


                const timestamp = new Date(parsedMessage.created)
                  .toLocaleString('en-US', {
                    hour12: false,
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                  })
                  .replace(/[/]/g, '') // Remove slashes
                  .replace(/[:]/g, ''); // Remove colons

                const payerInfo = message.payer ? `${message.payer}` : 'Anonymous';
                const username = message.payer && usernames[message.payer] ?
                  ` ${usernames[message.payer].username}` :
                  '';

                const click2link = message.payer && click2url[message.payer] ?
                  ` ${click2url[message.payer].click2url}` :
                  '';

                const displayHeader =
                  `<a href="https://explore.hashpack.app/${payerInfo}" target="_blank" style="color: ${accidTopicChatColor}; text-decoration: none;">${payerInfo}</a>
${click2link ? `<a href="${click2link}" target="_blank" style="color: ${usernameTopicChatColor};
text-decoration: none;">${username}</a>` : `<span style="color: ${usernameTopicChatColor};">${username}</span>`}`;

                storedMessages.push(parsedMessage);

                if (payer !== previousPayer) {
                  allMessages += `<div style="display: flex; align-items: center; margin-top: 0.1em;">
    <img src="${validPayerImage}" alt="Profile photo"
    style="width: 2em; height: 2em; margin-right: 0.5em; border-radius: 1em; cursor: pointer;"
    onclick="loadTOPIC4PIC('${message.payer}');">
                    <div style="display: flex; flex-direction: column; justify-content: center;">
                      <div>${displayHeader}</div>
                      <span style="font-size: 0.8em; color: gray;">${timestamp}</span>
                      <div style="color: ${textTopicChatColor};">${decryptedMessage}</div>
                    </div>
                  </div><br>`;
                } else {
                  allMessages += `<div style="display: flex; align-items: center; margin-left: 2.5em; margin-top: -1.25em;">
                    <div style="color: ${textTopicChatColor};">${decryptedMessage}</div>
                  </div><br>`;
                }
                previousPayer = payer; // Update the previous payer
              } else {
                console.warn(`Message ${index} is missing payer or data.`);
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          const chatContainer = document.getElementById('topic-chat-container');
          let startY, scrollTop;

          chatContainer.addEventListener('touchstart', (e) => {
            startY = e.touches[0].pageY - chatContainer.offsetTop;
            scrollTop = chatContainer.scrollTop;
          });

          chatContainer.addEventListener('touchmove', (e) => {
            const y = e.touches[0].pageY - chatContainer.offsetTop;
            const walk = (y - startY) * 2; // Adjust the multiplier for sensitivity
            chatContainer.scrollTop = scrollTop - walk;
            e.preventDefault(); // Prevent default touch behavior
          });

          messagesContainer.addEventListener('touchstart', (e) => {
            startY = e.touches[0].pageY - messagesContainer.offsetTop;
            scrollTop = messagesContainer.scrollTop;
            e.stopPropagation(); // Stop the event from bubbling up
          });

          messagesContainer.addEventListener('touchmove', (e) => {
            const y = e.touches[0].pageY - messagesContainer.offsetTop;
            const walk = (y - startY) * 2; // Adjust the multiplier for sensitivity
            messagesContainer.scrollTop = scrollTop - walk;
            e.preventDefault(); // Prevent default touch behavior
            e.stopPropagation(); // Stop the event from bubbling up
          });

          messagesContainer.innerHTML = allMessages;

          if (allMessages.length === 0) {
            messagesContainer.innerHTML = 'no messages found';
          }

          adjustTextareaHeight(messagesContainer);

          // Scroll to the bottom of the message container
          messagesContainer.scrollTop = messagesContainer.scrollHeight;

        } catch (error) {
          const messagesContainer = document.getElementById('messages-from-topic-chat');
          messagesContainer.innerHTML =
            `<div style="display: flex; justify-content: left; align-items: left; height: 100%;  padding-top: 1vh; padding-bottom: 1vh;">
       <span style="margin-left: 1vw;">Invalid Topic ID</span>
      </div>`;
          adjustTextareaHeight(messagesContainer);
          console.error("Error setting rules:", error);
        }
      });



      document.getElementById('upload-to-ipfs-button').disabled = true;

      let helia = null;
      let fs = null;

      console.log('initHeliabitswap', window.sodium);

      async function initHelia() {

        try {

          const bootstrapList = [
            '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN',
            '/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',
            '/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ',
            '/dns4/nyc-1.bootstrap.libp2p.io/tcp/443/wss/p2p/QmSoLMeWqB7YGVLJN3pNLQpmmEk35vGrvXL8kT3uNoHbeG',
            '/dns4/ams-1.bootstrap.libp2p.io/tcp/443/wss/p2p/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd',
          ];

          const noise = window.ChainsafeLibp2PNoise?.noise?.();

          const kuboClient = window.KuboRpcClient.create({
            url: 'https://delegated-ipfs.dev/api/v0'
          });

          const libp2pOptions = {
            addresses: {
              listen: [
                '/ip4/0.0.0.0/tcp/0',
                '/ip4/0.0.0.0/tcp/0/ws',
                '/ip4/0.0.0.0/udp/0/webrtc-direct',
                '/ip6/::/tcp/0',
                '/ip6/::/tcp/0/ws',
                '/ip6/::/udp/0/webrtc-direct',
                '/p2p-circuit'
              ],
              announce: [
                '/p2p-circuit/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ'
              ],
            },
            transports: [
              window.Libp2p.webRTC(
                {
                  iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                  ]
                }),
              window.Libp2p.webSockets(),
              window.Libp2p.circuitRelayTransport({ discoverRelays: 10, reservationConcurrency: 5, hop: { enabled: true } })
            ],
            connectionEncryption: noise ? [noise] : [],
            connectionManager: { minConnections: 2, maxConnections: 100 },
            peerDiscovery: [
              window.Libp2p.bootstrap({ list: bootstrapList, interval: 1000 }),
            ],
            services: {
              identify: window.Libp2p.identify(),
              dht: window.Libp2p.kadDHT({
                clientMode: true,
                kBucketSize: 20,
                router: window.Libp2PDelegatedPeerRouting.delegatedPeerRouting(kuboClient),
              }),
              ping: window.Libp2p.ping(),
            },
          };

          helia = await window.Helia.createHelia({ Libp2p: libp2pOptions });
          bitswap = window.HeliaBitswap.createBitswap(helia);

          console.log("bitswap", bitswap);

          fs = window.HeliaUnixfs.unixfs(helia);


          await helia.libp2p.services.dht.start();

          console.log('Helia Peer ID:', helia.libp2p.peerId.toString());

          setInterval(() => {
            const peers = helia.libp2p.getPeers();
            console.groupCollapsed('Number of connected peers:', peers.length);
            console.log('Peers:', peers);
            console.groupEnd();
            console.log('DHT routing table size:', helia.libp2p.services.dht.routingTable?.size || 'N/A');
          }, 5000);

          document.getElementById('upload-to-ipfs-button').disabled = false;
        } catch (error) {
          console.error('Initialization failed:', error);
          document.getElementById('cid-output').textContent = `Initialization failed: ${error.message}`;
        }
      }

      initHelia();

      document.getElementById('upload-to-ipfs-button').addEventListener('click', async () => {
        await upload();
      });

      async function upload() {
        const fileInput = document.getElementById('fileInput');
        const file = fileInput.files[0];
        if (!file) {
          alert('No file selected');
          return;
        }
        if (!fs || !helia) {
          document.getElementById('cid-output').textContent = 'Helia not initialized.';
          return;
        }

        try {
          const fileArrayBuffer = await file.arrayBuffer();
          const fileBytes = new Uint8Array(fileArrayBuffer);
          console.log('File size:', fileBytes.length);

          const cid = await fs.addBytes(fileBytes);
          console.log('Uploaded and pinned locally, CID:', cid.toString());
          document.getElementById('cid-output').textContent = `w8 for it to upload to the network it usually takes few minutes, if this text doesnt change retry after 5 minutes and wait again`;

          adjustTextareaHeight(document.getElementById('cid-output'));

          await helia.pins.add(cid);
          let announced = false;
          const maxRetries = 10;
          let retryCount = 0;
          const baseTimeout = 150000; // 150s

          while (!announced && retryCount < maxRetries) {
            try {
              console.log(`Announcing CID to DHT (attempt ${retryCount + 1}/${maxRetries})`);
              const announcePromise = helia.routing.provide(cid);
              const globalTimeout = new Promise((_, reject) =>
                setTimeout(() => reject(new Error(`DHT provide timed out after ${baseTimeout / 1000}s`)), baseTimeout)
              );
              await Promise.race([announcePromise, globalTimeout]);
              console.log('Announced CID to DHT successfully');
              announced = true;
            } catch (error) {
              console.error(`DHT announcement failed (attempt ${retryCount + 1}):`, error);
              retryCount++;
              if (retryCount < maxRetries) {
                const backoff = Math.pow(2, retryCount) * 5000; // 5s, 10s, 20s
                console.log(`Retrying after ${backoff / 1000}s...`);
                await new Promise(resolve => setTimeout(resolve, backoff));
              }
            }
          }

          if (announced) {
            const multiaddrs = helia.libp2p.getMultiaddrs();
            console.log('Node multiaddresses:', multiaddrs.map(addr => addr.toString()));
            document.getElementById('cid-output').textContent = ``;
            document.getElementById('cid-output').textContent = `successfully uploaded to the network CID: ${cid.toString()}`;
            adjustTextareaHeight(document.getElementById('cid-output'));
          }

          if (maxRetries === retryCount) {
            document.getElementById('cid-output').textContent = `Failed to upload to the network`;
            adjustTextareaHeight(document.getElementById('cid-output'));
          }

        } catch (error) {
          console.error('Error:', error);
          document.getElementById('cid-output').textContent = `Failed: ${error.message}`;
        }
      }

      document.getElementById('fetch-from-ipfs-button').addEventListener('click', async () => {
        await fetchContent();
      });

      console.log('fetchContentaaaaaaaaaaaaaaaaaa', window.Helia.createHelia());
      async function fetchContent() {
        const cidInput = document.getElementById('cid-input').value.trim();
        if (!cidInput) {
          alert('No CID provided');
          return;
        }

        if (!fs || !helia) {
          document.getElementById('cid-output').textContent = 'Helia not initialized.';
          return;
        }

        let cid;
        try {
          cid = window.Multiformats.CID.parse(cidInput);
        } catch (error) {
          document.getElementById('cid-output').textContent = `Invalid CID: ${error.message}`;
          return;
        }

        const contentType = document.getElementById('content-type')?.value || 'image';

        try {

          let chunks = [];

          try {

            console.log(`Looking for providers of CID: ${cid}`);

            const providers = [];

            for await (const provider of helia.libp2p.services.dht.findProviders(cid)) {

              console.log('provider', provider);

              if (provider && provider.peer) {
                providers.push(provider);
                console.log(`Found provider: ${provider.peer}`);
              } else {
                console.warn('Skipping invalid provider:', provider);
              }
            }

            // Check if any providers were found
            if (providers.length === 0) {
              document.getElementById('cid-output').textContent = 'No providers found for the given CID';
              return;
            }

            // Retrieve content from the first provider
            console.log('Retrieving content...');
            const content = [];
            for await (const chunk of fs.cat(cid)) {
              content.push(chunk);
            }

            // Combine chunks into a single Buffer
            const data = Buffer.concat(content);
            const text = data.toString('utf8'); // Assuming the content is text
            console.log('Retrieved content:', text);

            const gateways = [
              'https://dweb.link/ipfs/',
              'https://ipfs.io/ipfs/',
              'https://cloudflare-ipfs.com/ipfs/',
            ];
            for (const gateway of gateways) {
              try {
                const gatewayUrl = `${gateway}${cid.toString()}`;
                console.log(`Attempting to fetch from: ${gatewayUrl}`);
                const response = await window.HeliaVerifiedFetch.verifiedFetch(gatewayUrl, {
                  timeout: 30000,
                });
                if (!response.ok) {
                  throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = new Uint8Array(await response.arrayBuffer());
                chunks = [data];
                console.log(`Successfully fetched from ${gateway}`);
                break;
              } catch (gatewayError) {
                console.warn(`Gateway ${gateway} failed: ${gatewayError.message}`);
                if (gateway === gateways[gateways.length - 1]) {
                  throw new Error(`All gateways failed: ${gateways.join(', ')}`);
                }
              }
            }


            if (chunks.length === 0) {
              throw new Error('Failed to fetch CID from any provider or gateway');
            }

          } catch (error) {
            console.error('Fetch error:', error);
            document.getElementById('cid-output').textContent = `Fetch failed: ${error.message}`;
            adjustTextareaHeight(document.getElementById('cid-output'));
          }

          console.log('chunks', chunks);


          // Step 2: Process and display the fetched content
          const data = new Uint8Array(chunks.reduce((acc, chunk) => acc.concat([...chunk]), []));
          console.log('Fetched file size:', data.length);
          document.getElementById('cid-output').textContent = `Fetched: ${cidInput}`;
          adjustTextareaHeight(document.getElementById('cid-output'));

          let mimeType;
          let displayElement;
          if (contentType === 'video') {
            mimeType = 'video/*';
            displayElement = document.createElement('video');
            displayElement.controls = true;
            displayElement.style.maxWidth = '100%';
          } else {
            mimeType = 'image/*';
            displayElement = document.createElement('img');
            displayElement.style.maxWidth = '100%';
          }

          const blob = new Blob([data], { type: mimeType });
          const url = URL.createObjectURL(blob);
          displayElement.src = url;
          displayElement.alt = `${contentType} from IPFS`;

          const container = document.getElementById('image-container') || document.body;
          container.innerHTML = '';
          container.appendChild(displayElement);

          // Step 3: Pin the content and announce as provider
          try {
            await helia.pins.add(cid);

            let announced = false;
            const maxRetries = 10;
            let retryCount = 0;

            while (!announced && retryCount < maxRetries) {
              try {
                console.log(`Announcing CID to DHT (attempt ${retryCount + 1}/${maxRetries})`);
                const announcePromise = helia.libp2p.services.dht.provide(cid);
                const baseTimeout = retryCount === 0 ? 30000 : (retryCount === 1 || retryCount === 2) ? 150000 : Math.pow(2, retryCount - 1) * 5000;
                const globalTimeout = new Promise((_, reject) =>
                  setTimeout(() => reject(new Error(`DHT provide timed out after ${baseTimeout / 1000}s`)), baseTimeout)
                );
                await Promise.race([announcePromise, globalTimeout]);
                console.log('Announced CID to DHT successfully');
                announced = true;
              } catch (error) {
                console.error(`DHT announcement failed (attempt ${retryCount + 1}):`, error);
                retryCount++;
                if (retryCount < maxRetries) {
                  const backoff = retryCount === 1 ? 30000 : (retryCount === 2 || retryCount === 3) ? 150000 : Math.pow(2, retryCount - 1) * 5000;
                  console.log(`Retrying after ${backoff / 1000}s...`);
                  await new Promise(resolve => setTimeout(resolve, backoff));
                }
              }
            }

          } catch (pinError) {
            console.error('Pinning failed:', pinError);
            document.getElementById('cid-output').textContent += `\nPinning failed: ${pinError.message}`;
            adjustTextareaHeight(document.getElementById('cid-output'));
          }
        } catch (error) {
          console.error('Fetch error:', error);
          document.getElementById('cid-output').textContent = `Fetch failed: ${error.message}`;
          adjustTextareaHeight(document.getElementById('cid-output'));
        }
      }

      document.getElementById("load-msgs-from-ids-button").addEventListener("click", async () => {
        const ids = document.getElementById("load-msgs-from-ids").value.toLowerCase();
        const idsArray = ids.split(",").map(id => id.trim()).filter(id => id.length > 0); // Trim whitespace and filter out empty strings

        idsArray.forEach(id => {
          if (!id.startsWith("0.0.")) {
            const domainEntry = loadedDomains.find(domain => domain.domain === id); // Assuming loadedDomains is an array of objects with an 'id' property
            idsArray.splice(idsArray.indexOf(id), 1); // Remove the id from idsArray
            if (domainEntry) {
              idsArray.push(domainEntry.lastMessage.topic); // Add the domain entry to idsArray
            }
          }
        });

        await handleAllMessages();

        geojson.features = [];
        // Filter geojson.features based on the specified payers
        const filteredFeatures = geojson.features.filter(feature => {
          const match = idsArray.includes(feature.payer);
          return match;
        });

        const filteredPolygons = polygons.filter(polygon => {
          const match = idsArray.includes(polygon.payer);
          return match;
        });



        geojson.features = filteredFeatures;
        polygons.length = 0; // Clear existing polygons
        polygons.push(...filteredPolygons); // Add filtered polygons



        setTimeout(() => {
          existingMarkers.forEach(marker => marker.remove());
          existingMarkers = [];
        }, 250);

        map.getStyle().layers.forEach(layer => {
          if (layer.id.includes('-layer')) {
            map.removeLayer(layer.id);
          }
        });

        const sourceIds = Object.keys(map.getStyle().sources);
        sourceIds.forEach(sourceId => {
          if (sourceId.includes('-source')) {
            map.removeSource(sourceId);
          }
        });


        if (geojson.features.length > 0) {
          index.load(geojson.features);
          updateClusters(); // Assuming you have a function to update clusters
        }

        if (polygons.length > 0) {
          polygons.forEach(polygon => {
            addPolygonWithImageFill(map, polygon);
          });
        }
      });

      loader.updateProgress();

      document.getElementById("button4").addEventListener("click", async () => {

        const domain = document.getElementById("toolbar-input").value.toLowerCase();
        const domainObject = loadedDomains.find(d => d.domain === domain);

        if (domainObject) {

          console.log("domainObject", domainObject);
          const currentTime = Date.now() / 1000; // Get current time in seconds

          const timeLeftInSeconds = domainObject.addedTime - currentTime;

          // Calculate days, hours, minutes, and seconds
          const days = Math.floor(timeLeftInSeconds / (24 * 3600));
          const hours = Math.floor((timeLeftInSeconds % (24 * 3600)) / 3600);
          const minutes = Math.floor((timeLeftInSeconds % 3600) / 60);
          const seconds = Math.floor(timeLeftInSeconds % 60);

          const formattedTimeLeft = `${days}d ${hours}h ${minutes}m ${seconds}s`;

          document.getElementById("domain-time-left").textContent = `Time left: ${formattedTimeLeft}`;
        } else {
          console.warn("Domain not found in loadedDomains.");
          document.getElementById("domain-time-left").textContent = 'no one uses this domain';
        }
      });

      document.getElementById('go-to-top-msgs').addEventListener('click', function () {
        const container = document.getElementById('topic-chat-container');
        container.scrollTop = 0;
      });


      let storedMessages = [];
      let accidTopicChatColor = '#800080';
      let usernameTopicChatColor = '#ffffff';
      let textTopicChatColor = '#ffffff';

      document.getElementById("load-msgs-from").addEventListener("click", async () => {
        try {
          let userInput = document.getElementById("topic-chat-topic-id").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput;
          }


          const messagesContainer = document.getElementById("messages-from-topic-chat");
          const topicSpinnerChat = `
    <div style="display: flex; justify-content: left; align-items: left; height: 100%;  padding-top: 1vh; padding-bottom: 1vh;">
      <div id="topicspinnerchat"></div>
       <span style="margin-left: 1vw;">Loading messages from ${topicId}</span>
      </div>`;
          messagesContainer.innerHTML = topicSpinnerChat;
          adjustTextareaHeight(messagesContainer);

          const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          const memo = topicInfo.memo;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
            }
          });

          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          if (!result || !Array.isArray(result.messages)) {
            console.log("No messages found or result is not an array.");
            return [];
          }

          const profilePictures = await loadProfilePicture(); // Load profile pictures
          const usernames = await loadUsername(); // Load usernames
          const click2url = await loadCLICK2URL();
          const topic2pic = await loadTOPIC2PIC();


          let allMessages = ''; // Initialize an empty string to hold all messages

          let previousPayer = null; // Track the previous payer

          const topicActions = new Map();

          const loadedNFTsForTopicChat = [];



          for (let index = 0; index < result.messages.length; index++) {
            const message = result.messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
              const timestamp = message.timestamp || Date.now(); // Use message timestamp or current time

              if (parsedMessage.addTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const nfts = parsedMessage.addTopicChatNFT.split(',').map(nft => nft.trim());
                nfts.forEach(nft => {
                  if (nft.startsWith("0.0.") && !loadedNFTsForTopicChat.includes(nft)) { // Check if NFT starts with "0.0."
                    loadedNFTsForTopicChat.push(nft);
                  }
                });
              }

              if (parsedMessage.removeTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const nft = parsedMessage.removeTopicChatNFT.trim();
                if (nft.startsWith("0.0.")) { // Check if NFT starts with "0.0."
                  const index = loadedNFTsForTopicChat.indexOf(nft);
                  if (index !== -1) {
                    loadedNFTsForTopicChat.splice(index, 1);
                  }
                }
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }


          if (loadedNFTsForTopicChat.length > 0) {
            console.log("loadedNFTsForTopicChat", loadedNFTsForTopicChat);
          }

          // Process messages
          for (let index = 0; index < result.messages.length; index++) {
            const message = result.messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }

              const payer = parsedMessage.payer || 'Unknown';

              // Check if the payer owns any NFT from loadedNFTsForTopicChat
              let payerHasNFT = false;
              if (loadedNFTsForTopicChat.length > 0) {
                for (const item of loadedNFTsForTopicChat) {
                  const checkIfUserHasNFT = await sdk.getAccountNFTs(payer, item);
                  if (checkIfUserHasNFT.length > 0) {
                    payerHasNFT = true;
                    break;
                  }
                }
              } else {
                payerHasNFT = true; // If no NFTs to check, allow all messages
              }

              if (payerHasNFT && parsedMessage.userMessage) {
                const userMessage = parsedMessage.userMessage;

                const payerImage = profilePictures[payer]?.url || 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';

                // Function to validate URL
                function isValidUrl(string) {
                  try {
                    new URL(string);
                    return true;
                  } catch (_) {
                    return false;
                  }
                }

                // Check if payerImage is valid, if not use fallback
                const validPayerImage = isValidUrl(payerImage) ? payerImage : 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';


                const timestamp = new Date(parsedMessage.created)
                  .toLocaleString('en-US', {
                    hour12: false,
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                  })
                  .replace(/[/]/g, '') // Remove slashes
                  .replace(/[:]/g, ''); // Remove colons

                const payerInfo = message.payer ? `${message.payer}` : 'Anonymous';
                const username = message.payer && usernames[message.payer] ?
                  ` ${usernames[message.payer].username}` :
                  '';

                const click2link = message.payer && click2url[message.payer] ?
                  ` ${click2url[message.payer].click2url}` :
                  '';

                const displayHeader =
                  `<a href="https://explore.hashpack.app/${payerInfo}" target="_blank" style="color: ${accidTopicChatColor}; text-decoration: none;">${payerInfo}</a>
${click2link ? `<a href="${click2link}" target="_blank" style="color: ${usernameTopicChatColor};
text-decoration: none;">${username}</a>` : `<span style="color: ${usernameTopicChatColor};">${username}</span>`}`;

                storedMessages.push(parsedMessage);

                if (payer !== previousPayer) {
                  allMessages += `<div style="display: flex; align-items: center; margin-top: 0.1em;">
    <img src="${validPayerImage}" alt="Profile photo"
    style="width: 2em; height: 2em; margin-right: 0.5em; border-radius: 1em; cursor: pointer;"
    onclick="loadTOPIC4PIC('${message.payer}');">
                    <div style="display: flex; flex-direction: column; justify-content: center;">
                      <div>${displayHeader}</div>
                      <span style="font-size: 0.8em; color: gray;">${timestamp}</span>
                      <div style="color: ${textTopicChatColor};">${userMessage}</div>
                    </div>
                  </div><br>`;
                } else {
                  allMessages += `<div style="display: flex; align-items: center; margin-left: 2.5em; margin-top: -1.25em;">
                    <div style="color: ${textTopicChatColor};">${userMessage}</div>
                  </div><br>`;
                }
                previousPayer = payer; // Update the previous payer
              } else {
                console.warn(`Message ${index} is missing payer or data.`);
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          const chatContainer = document.getElementById('topic-chat-container');
          let startY, scrollTop;

          chatContainer.addEventListener('touchstart', (e) => {
            startY = e.touches[0].pageY - chatContainer.offsetTop;
            scrollTop = chatContainer.scrollTop;
          });

          chatContainer.addEventListener('touchmove', (e) => {
            const y = e.touches[0].pageY - chatContainer.offsetTop;
            const walk = (y - startY) * 2; // Adjust the multiplier for sensitivity
            chatContainer.scrollTop = scrollTop - walk;
            e.preventDefault(); // Prevent default touch behavior
          });

          messagesContainer.addEventListener('touchstart', (e) => {
            startY = e.touches[0].pageY - messagesContainer.offsetTop;
            scrollTop = messagesContainer.scrollTop;
            e.stopPropagation(); // Stop the event from bubbling up
          });

          messagesContainer.addEventListener('touchmove', (e) => {
            const y = e.touches[0].pageY - messagesContainer.offsetTop;
            const walk = (y - startY) * 2; // Adjust the multiplier for sensitivity
            messagesContainer.scrollTop = scrollTop - walk;
            e.preventDefault(); // Prevent default touch behavior
            e.stopPropagation(); // Stop the event from bubbling up
          });

          messagesContainer.innerHTML = allMessages;

          if (allMessages.length === 0) {
            messagesContainer.innerHTML = 'no messages found';
          }

          adjustTextareaHeight(messagesContainer);

          // Scroll to the bottom of the message container
          messagesContainer.scrollTop = messagesContainer.scrollHeight;

        } catch (error) {
          const messagesContainer = document.getElementById('messages-from-topic-chat');
          messagesContainer.innerHTML =
            `<div style="display: flex; justify-content: left; align-items: left; height: 100%;  padding-top: 1vh; padding-bottom: 1vh;">
       <span style="margin-left: 1vw;">Invalid Topic ID</span>
      </div>`;
          adjustTextareaHeight(messagesContainer);
          console.error("Error setting rules:", error);
        }
      });

      document.getElementById("topic-msgs-filter").addEventListener("click", async () => {
        const fromDateInput = document.getElementById("from-mmddyyyy").value;
        const toDateInput = document.getElementById("to-mmddyyyy").value;

        if (!fromDateInput || !toDateInput) {
          console.error("Please provide both from and to dates.");
          return;
        }

        const profilePictures = await loadProfilePicture(); // Load profile pictures
        const usernames = await loadUsername(); // Load usernames
        const click2url = await loadCLICK2URL();
        const topic2pic = await loadTOPIC2PIC();

        const fromDate = new Date(fromDateInput.slice(4, 8), fromDateInput.slice(0, 2) - 1, fromDateInput.slice(2, 4));
        const toDate = new Date(toDateInput.slice(4, 8), toDateInput.slice(0, 2) - 1, toDateInput.slice(2, 4));

        console.log("fromDate", fromDate);
        console.log("toDate", toDate);

        // Adjust toDate to include the entire day
        toDate.setHours(23, 59, 59, 999);

        const filteredMessages = storedMessages.filter(message => {
          const messageDate = new Date(message.created); // Parse the created date string
          return messageDate >= fromDate && messageDate <= toDate;
        });

        let filteredMessagesHtml = '';
        let previousPayer = null;

        filteredMessages.forEach(parsedMessage => {
          const userMessage = parsedMessage.userMessage;
          const payer = parsedMessage.payer || 'Unknown';
          const payerImage = profilePictures[payer]?.url || 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';

          // Function to validate URL
          function isValidUrl(string) {
            try {
              new URL(string);
              return true;
            } catch (_) {
              return false;
            }
          }

          // Check if payerImage is valid, if not use fallback
          const validPayerImage = isValidUrl(payerImage) ? payerImage : 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';
          const timestamp = new Date(parsedMessage.created)
            .toLocaleString('en-US', {
              hour12: false,
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit'
            })
            .replace(/[/]/g, '') // Remove slashes
            .replace(/[:]/g, ''); // Remove colons

          const payerInfo = parsedMessage.payer ? `${parsedMessage.payer}` : 'Anonymous';
          const username = parsedMessage.payer && usernames[parsedMessage.payer] ?
            ` ${usernames[parsedMessage.payer].username}` :
            '';

          const click2link = parsedMessage.payer && click2url[parsedMessage.payer] ?
            ` ${click2url[parsedMessage.payer].click2url}` :
            '';

          const displayHeader =
            `<a href="https://explore.hashpack.app/${payerInfo}" target="_blank" style="color: ${accidTopicChatColor}; text-decoration: none;">${payerInfo}</a>
${click2link ? `<a href="${click2link}" target="_blank" style="color: ${usernameTopicChatColor};
text-decoration: none;">${username}</a>` : `<span style="color: ${usernameTopicChatColor};">${username}</span>`}`;

          filteredMessages.push(parsedMessage);



          if (payer !== previousPayer) {
            filteredMessagesHtml += `<div style="display: flex; align-items: center; margin-top: 0.1em;">
    <img src="${validPayerImage}" alt="Profile photo"
    style="width: 2em; height: 2em; margin-right: 0.5em; border-radius: 1em; cursor: pointer;"
    onclick="loadTOPIC4PIC('${parsedMessage.payer}');">
                    <div style="display: flex; flex-direction: column; justify-content: center;">
                      <div>${displayHeader}</div>
                      <span style="font-size: 0.8em; color: gray;">${timestamp}</span>
                      <div style="color: ${textTopicChatColor};">${userMessage}</div>
                    </div>
                  </div><br>`;
          } else {
            filteredMessagesHtml += `<div style="display: flex; align-items: center; margin-left: 2.5em; margin-top: -1.25em;">
                    <div style="color: ${textTopicChatColor};">${userMessage}</div>
                  </div><br>`;
          }
          previousPayer = payer; // Update the previous payer
        });

        const messageContainer = document.getElementById("messages-from-topic-chat");
        messageContainer.innerHTML = filteredMessagesHtml;
        adjustTextareaHeight(messageContainer);
        messageContainer.scrollTop = messageContainer.scrollHeight;

      });

      document.getElementById("topic-msgs-filter-time").addEventListener("click", async () => {
        const fromDateInput = document.getElementById("from-mmddyyyy").value;
        const toDateInput = document.getElementById("to-mmddyyyy").value;
        const fromTimeInput = document.getElementById("from-hhmmss").value;
        const toTimeInput = document.getElementById("to-hhmmss").value;

        if (!fromDateInput || !toDateInput || !fromTimeInput || !toTimeInput) {
          console.error("Please provide both from and to dates and times.");
          return;
        }

        const profilePictures = await loadProfilePicture(); // Load profile pictures
        const usernames = await loadUsername(); // Load usernames
        const click2url = await loadCLICK2URL();
        const topic2pic = await loadTOPIC2PIC();

        const fromDate = new Date(
          fromDateInput.slice(4, 8),
          fromDateInput.slice(0, 2) - 1,
          fromDateInput.slice(2, 4),
          fromTimeInput.slice(0, 2), // Hours
          fromTimeInput.slice(2, 4), // Minutes
          fromTimeInput.slice(4, 6)  // Seconds
        );

        const toDate = new Date(
          toDateInput.slice(4, 8),
          toDateInput.slice(0, 2) - 1,
          toDateInput.slice(2, 4),
          toTimeInput.slice(0, 2), // Hours
          toTimeInput.slice(2, 4), // Minutes
          toTimeInput.slice(4, 6)  // Seconds
        );

        console.log("fromDate", fromDate);
        console.log("toDate", toDate);

        const filteredMessages = storedMessages.filter(message => {
          const messageDate = new Date(message.created); // Parse the created date string
          return messageDate >= fromDate && messageDate <= toDate;
        });

        let filteredMessagesHtml = '';
        let previousPayer = null;

        filteredMessages.forEach(parsedMessage => {
          const userMessage = parsedMessage.userMessage;
          const payer = parsedMessage.payer || 'Unknown';
          const payerImage = profilePictures[payer]?.url || 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';

          // Function to validate URL
          function isValidUrl(string) {
            try {
              new URL(string);
              return true;
            } catch (_) {
              return false;
            }
          }

          // Check if payerImage is valid, if not use fallback
          const validPayerImage = isValidUrl(payerImage) ? payerImage : 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';
          const timestamp = new Date(parsedMessage.created)
            .toLocaleString('en-US', {
              hour12: false,
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit'
            })
            .replace(/[/]/g, '') // Remove slashes
            .replace(/[:]/g, ''); // Remove colons

          const payerInfo = parsedMessage.payer ? `${parsedMessage.payer}` : 'Anonymous';
          const username = parsedMessage.payer && usernames[parsedMessage.payer] ?
            ` ${usernames[parsedMessage.payer].username}` :
            '';

          const click2link = parsedMessage.payer && click2url[parsedMessage.payer] ?
            ` ${click2url[parsedMessage.payer].click2url}` :
            '';

          const displayHeader =
            `<a href="https://explore.hashpack.app/${payerInfo}" target="_blank" style="color: ${accidTopicChatColor}; text-decoration: none;">${payerInfo}</a>
${click2link ? `<a href="${click2link}" target="_blank" style="color: ${usernameTopicChatColor};
text-decoration: none;">${username}</a>` : `<span style="color: ${usernameTopicChatColor};">${username}</span>`}`;

          // Store the message in the external array
          filteredMessages.push(parsedMessage);



          if (payer !== previousPayer) {
            filteredMessagesHtml += `<div style="display: flex; align-items: center; margin-top: 0.1em;">
    <img src="${validPayerImage}" alt="Profile photo"
    style="width: 2em; height: 2em; margin-right: 0.5em; border-radius: 1em; cursor: pointer;"
    onclick="loadTOPIC4PIC('${parsedMessage.payer}');">
                    <div style="display: flex; flex-direction: column; justify-content: center;">
                      <div>${displayHeader}</div>
                      <span style="font-size: 0.8em; color: gray;">${timestamp}</span>
                      <div style="color: ${textTopicChatColor};">${userMessage}</div>
                    </div>
                  </div><br>`;
          } else {
            filteredMessagesHtml += `<div style="display: flex; align-items: center; margin-left: 2.5em; margin-top: -1.25em;">
                    <div style="color: ${textTopicChatColor};">${userMessage}</div>
                  </div><br>`;
          }
          previousPayer = payer; // Update the previous payer
        });

        const messageContainer = document.getElementById("messages-from-topic-chat");
        messageContainer.innerHTML = filteredMessagesHtml;
        adjustTextareaHeight(messageContainer);
        messageContainer.scrollTop = messageContainer.scrollHeight;

      });




      let loadedDomains = [];


      async function loadDomains() {
        try {
          const topicId = "0.0.9606779";

          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          if (!result || !Array.isArray(result.messages)) {
            console.log("No messages found or result is not an array.");
            return [];
          }

          const domainsMap = new Map();

          for (let index = 0; index < result.messages.length; index++) {
            const message = result.messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }

              if (parsedMessage.payer && parsedMessage.domain) {
                const domain = parsedMessage.domain;
                if (!domainsMap.has(domain)) {
                  domainsMap.set(domain, []);
                }
                domainsMap.get(domain).push({
                  topic: parsedMessage.topic,
                  domain: domain,
                  payer: parsedMessage.payer,
                  timestamp: parsedMessage.consensus_timestamp // or parsedMessage.timestamp
                });
              } else {
                console.warn(`Message ${index} is missing payer or domain.`);
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          const SECONDS_TO_ADD = 2419200;
          const currentTime = Date.now() / 1000;

          let domainsArray = Array.from(domainsMap.entries()).map(([domain, messages]) => {
            // Sort all messages for the domain by timestamp
            messages.sort((a, b) => parseFloat(a.timestamp) - parseFloat(b.timestamp));

            if (messages.length === 0) {
              return { domain, lastMessage: null, addedTime: 0 };
            }

            const firstPayer = messages[0].payer;
            const firstTimestamp = parseFloat(messages[0].timestamp);
            const initialWindowEnd = firstTimestamp + SECONDS_TO_ADD;

            // Check if firstPayer has any renewal (subsequent message) within the initial window
            const hasRenewal = messages.some((msg, idx) => idx > 0 && msg.payer === firstPayer && parseFloat(msg.timestamp) <= initialWindowEnd);

            let validPayerMessages = [];
            let startTimestamp;

            if (hasRenewal) {
              // Use firstPayer and all their messages
              validPayerMessages = messages.filter(message => message.payer === firstPayer);
              startTimestamp = firstTimestamp;
            } else {
              // Find the first takeover message from a different payer AFTER the initial window end
              let takeoverIndex = -1;
              for (let i = 1; i < messages.length; i++) {
                const msgTimestamp = parseFloat(messages[i].timestamp);
                if (messages[i].payer !== firstPayer && msgTimestamp > initialWindowEnd) {
                  takeoverIndex = i;
                  break;
                }
              }

              if (takeoverIndex === -1) {
                // No takeover, fall back to firstPayer with no renewal (initial period only)
                validPayerMessages = messages.filter(message => message.payer === firstPayer);
                startTimestamp = firstTimestamp;
              } else {
                // Switch to takeover payer and their messages from takeover onwards
                const takeoverPayer = messages[takeoverIndex].payer;
                startTimestamp = parseFloat(messages[takeoverIndex].timestamp);
                validPayerMessages = messages.slice(takeoverIndex).filter(message => message.payer === takeoverPayer);
              }
            }

            if (validPayerMessages.length === 0) {
              return { domain, lastMessage: null, addedTime: 0 };
            }

            // Compute addedTime starting from the startTimestamp
            let addedTime = startTimestamp + SECONDS_TO_ADD;

            // Handle sequential renewals: iterate through subsequent messages
            for (let i = 1; i < validPayerMessages.length; i++) {
              const renewalTime = parseFloat(validPayerMessages[i].timestamp);
              if (renewalTime < addedTime) {
                // Extend expiry if renewal is within current window
                addedTime = addedTime + SECONDS_TO_ADD;
              }
            }

            // Get the last message from the valid payer
            const lastMessage = validPayerMessages[validPayerMessages.length - 1];

            return {
              domain,
              lastMessage,
              addedTime
            };
          });

          // Filter out expired domains (keep only active ones where addedTime > currentTime)
          domainsArray = domainsArray.filter(item => item.addedTime > currentTime);

          return domainsArray;

        } catch (error) {
          console.error("Error in loadDomains:", error);
          return [];
        }
      }

      loadDomains().then(domains => {
        loadedDomains = domains.filter(domain => !domain.domain.includes("0.0."));
      });


      document.getElementById("copy-coordinates").addEventListener("click", () => {
        event.stopPropagation();
        const center = map.getCenter();
        const coordinates = `${center.lng.toFixed(5)},${center.lat.toFixed(5)}`;

        navigator.clipboard.writeText(coordinates).then(() => {
        }).catch(err => {
          console.error("Failed to copy coordinates:", err);
        });
      });

      loader.updateProgress();

      // Define a default model URL
      const defaultModelUrl = 'https://kiloscribe.com/api/inscription-cdn/0.0.9742046'; // Replace with your actual default model URL
      await loadUfoModel(defaultModelUrl);
      let BetaNFTScaleFactor = 1;

      async function connectWallet() {
        try {
          const { balance, accountId } = await sdk.connectWallet(
            PROJECT_ID,
            APP_METADATA
          );

          if (accountId && accountId !== null) {
            loadProfile(accountId, balance);
          } else {
            updateAccountInfo(undefined);
          }

        } catch (error) {
          console.error("Failed to connect wallet:", error);
        }
      }

      async function disconnectWallet() {
        try {
          await sdk.disconnectWallet(PROJECT_ID, APP_METADATA);
          updateAccountInfo(undefined);
        } catch (error) {
          console.error("Failed to connect wallet:", error);
        }
      }

      async function initAccount() {
        try {
          const accountResponse = await sdk.initAccount(PROJECT_ID, APP_METADATA);
          return accountResponse;
        } catch (error) {
          return null;
        }
      }

      async function initRetryAccount(accountResponse) {
        if (!accountResponse) {
          updateAccountInfo(null, 0);
          return;
        }

        updateAccountInfo(
          accountResponse.accountId || null,
          accountResponse.balance || 0
        );

        if (accountResponse.accountId === null) {
        } else {
          loadProfile(accountResponse.accountId, accountResponse.balance || 0);
        }
      }

      async function main() {
        const accountResponse = await initAccount();
        await initRetryAccount(accountResponse);
      }

      main();


      document.getElementById("connect-wallet-btn").addEventListener("click", connectWallet);
      document.getElementById("disconnect-wallet-btn").addEventListener("click", disconnectWallet);

      // ===== MODERN SIDEBAR FUNCTIONALITY =====
      
      // Sidebar Toggle Functionality
      const sidebarPanel = document.getElementById('sidebarPanel');
      const sidebarToggle = document.getElementById('sidebarToggle');
      const sidebarOpener = document.getElementById('sidebarOpener');
      
      function toggleSidebar() {
        sidebarPanel.classList.toggle('collapsed');
        
        // Show/hide opener button
        if (sidebarPanel.classList.contains('collapsed')) {
          sidebarOpener.style.display = 'flex';
        } else {
          sidebarOpener.style.display = 'none';
        }
        
        // Update toggle icon
        const toggleIcon = sidebarToggle.querySelector('.toggle-icon');
        const openerIcon = sidebarOpener.querySelector('.opener-icon');
        
        if (sidebarPanel.classList.contains('collapsed')) {
          toggleIcon.textContent = '→';
          openerIcon.textContent = '→';
        } else {
          toggleIcon.textContent = '←';
          openerIcon.textContent = '→';
        }
      }
      
      sidebarToggle.addEventListener('click', toggleSidebar);
      sidebarOpener.addEventListener('click', toggleSidebar);
      
      // Modern Wallet Integration
      const modernConnectBtn = document.getElementById('modernConnectWallet');
      const modernDisconnectBtn = document.getElementById('modernDisconnectWallet');
      const modernAccountDisplay = document.getElementById('modernAccountId');
      
      // Sync modern buttons with original wallet functionality
      modernConnectBtn.addEventListener('click', connectWallet);
      modernDisconnectBtn.addEventListener('click', disconnectWallet);
      
      // Function to update modern UI when wallet state changes
      function updateModernWalletUI(isConnected, accountId = '') {
        if (isConnected) {
          modernConnectBtn.style.display = 'none';
          modernDisconnectBtn.style.display = 'block';
          modernAccountDisplay.textContent = accountId;
          modernAccountDisplay.style.display = 'block';
        } else {
          modernConnectBtn.style.display = 'block';
          modernDisconnectBtn.style.display = 'none';
          modernAccountDisplay.textContent = '';
          modernAccountDisplay.style.display = 'none';
        }
      }
      
      // Watch for wallet state changes and sync UI
      // Override original functions to sync with modern UI
      const originalConnectWallet = connectWallet;
      const originalDisconnectWallet = disconnectWallet;
      
      connectWallet = async function() {
        await originalConnectWallet();
        // Check if connection was successful and update modern UI
        const accountElement = document.getElementById('account-id');
        if (accountElement && accountElement.textContent) {
          updateModernWalletUI(true, accountElement.textContent);
        }
      };
      
      disconnectWallet = async function() {
        await originalDisconnectWallet();
        updateModernWalletUI(false);
      };
      
      // Initialize modern UI state on page load
      setTimeout(() => {
        const accountElement = document.getElementById('account-id');
        const isConnected = accountElement && accountElement.textContent;
        if (isConnected) {
          updateModernWalletUI(true, accountElement.textContent);
        } else {
          updateModernWalletUI(false);
        }
      }, 1000);

      // ===== RIGHT SIDEBAR FUNCTIONALITY =====
      
      // Right Sidebar Toggle Functionality
      const rightSidebarPanel = document.getElementById('rightSidebarPanel');
      const rightSidebarToggle = document.getElementById('rightSidebarToggle');
      const rightSidebarOpener = document.getElementById('rightSidebarOpener');
      
      function toggleRightSidebar() {
        rightSidebarPanel.classList.toggle('collapsed');
        
        // Show/hide opener button
        if (rightSidebarPanel.classList.contains('collapsed')) {
          rightSidebarOpener.style.display = 'flex';
        } else {
          rightSidebarOpener.style.display = 'none';
        }
        
        // Update toggle icon
        const toggleIcon = rightSidebarToggle.querySelector('.toggle-icon');
        const openerIcon = rightSidebarOpener.querySelector('.opener-icon');
        
        if (rightSidebarPanel.classList.contains('collapsed')) {
          toggleIcon.textContent = '←';
          openerIcon.textContent = '←';
        } else {
          toggleIcon.textContent = '→';
          openerIcon.textContent = '←';
        }
      }
      
      rightSidebarToggle.addEventListener('click', toggleRightSidebar);
      rightSidebarOpener.addEventListener('click', toggleRightSidebar);
      
      // Right sidebar button functionality - connect to existing features
      document.getElementById('rightToggleControls').addEventListener('click', () => {
        document.getElementById('toggle-controls-btn').click();
      });
      
      document.getElementById('rightToggleVisibility').addEventListener('click', () => {
        document.getElementById('toggle-visibility-controls-btn').click();
      });
      
      document.getElementById('rightToggleFov').addEventListener('click', () => {
        document.getElementById('toggle-your-fov-btn').click();
      });
      
      document.getElementById('rightToggleModels').addEventListener('click', () => {
        // This could link to model settings when we implement them
        console.log('Model settings clicked');
      });

      async function extractAccountId() {
        const thisAccountId = globalAccountId;
        console.log("globalAccountId is", thisAccountId)
        return thisAccountId;
      }


      document.getElementById("submit-button-Create_New_Topic").addEventListener("click", async () => {
        try {
          const memo = document.getElementById("input-field-5-1").value || '';
          const adminKey = document.getElementById("input-field-5-2").value;
          // const fee = document.getElementById("input-field-5-3").value;
          // const tokenId = document.getElementById("input-field-5-4").value;
          // const royaltyAccount = document.getElementById("input-field-5-5").value;

          if ((memo && !adminKey) || (!memo && adminKey)) {
            console.error("Both memo and adminKey must be provided together.");
            return;
          }

          let createdTopicId;

          if (memo && adminKey) {
            createdTopicId = await window.HashinalsWalletConnectSDK.createTopic(memo, adminKey);
          } else {
            createdTopicId = await window.HashinalsWalletConnectSDK.createTopic(adminKey);
          }

          console.log("createdTopicId is", createdTopicId);


          document.getElementById("input-field-5").value = createdTopicId;
          document.getElementById("input-field-2-0").value = createdTopicId;
          document.getElementById("input-field-3-0").value = createdTopicId;
          document.getElementById("input-field").value = createdTopicId;
        } catch (error) {
          console.error("Error creating topic:", error);
        }
      });

      function adjustTextareaHeight(textarea) {
        textarea.style.height = ''; // Reset the height
        textarea.style.height = textarea.scrollHeight + 'px'; // Set it to the scroll height
      }

      document.getElementById("generate-private-and-public-key").addEventListener("click", async () => {
        try {
          const { privateKey, publicKey } = await sdk.generatePrivateAndPublicKey();

          const privateKeyTextarea = document.getElementById("generated-private-key");
          const publicKeyTextarea = document.getElementById("generated-public-key");

          privateKeyTextarea.value = privateKey;
          publicKeyTextarea.value = publicKey;

          adjustTextareaHeight(privateKeyTextarea);
          adjustTextareaHeight(publicKeyTextarea);
        } catch (error) {
          console.error("Error creating topic:", error);
        }
      });


      document.getElementById("submit-button-Change_Memo").addEventListener("click", async () => {
        try {
          let userInput = document.getElementById("input-field-topic-id").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput;
          }
          const memo = document.getElementById("input-field-memo").value || '';
          let adminKey = document.getElementById("input-field-admin-key").value;
          const realfee = document.getElementById("input-field-fee").value;
          const tokenId = document.getElementById("input-field-fee-token").value;
          const royaltyAccount = document.getElementById("input-field-royal-acc").value;

          const fee = realfee * 1000000

          let customFees = [];

          let createdTopicId;

          if (fee && tokenId && royaltyAccount) {
            customFees.push({
              denominatingTokenId: tokenId,
              amount: fee,
              collectorAccountId: royaltyAccount
            });
            const topic = topicId;
            const changeMemo =
              await window.HashinalsWalletConnectSDK.updateTopic(topic, memo, adminKey, customFees);
          } else {
            const topic = topicId;
            const changeMemo =
              await window.HashinalsWalletConnectSDK.updateTopic(topic, memo, adminKey);
          }


        } catch (error) {
          console.error("Error creating topic:", error);
        }
      });






      async function loadProfilePicture() {
        const topicId = "0.0.9609881";
        const accountUrls = {}; // Dictionary to store account IDs and their URLs

        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages)) {
            console.log("No profile pictures found, using defaults");
            return {};
          }

          // Process all messages to build the accountUrls dictionary
          result.messages.forEach(message => {
            if (message.payer && message.data && message.data.urls && message.data.urls.length > 0) {
              // Store or update the URL for this account
              accountUrls[message.payer] = {
                url: message.data.urls[0],
                timestamp: message.timestamp
              };
            }
          });


          return accountUrls;

        } catch (error) {
          console.log("Error in loadProfilePicture:", error);
          return {}; // Return empty object instead of throwing error
        }
      }

      loadProfilePicture();
      loader.updateProgress();

      async function loadUsername() {
        const topicId = "0.0.9609904";
        const accountUsernames = {};

        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages)) {
            console.log("No usernames found, using defaults");
            return {};
          }

          // Process all messages to build the accountUsernames dictionary
          result.messages.forEach(message => {
            if (message.payer && message.data && message.data.username) {
              // Only store usernames with less than 20 characters
              if (message.data.username.length < 20) {
                accountUsernames[message.payer] = {
                  username: message.data.username,
                  timestamp: message.timestamp
                };
              }
            }
          });

          return accountUsernames;

        } catch (error) {
          console.log("Error in loadUsername:", error);
          return {}; // Return empty object instead of throwing error
        }
      }

      async function loadCLICK2URL() {
        const topicId = "0.0.9752486";
        const accountCLICK2URL = {};

        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages)) {
            console.log("No CLICK2URL found, using defaults");
            return {};
          }

          // Process all messages to build the accountUsernames dictionary
          result.messages.forEach(message => {
            if (message.payer && message.data && message.data.click2url && message.data.click2url.length > 0) {
              // Only store usernames with less than 20 characters
              accountCLICK2URL[message.payer] = {
                click2url: message.data.click2url[0],
                timestamp: message.timestamp
              };
            }
          });

          return accountCLICK2URL;

        } catch (error) {
          console.log("Error in loadCLICK2URL:", error);
          return {}; // Return empty object instead of throwing error
        }
      }


      async function loadTOPIC2PIC() {
        const topicId = "0.0.9759201";
        const accountTOPIC2PIC = {}; // Dictionary to store account IDs and their topics2pic

        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages)) {
            console.log("No TOPIC2PIC found, using defaults");
            return {};
          }

          // Process all messages to build the accountTOPIC2PIC dictionary
          result.messages.forEach(message => {
            if (message.payer && message.data && message.data.topic2pic) {
              // Only store topics2pic with less than 20 characters
              if (message.data.topic2pic.length < 20) {
                accountTOPIC2PIC[message.payer] = {
                  topic2pic: message.data.topic2pic,
                  timestamp: message.timestamp
                };
              }
            }
          });

          return accountTOPIC2PIC;

        } catch (error) {
          console.log("Error in loadTOPIC2PIC:", error);
          return {}; // Return empty object instead of throwing error
        }
      }

      window.openPopupSettings = function () {
        requestAnimationFrame(() => {
          if (document.getElementById("popup-column-2").style.display === "block" && document.getElementById("popup-column-3").style.display === "block") {
            document.getElementById("popup-column-2").style.display = "none";
            document.getElementById("popup-column-container-2").style.display = "none";
            document.getElementById("popup-column-3").style.display = "none";
            document.getElementById("popup-column-container-3").style.display = "none";
          } else {
            document.getElementById("popup-column-2").style.display = "block";
            document.getElementById("popup-column-container-2").style.display = "block";
            document.getElementById("popup-column-3").style.display = "block";
            document.getElementById("popup-column-container-3").style.display = "block";
            OpenToggleYourFov();
            removeUfoModel();
          }
        });
      };


      window.loadTOPIC4PIC = async function (payer) {
        try {
          const accountTOPIC2PIC = await loadTOPIC2PIC();

          if (!accountTOPIC2PIC[payer] || !accountTOPIC2PIC[payer].topic2pic) {
            return {};
          }

          const topicId = accountTOPIC2PIC[payer].topic2pic;
          const topicIdStr = topicId[0];
          const topicInfo = await window.HashinalsWalletConnectSDK.getTopicInfo(topicIdStr);
          const topicAdmin = [];
          const memo = topicInfo.memo;

          const parts = memo.split(',');
          let hasRules = false;
          parts.forEach(part => {
            if (part.startsWith("0.0.")) {
              topicAdmin.push(part);
              hasRules = true;
            }
          });

          const result = await window.HashinalsWalletConnectSDK.getMessages(topicIdStr);

          if (!result || !Array.isArray(result.messages)) {
            console.log(`No messages found for topicId ${topicId}, returning empty object`);
            return {};
          }

          let hasMoreThanOneTopic = false;
          const topicActions = new Map();

          for (let index = 0; index < result.messages.length; index++) {
            const message = result.messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
              const timestamp = message.timestamp || Date.now();

              if (
                parsedMessage.addTopic &&
                parsedMessage.addTopic.addTopic &&
                (topicAdmin.length === 0 || topicAdmin.includes(message.payer))
              ) {
                hasMoreThanOneTopic = true;
                const topics =
                  typeof parsedMessage.addTopic.addTopic === 'string'
                    ? parsedMessage.addTopic.addTopic.split(',')
                    : [];
                topics.forEach(topic => {
                  topicActions.set(topic, { action: 'add', timestamp });
                });
              }

              if (
                parsedMessage.removeTopic &&
                parsedMessage.removeTopic.removeTopic &&
                (topicAdmin.length === 0 || topicAdmin.includes(message.payer))
              ) {
                hasMoreThanOneTopic = true;
                const topics =
                  typeof parsedMessage.removeTopic.removeTopic === 'string'
                    ? parsedMessage.removeTopic.removeTopic.split(',')
                    : [];
                topics.forEach(topic => {
                  topicActions.set(topic, { action: 'remove', timestamp });
                });
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          const loadedTopicsIds = Array.from(topicActions.entries())
            .filter(([topic, { action }]) => action === 'add' && topic.startsWith('0.0.'))
            .map(([topic]) => topic);

          const loadedTopicIdsWithNames = [];
          for (const topicId of loadedTopicsIds) {
            const { loadedTopicName } = await processTopicMessages(topicId);

            if (loadedTopicName !== undefined) {
              const topicNamePart = loadedTopicName ? `-${loadedTopicName}` : '';
              loadedTopicIdsWithNames.push(`${topicId}${topicNamePart}`);
            }
          }

          globalLoadedTopicIdsWithNames = loadedTopicIdsWithNames.sort((a, b) => {
            const idA = parseFloat(a.split('-')[0].replace('0.0.', ''));
            const idB = parseFloat(b.split('-')[0].replace('0.0.', ''));
            return idA - idB;
          });

          activePolygonPopups.forEach((popup) => popup.remove());
          activeMarkerPopups.forEach((popup) => popup.remove());
          CloseALL();
          const loadColumn = document.getElementById("load-column");
          loadColumn.style.display = "block";
          OpenToggleToolbar();
          const inputarea = document.getElementById("input-field");
          inputarea.value = '';
          const loaded_text_area = document.getElementById("loaded-topics");
          loaded_text_area.innerHTML = '';
          loaded_text_area.innerHTML = globalLoadedTopicIdsWithNames.join('<br>');
          adjustTextareaHeight(loaded_text_area);

          return { loadedTopicIdsWithNames };

        } catch (error) {
          console.log(`Error in loadTOPIC4PIC for payer ${payer}:`, error);
          return {};
        }
      }

      const geojson = {
        type: "FeatureCollection",
        features: []
      };

      const polygons = [
      ];

      const loadedNFTsForModel = [];
      const loadedNFTScaleForModel = [];
      let hasRulesForModelNFT = false;

      function updateRulesForModelNFTState() {
        if (loadedNFTsForModel.length > 0) {
          hasRulesForModelNFT = true;
        } else {
          hasRulesForModelNFT = false;
        }
      }

      let globalLoadedTopicIdsWithNames = [];

      async function handleAllMessages() {
        try {
          const profilePics = await loadProfilePicture();
          const usernames = await loadUsername();
          const click2url = await loadCLICK2URL();
          let userInput = document.getElementById("input-field").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput || initialTopicId;
          }

          const result = await sdk.getMessages(topicId);

          globalLoadedTopicIdsWithNames = [];
          let addedTopics = [];
          let removedTopics = [];
          let loadedTopicsIds = [];

          const loaded_text_area = document.getElementById("loaded-topics");
          loaded_text_area.value = '';
          const topicSpinnerChat = `
    <div style="display: flex; justify-content: left; align-items: left; padding-top: 1vh; padding-bottom: 1vh;">
      <div id="topicspinnerchat"></div>
       <span style="margin-left: 1vw;">loading messages from ${topicId}</span>
      </div>`;
          loaded_text_area.innerHTML = topicSpinnerChat;
          adjustTextareaHeight(loaded_text_area);

          let hasMoreThanOneTopic = false;

          geojson.features = [];
          polygons.length = 0;

          // Remove existing markers
          existingMarkers.forEach(marker => marker.remove());
          existingMarkers = [];

          // Remove existing polygon layers
          map.getStyle().layers.forEach(layer => {
            if (layer.id.includes('-layer')) {
              map.removeLayer(layer.id);
            }
          });

          // Remove existing polygon sources
          const sourceIds = Object.keys(map.getStyle().sources);
          sourceIds.forEach(sourceId => {
            if (sourceId.includes('-source')) {
              map.removeSource(sourceId);
            }
          });

          const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          const memo = topicInfo.memo;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
              hasRules = true;
            }
          });

          const topicActions = new Map();

          for (let index = 0; index < result.messages.length; index++) {
            const message = result.messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
              const timestamp = message.consensus_timestamp

              if (parsedMessage.addTopic && parsedMessage.addTopic.addTopic && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                hasMoreThanOneTopic = true;
                const topics = typeof parsedMessage.addTopic.addTopic === 'string'
                  ? parsedMessage.addTopic.addTopic.split(',')
                  : [];
                topics.forEach(topic => {
                  topicActions.set(topic, { action: 'add', timestamp });
                });
              }

              if (parsedMessage.removeTopic && parsedMessage.removeTopic.removeTopic && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                hasMoreThanOneTopic = true;
                const topics = typeof parsedMessage.removeTopic.removeTopic === 'string'
                  ? parsedMessage.removeTopic.removeTopic.split(',')
                  : [];
                topics.forEach(topic => {
                  topicActions.set(topic, { action: 'remove', timestamp });
                });
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          // Determine the final list of topics based on the latest action
          loadedTopicsIds = Array.from(topicActions.entries())
            .filter(([topic, { action }]) => action === 'add' && topic.startsWith('0.0.'))
            .map(([topic]) => topic);

          const loadedTopicIdsWithNames = [];


          // Load and process messages from each topic in loadedTopicsIds
          for (const topicId of loadedTopicsIds) {
            const { topicGeojsonFeatures, topicPolygons, loadedTopicName } = await processTopicMessages(topicId); // Ensure this is awaited if it's async

            // Update markers/clusters
            if (geojson.features.length > 0) {
              index.load(geojson.features);
              updateClusters();
            }
            // Add new polygons
            polygons.forEach(polygon => {
              addPolygonWithImageFill(map, polygon);
            });


            if (loadedTopicName !== undefined) { // Only skip if loadedTopicName is undefined
              const topicNamePart = loadedTopicName ? `-${loadedTopicName}` : '';
              loadedTopicIdsWithNames.push(`${topicId}${topicNamePart}`);
            }
          }

          globalLoadedTopicIdsWithNames = loadedTopicIdsWithNames;


          globalLoadedTopicIdsWithNames.sort((a, b) => {
            const idA = parseFloat(a.split('-')[0].replace('0.0.', ''));
            const idB = parseFloat(b.split('-')[0].replace('0.0.', ''));
            return idA - idB;
          });

          loaded_text_area.innerHTML = globalLoadedTopicIdsWithNames.join('<br>'); // Update with new values
          adjustTextareaHeight(loaded_text_area); // Adjust height after loading

          return loadedTopicIdsWithNames; // Return the loadedTopicsIds array

        } catch (error) {
          console.error("Error processing topic messages:", error);
        }
      };

      loader.updateProgress();

      loadedNFTScaleForModel.sort((a, b) => b.scale - a.scale);
      let scaleForModel = 1;
      let finalScaleForModel = 1;



      async function confirmNFTFunction(accountId) {
        let tokenIdForModel = "0.0.9605689";
        let tokenIDForBeta = "0.0.9606654";
        let userInput = document.getElementById("input-field").value.toLowerCase();
        let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
        let topicId;

        if (domainEntry && domainEntry.lastMessage) {
          topicId = domainEntry.lastMessage.topic;
        } else {
          topicId = userInput || initialTopicId;
        }
        await handleAllMessages();

        loadedNFTsForModel.length = 0;
        hasRulesForModelNFT = false;


        const NFTForModel = await sdk.getAccountNFTs(accountId, tokenIdForModel);
        const NFTForBeta = await sdk.getAccountNFTs(accountId, tokenIDForBeta);

        if (NFTForBeta.length > 0) {
          BetaNFTScaleFactor = 1.5;
          finalScaleForModel = BetaNFTScaleFactor * scaleForModel;
        } else {
          BetaNFTScaleFactor = 1; // Set to 1 if no beta NFTs
        }



        if (loadedNFTScaleForModel.length > 0) {
          for (const item of loadedNFTScaleForModel) {
            const checkIfUserHasNFT = await sdk.getAccountNFTs(accountId, item.NFT);
            if (checkIfUserHasNFT.length > 0) {
              scaleForModel = item.scale;
              finalScaleForModel = BetaNFTScaleFactor * scaleForModel;
              break;
            }
            else {
              scaleForModel = 1;
            }
          }
        }


        if (NFTForModel.length > 0) {
          try {
            if (hasRulesForModelNFT === true) {
              for (const nft of loadedNFTsForModel) {
                const checkIfUserHasNFT = await sdk.getAccountNFTs(accountId, nft);
                if (checkIfUserHasNFT.length > 0) {
                  await someFunction(accountId, topicId);
                  return true;
                }
              }
              return false;
            }

            if (hasRulesForModelNFT === false) {
              await someFunction(accountId, topicId);
            }

          } catch (error) {
          }
        } else {
          return false;
        }
      }

      const renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document
        .getElementById("three-container")
        .appendChild(renderer.domElement);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );


      function createStars() {
        const starsGeometry = new THREE.BufferGeometry();
        const starCount = 2000;
        const positions = new Float32Array(starCount * 3);
        const innerRadius = 900;
        const outerRadius = 950;

        for (let i = 0; i < starCount; i++) {
          const i3 = i * 3;

          // Generate random spherical coordinates
          const theta = Math.random() * 2 * Math.PI; // Azimuthal angle
          const phi = Math.acos(2 * Math.random() - 1); // Polar angle
          // Random radius between innerRadius and outerRadius
          const radius = Math.cbrt(Math.random()) * (outerRadius - innerRadius) + innerRadius;

          // Convert to Cartesian coordinates
          positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
          positions[i3 + 2] = radius * Math.cos(phi);
        }

        starsGeometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        const starsMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 1.5,
          sizeAttenuation: true,
        });

        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
        return stars;
      }

      const stars = createStars();


      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      camera.position.z = 10;

      const randomLatitude = (Math.random() * 180) - 90; // Random latitude between -90 and 90
      const randomLongitude = (Math.random() * 360) - 180; // Random longitude between -180 and 180

      const map = new maplibregl.Map({
        container: "map",
        style: "https://tiles.openfreemap.org/styles/liberty",
        center: [-172, -19],
        zoom: 0,
        pitch: 0,
        bearing: 0,
        maxPitch: 75,
        maxZoom: 19,
        antialias: true,
        projection: {
          name: "globe",
        },
      });

      // Add navigation controls (optional, for testing bearing changes)
      map.addControl(new maplibregl.NavigationControl());

      // map.dragPan.disable();
      // map.scrollZoom.disable();
      // map.boxZoom.disable();
      // map.doubleClickZoom.disable();
      // map.touchZoomRotate.disable();
      // map.dragRotate.disable();


      const keys = {
        w: false,
        a: false,
        s: false,
        d: false,
        q: false,
        e: false,
        space: false,
        shift: false,
        r: false,
        f: false,
      };

      const MOVE_SPEED = 0.5;
      const BUTTON_PAN_SPEED = 6;
      const BUTTON_ZOOM_SPEED = 0.05;

      const speedSlider = document.getElementById("speed-slider");

      function getSpeedMultiplier() {
        return parseFloat(speedSlider.value);
      }

      loader.updateProgress();


      function handleMovement() {

        const isBlocked = [
          ...everythinginsideyourfov,
          ...everythinginsidetoolbar
        ].some(id => {
          const element = document.getElementById(id);
          return element && window.getComputedStyle(element).display === "block";
        });

        const zoom = map.getZoom();
        const panSpeed = 10 * getSpeedMultiplier();
        const zoomSpeed = 0.05 * getSpeedMultiplier();

        if (!isBlocked) {
          if (keys.w) {
            map.panBy([0, -panSpeed], { animate: false });
          }
          if (keys.s) {
            map.panBy([0, panSpeed], { animate: false });
          }

          if (keys.a) {
            map.panBy([-panSpeed, 0], { animate: false });
          }
          if (keys.d) {
            map.panBy([panSpeed, 0], { animate: false });
          }

          if (keys.e) {
            map.setBearing(map.getBearing() + MOVE_SPEED * getSpeedMultiplier());
          }
          if (keys.q) {
            map.setBearing(map.getBearing() - MOVE_SPEED * getSpeedMultiplier());
          }

          if (keys.space) {
            map.setZoom(map.getZoom() + zoomSpeed);
          }
          if (keys.shift) {
            map.setZoom(map.getZoom() - zoomSpeed);
          }

          if (keys.r) {
            map.setPitch(map.getPitch() + 1 * getSpeedMultiplier());
          }
          if (keys.f) {
            map.setPitch(map.getPitch() - 1 * getSpeedMultiplier());
          }
        }
      }

      document.addEventListener("keydown", (event) => {
        const activeElement = document.activeElement; // Get the currently focused element
        const isInputField = activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA";
        const isSpeedSlider = activeElement.id === "speed-slider"; // Check if the active element is the speed slider

        switch (event.key.toLowerCase()) {
          case "w":
            keys.w = true;
            break;
          case "a":
            keys.a = true;
            break;
          case "s":
            keys.s = true;
            break;
          case "d":
            keys.d = true;
            break;
          case "q":
            keys.q = true;
            break;
          case "e":
            keys.e = true;
            break;
          case " ":
            if (!isInputField || isSpeedSlider) { // Allow spacebar if the active element is the speed slider
              keys.shift = true;
              event.preventDefault();
            }
            break;
          case "shift":
            keys.space = true;
            break;
          case "r":
            keys.r = true;
            break;
          case "f":
            keys.f = true;
          case " ":
        }
      });

      document.addEventListener("keyup", (event) => {
        switch (event.key.toLowerCase()) {
          case "w":
            keys.w = false;
            break;
          case "a":
            keys.a = false;
            break;
          case "s":
            keys.s = false;
            break;
          case "d":
            keys.d = false;
            break;
          case "q":
            keys.q = false;
            break;
          case "e":
            keys.e = false;
            break;
          case " ":
            keys.shift = false;
            break;
          case "shift":
            keys.space = false;
            break;
          case "r":
            keys.r = false;
            break;
          case "f":
            keys.f = false;
            break;
        }
      });

      function OpenToggleToolbar() {
        document.getElementById("main-toggle-btn").style.display = "none";
        document.getElementById("toggle-toolbar-btn-btn").style.display = "block";
        document.getElementById("topic-chat-btn").style.display = "block";
      }

      function OpenToggleYourFov() {
        document.getElementById("main-toggle-btn").style.display = "none";
        document.getElementById("toggle-your-fov-btn-btn").style.display = "block";
        document.getElementById("topic-chat-btn").style.display = "block";
      }


      const everythinginsideoptionsbuttons = [
        "toggle-controls-btn",
        "toggle-your-fov-btn",
        "toggle-visibility-controls-btn",
        "toggle-toolbar-btn",
        "toggle-encrypted-chat-btn"
      ];

      const firstlayercolumns = [
        "rotation-controls",
        "toolbar",
        "visibility-controls",
        "topic-chat-container",
        "encrypted-chat-container"
      ];


      const everythinginsideyourfov = [
        "model-column",
        "model-column-save",
        "crosshair-column",
        "crosshair-column-save",
        "popup-column-2",
        "popup-column-3",
        "main-button-column",
        "main-button-column-save",
        "marker-options-column",
        "marker-column-save",
        "button-input-column",
        "button-input-column-save",
        "topic-chat-column",
        "topic-chat-save",
      ];

      const everythinginsidetoolbar = [
        "Edit_Profile-column",
        "load-column",
        "create-column",
        "upload-to-ipfs-column",
        "marker-column",
        "polygon-column",
        "rules-column",
        "utility-column",
        "memo-column",
        "stack-topic-ids",
      ];

      let popIsOpen = false;

      function CloseALL() {
        everythinginsideoptionsbuttons.forEach(buttonId => {
          const element = document.getElementById(buttonId);
          if (element) element.style.display = "none";
        });
        everythinginsideyourfov.forEach(buttonId => {
          document.getElementById(buttonId).style.display = "none";
        });
        everythinginsidetoolbar.forEach(buttonId => {
          document.getElementById(buttonId).style.display = "none";
        });
        firstlayercolumns.forEach(buttonId => {
          document.getElementById(buttonId).style.display = "none";
        });
        document.getElementById("main-toggle-btn").style.display = "block";
        document.getElementById("topic-chat-btn").style.display = "block";
        document.getElementById("toggle-toolbar-btn-btn").style.display = "none";
        document.getElementById("toggle-your-fov-btn-btn").style.display = "none";
        if (popIsOpen === true) {
          if (currentUfoModel) {
            scene.add(currentUfoModel);
            crosshair.style.display = "block";
          }
        }
        popIsOpen = false;
      }

      document.addEventListener('click', function (event) {
        CloseALL();
      });

      function removeUfoModel() {
        if (currentUfoModel) {
          scene.remove(currentUfoModel);
          crosshair.style.display = "none";
        }
        popIsOpen = true;
      }

      document.getElementById("main-toggle-btn").addEventListener("click", function (event) {
        event.stopPropagation();
        CloseALL();
        activePolygonPopups.forEach((popup) => popup.remove());
        activeMarkerPopups.forEach((popup) => popup.remove());
        document.getElementById("main-toggle-btn").style.display = "none";
        document.getElementById("topic-chat-btn").style.display = "none";
        everythinginsideoptionsbuttons.forEach(buttonId => {
          const element = document.getElementById(buttonId);
          if (element) element.style.display = "block";
        });
      });

      let toggleControlsPressCount = 0;

      document.getElementById("toggle-controls-btn").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        const speedSlider = document.getElementById("speed-slider");
        const maplibreglCtrlGroup = document.querySelector(".maplibregl-ctrl.maplibregl-ctrl-group");
        toggleControlsPressCount++;
        if (toggleControlsPressCount === 1) {
          speedSlider.style.display = "block";
          if (maplibreglCtrlGroup) maplibreglCtrlGroup.style.display = "block";
        } else if (toggleControlsPressCount > 3) {
          speedSlider.style.display = "none";
          if (maplibreglCtrlGroup) maplibreglCtrlGroup.style.display = "none";
          toggleControlsPressCount = 0;
        }
        const zoomControls = document.getElementById("zoom-controls");
        const leftDpad = document.getElementById("left-dpad");
        const rightDpad = document.getElementById("right-dpad");
        const isVisible = getComputedStyle(zoomControls).display !== "none";
        if (isVisible) {
          zoomControls.setAttribute("style", "display: none !important");
          leftDpad.setAttribute("style", "display: none !important");
          rightDpad.setAttribute("style", "display: none !important");
        } else {
          zoomControls.setAttribute("style", "display: flex !important; z-index: 2000 !important; opacity: 1 !important; visibility: visible !important;");
          leftDpad.setAttribute("style", "display: grid !important; z-index: 2000 !important; opacity: 1 !important; visibility: visible !important;");
          rightDpad.setAttribute("style", "display: grid !important; z-index: 2000 !important; opacity: 1 !important; visibility: visible !important;");
        }
      });

      document.getElementById("toggle-visibility-controls-btn").addEventListener("click", function (event) {
        event.stopPropagation();
        CloseALL();
        document.getElementById("visibility-controls").style.display = "block";
        removeUfoModel();
      });

      document.getElementById("toggle-your-fov-btn").addEventListener("click", function (event) {
        event.stopPropagation();
        CloseALL();
        document.getElementById("rotation-controls").style.display = "block";
      });

      document.getElementById("toggle-your-fov-btn-btn").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("rotation-controls").style.display = "block";
      });

      document.getElementById("change-model-settings").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("model-column").style.display = "block";
        document.getElementById("model-column-container").style.display = "block";
        document.getElementById("model-column-save").style.display = "block";
        document.getElementById("model-column-container-save").style.display = "block";
        OpenToggleYourFov();
      });

      document.getElementById("change-crosshair-settings").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("crosshair-column").style.display = "block";
        document.getElementById("crosshair-column-container").style.display = "block";
        document.getElementById("crosshair-column-save").style.display = "block";
        document.getElementById("crosshair-column-container-save").style.display = "block";
        OpenToggleYourFov();
      });

      document.getElementById("change-color-of-main-buttons").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("main-button-column").style.display = "block";
        document.getElementById("main-button-column-container").style.display = "block";
        document.getElementById("main-button-column-save").style.display = "block";
        document.getElementById("main-button-column-container-save").style.display = "block";
        OpenToggleYourFov();
        removeUfoModel();
      });

      document.getElementById("change-marker-options").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("marker-options-column").style.display = "block";
        document.getElementById("marker-options-column-container").style.display = "block";
        document.getElementById("marker-column-save").style.display = "block";
        document.getElementById("marker-column-container-save").style.display = "block";
        OpenToggleYourFov();
        removeUfoModel();
      });

      document.getElementById("change-button-input-settings").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("button-input-column").style.display = "block";
        document.getElementById("button-input-column-container").style.display = "block";
        document.getElementById("button-input-column-save").style.display = "block";
        document.getElementById("button-input-column-container-save").style.display = "block";
        OpenToggleYourFov();
        removeUfoModel();
      });

      document.getElementById("change-topic-chat-options").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("topic-chat-column").style.display = "block";
        document.getElementById("topic-chat-column-container").style.display = "block";
        document.getElementById("topic-chat-save").style.display = "block";
        document.getElementById("topic-chat-container-save").style.display = "block";
        OpenToggleYourFov();
        removeUfoModel();
      });

      document.getElementById("toggle-toolbar-btn").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("toolbar").style.display = "block";
        removeUfoModel();
      });

      document.getElementById("Edit_Profile").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("Edit_Profile-column").style.display = "block";
        document.getElementById("Edit_Profile-column-container").style.display = "block";
        OpenToggleToolbar();
        removeUfoModel();
      });

      document.getElementById("Load_Everything").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("load-column").style.display = "block";
        document.getElementById("load-column-container").style.display = "block";
        const loaded_text_area = document.getElementById("loaded-topics");
        loaded_text_area.innerHTML = '';
        loaded_text_area.innerHTML = globalLoadedTopicIdsWithNames.join('<br>');
        adjustTextareaHeight(loaded_text_area);
        OpenToggleToolbar();
        removeUfoModel();
      });

      document.getElementById("Upload_To_IPFS").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("upload-to-ipfs-column").style.display = "block";
        document.getElementById("upload-to-ipfs-column-container").style.display = "block";
        OpenToggleToolbar();
        removeUfoModel();
      });

      document.getElementById("Create_New_Topic").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("create-column").style.display = "block";
        document.getElementById("create-column-container").style.display = "block";
        OpenToggleToolbar();
        removeUfoModel();
      });

      document.getElementById("Create_Marker").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("marker-column").style.display = "block";
        document.getElementById("marker-column-container").style.display = "block";
        OpenToggleToolbar();
        removeUfoModel();
      });

      document.getElementById("Create_Polygon").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("polygon-column").style.display = "block";
        document.getElementById("polygon-column-container").style.display = "block";
        OpenToggleToolbar();
        removeUfoModel();
      });

      document.getElementById("Set_Rules").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("rules-column").style.display = "block";
        document.getElementById("rules-column-container").style.display = "block";
        OpenToggleToolbar();
        removeUfoModel();
      });

      document.getElementById("NFT-utility").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("utility-column").style.display = "block";
        document.getElementById("utility-column-container").style.display = "block";
        OpenToggleToolbar();
        removeUfoModel();
      });

      document.getElementById("Change_Memo").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("memo-column").style.display = "block";
        document.getElementById("memo-column-container").style.display = "block";
        OpenToggleToolbar();
        removeUfoModel();
      });

      document.getElementById("Stack_topic_IDs").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("stack-topic-ids").style.display = "block";
        document.getElementById("stack-topic-ids-container").style.display = "block";
        OpenToggleToolbar();
        removeUfoModel();
      });

      document.getElementById("topic-chat-btn").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        activePolygonPopups.forEach((popup) => popup.remove());
        activeMarkerPopups.forEach((popup) => popup.remove());
        document.getElementById("topic-chat-container").style.display = "block";
        document.getElementById("options-from-topic-chat").style.display = "none";
        document.getElementById("show-options-from-topic-chat").style.display = "block";
        document.getElementById("show-options-from-topic-chat-btn").style.display = "none";
        removeUfoModel();
      });

      document.getElementById("show-options-from-topic-chat").addEventListener("click", (event) => {
        document.getElementById("options-from-topic-chat").style.display = "block";
        document.getElementById("show-options-from-topic-chat").style.display = "none";
        document.getElementById("show-options-from-topic-chat-btn").style.display = "block";
      });

      document.getElementById("show-options-from-topic-chat-btn").addEventListener("click", (event) => {
        document.getElementById("options-from-topic-chat").style.display = "none";
        document.getElementById("show-options-from-topic-chat-btn").style.display = "none";
        document.getElementById("show-options-from-topic-chat").style.display = "block";
      });

      document.getElementById("toggle-toolbar-btn-btn").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("toolbar").style.display = "block";
        removeUfoModel();
      });

      document.getElementById("toggle-encrypted-chat-btn").addEventListener("click", (event) => {
        event.stopPropagation();
        CloseALL();
        document.getElementById("encrypted-chat-container").style.display = "block";
        document.getElementById("options-from-encrypted-chat").style.display = "none";
        document.getElementById("show-options-from-encrypted-chat").style.display = "block";
        document.getElementById("show-options-from-encrypted-chat-btn").style.display = "none";
        removeUfoModel();
      });

      document.getElementById("show-options-from-encrypted-chat").addEventListener("click", (event) => {
        document.getElementById("options-from-encrypted-chat").style.display = "block";
        document.getElementById("show-options-from-encrypted-chat").style.display = "none";
        document.getElementById("show-options-from-encrypted-chat-btn").style.display = "block";
      });

      document.getElementById("show-options-from-encrypted-chat-btn").addEventListener("click", (event) => {
        document.getElementById("options-from-encrypted-chat").style.display = "none";
        document.getElementById("show-options-from-encrypted-chat-btn").style.display = "none";
        document.getElementById("show-options-from-encrypted-chat").style.display = "block";
      });

      function closePopupColumn3options() {
        document.getElementById("popup-column-3-border").style.display = "none";
        document.getElementById("popup-column-3-number").style.display = "none";
        document.getElementById("popup-column-3-close").style.display = "none";
        document.getElementById("popup-column-3-accid").style.display = "none";
        document.getElementById("popup-column-3-username").style.display = "none";
        document.getElementById("popup-column-3-titles").style.display = "none";
        document.getElementById("popup-column-3-text").style.display = "none";
        document.getElementById("popup-column-3-font").style.display = "none";
        removeUfoModel();
      };

      document.getElementById("popup-column-2-border").addEventListener("click", (event) => {
        event.stopPropagation();
        closePopupColumn3options()
        document.getElementById("popup-column-3-border").style.display = "block";
      });

      document.getElementById("popup-column-2-number").addEventListener("click", (event) => {
        event.stopPropagation();
        closePopupColumn3options()
        document.getElementById("popup-column-3-number").style.display = "block";
      });

      document.getElementById("popup-column-2-close").addEventListener("click", (event) => {
        event.stopPropagation();
        closePopupColumn3options()
        document.getElementById("popup-column-3-close").style.display = "block";
      });

      document.getElementById("popup-column-2-accid").addEventListener("click", (event) => {
        event.stopPropagation();
        closePopupColumn3options()
        document.getElementById("popup-column-3-accid").style.display = "block";
      });

      document.getElementById("popup-column-2-username").addEventListener("click", (event) => {
        event.stopPropagation();
        closePopupColumn3options()
        document.getElementById("popup-column-3-username").style.display = "block";
      });

      document.getElementById("popup-column-2-titles").addEventListener("click", (event) => {
        event.stopPropagation();
        closePopupColumn3options()
        document.getElementById("popup-column-3-titles").style.display = "block";
      });

      document.getElementById("popup-column-2-text").addEventListener("click", (event) => {
        event.stopPropagation();
        closePopupColumn3options()
        document.getElementById("popup-column-3-text").style.display = "block";
      });

      document.getElementById("popup-column-2-font").addEventListener("click", (event) => {
        event.stopPropagation();
        closePopupColumn3options()
        document.getElementById("popup-column-3-font").style.display = "block";
      });

      document.getElementById("button3").addEventListener("click", async () => {
        try {
          const topicId = document.getElementById("Edit_Profile-topic-id").value;
          const newName = document.getElementById("toolbar-input").value;

          const meesageobject = {
            changeName: newName
          };

          const meesage = JSON.stringify(meesageobject);
          const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);

        } catch (error) {
          console.error("Error setting rules:", error);
        }
      });

      document.getElementById("post-msg").addEventListener("click", async () => {
        try {
          const newMessage = document.getElementById("user-write-message").value;

          let userInput = document.getElementById("topic-chat-topic-id").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput;
          }

          const meesageobject = {
            userMessage: newMessage
          };

          const meesage = JSON.stringify(meesageobject);
          const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);

        } catch (error) {
          console.error("Error setting rules:", error);
        }
      });



      document
        .getElementById("submit-button-Set_Rules")
        .addEventListener("click", async () => {
          try {
            let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
            let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
            let topicId;

            if (domainEntry && domainEntry.lastMessage) {
              topicId = domainEntry.lastMessage.topic;
            } else {
              topicId = userInput;
            }
            const polygonTopicId = document.getElementById("input-field-topic-id-for-polygons").value;
            const markerTopicId = document.getElementById("input-field-topic-id-for-markers").value;
            const messagesPerNftPolygon = document.getElementById("input-field-messages-per-nft-for-polygons").value;
            const messagesPerNftMarker = document.getElementById("input-field-messages-per-nft-for-markers").value;
            const SizeForPolygons = document.getElementById("input-field-messages-size-for-polygons").value;

            const meesageobject = {
              rules: {
                forpolygon: {
                  polygonTopicId: polygonTopicId,
                  polygonMessagesPerNft: messagesPerNftPolygon,
                  polygonSize: SizeForPolygons
                },
                formarker: {
                  markerTopicId: markerTopicId,
                  markerMessagesPerNft: messagesPerNftMarker
                }
              }
            };

            const meesage = JSON.stringify(meesageobject);

            const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
            console.log("Reciept is", reciept);

          } catch (error) {
            console.error("Error setting rules:", error);
          }
        });


      document.getElementById("load-topic-rules-for-topic").addEventListener("click", async () => {
        try {
          let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput;
          }


          const messagesContainer = document.getElementById('loaded-topic-rules-for-topic');
          messagesContainer.innerHTML = '';
          const topicSpinnerChat = `
        <div style="display: flex; justify-content: left; align-items: left; padding-top: 1vh; padding-bottom: 1vh;">
          <div id="topicspinnerchat"></div>
          <span style="margin-left: 1vw;">loading messages from ${topicId}</span>
          </div>`;
          messagesContainer.innerHTML = topicSpinnerChat;
          adjustTextareaHeight(messagesContainer);


          const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);
          const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          const memo = topicInfo.memo;
          let hasRules = false;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
              hasRules = true;
            }
          });

          const messages = response.messages; // Extract messages
          let lastRule = null;



          // Read rules from messages in reverse order
          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
              if (parsedMessage.rules && topicAdmin.includes(message.payer)) {
                lastRule = parsedMessage.rules;
                break; // Exit the loop after finding the last message with rules
              }

            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          let formattedRules = '';
          if (lastRule) {
            if (lastRule.forpolygon) {
              const polygonSize = lastRule.forpolygon.polygonSize;
              const maxLongitudeSize = 360 / polygonSize;
              const maxLatitudeSize = 180 / polygonSize;
              formattedRules +=
                `<span style="user-select: text;">Polygon NFT ID: ${lastRule.forpolygon.polygonTopicId}</span><br>
            <span style="user-select: text;">Polygon Messages Per NFT: ${lastRule.forpolygon.polygonMessagesPerNft}</span><br>
            <span style="user-select: text;">Maximum distance between points is:</span> <br>
            <span style="user-select: text;">Polygon Size: ${polygonSize}</span><br>
            <span style="user-select: text;">360/${polygonSize} = ${maxLongitudeSize} for longitude</span><br>
            <span style="user-select: text;">180/${polygonSize} = ${maxLatitudeSize} for latitude.</span><br>`;
              hasRules = true;
            }

            if (lastRule.formarker) {
              formattedRules +=
                `<span style="user-select: text;">Marker NFT ID: ${lastRule.formarker.markerTopicId}</span><br>
            <span style="user-select: text;">Marker Messages Per NFT: ${lastRule.formarker.markerMessagesPerNft}</span>`;
              hasRules = true;
            }
          }

          // Check if messages exist and is an array
          if (hasRules === false) {
            const noRulesMessage = `<span style="padding-top: 1vh;">No rules for this topic.</span>`;
            messagesContainer.innerHTML = noRulesMessage;
            adjustTextareaHeight(messagesContainer);
            return;
          }

          // Log the formatted rules onto the textarea
          messagesContainer.innerHTML = formattedRules;
          adjustTextareaHeight(messagesContainer);

        } catch (error) {
          const messagesContainer = document.getElementById('loaded-topic-rules-for-topic');
          const invalidTopicIdMessage = `<span style="padding-top: 1vh;">Invalid Topic ID</span>`;
          messagesContainer.innerHTML = invalidTopicIdMessage;
          adjustTextareaHeight(messagesContainer);

        }
      });

      document.getElementById("load-topic-rules-for-utility").addEventListener("click", async () => {
        try {
          let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput;
          }

          const messagesContainer = document.getElementById('loaded-topic-rules-for-utility');
          messagesContainer.innerHTML = '';
          const topicSpinnerChat = `
        <div style="display: flex; justify-content: left; align-items: left; padding-top: 1vh; padding-bottom: 1vh;">
          <div id="topicspinnerchat"></div>
          <span style="margin-left: 1vw;">loading messages from ${topicId}</span>
          </div>`;
          messagesContainer.innerHTML = topicSpinnerChat;
          adjustTextareaHeight(messagesContainer);


          const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);
          const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          const memo = topicInfo.memo;
          let hasRules = false;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
              hasRules = true;
            }
          });

          const messages = response.messages; // Extract messages

          let formattedRules;


          const loadedNFTsForModel = [];
          const loadedNFTScaleForModel = [];
          const loadedNFTsForTopicChat = [];


          for (let index = 0; index < messages.length; index++) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
              if (parsedMessage.addTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const nfts = parsedMessage.addTopicNFT.split(',').map(nft => nft.trim());
                nfts.forEach(nft => {
                  if (!loadedNFTsForModel.includes(nft)) {
                    loadedNFTsForModel.push(nft);
                  }
                });
              }

              if (parsedMessage.removeTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const nft = parsedMessage.removeTopicNFT.trim();
                const index = loadedNFTsForModel.indexOf(nft);
                if (index !== -1) {
                  loadedNFTsForModel.splice(index, 1);
                }
              }

              if (parsedMessage.addScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const { NFT, scale } = parsedMessage.addScale;
                loadedNFTScaleForModel.push({ NFT, scale });
              }

              if (parsedMessage.removeScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const { NFT } = parsedMessage.removeScale;
                const index = loadedNFTScaleForModel.findIndex(item => item.NFT === NFT);
                if (index !== -1) {
                  loadedNFTScaleForModel.splice(index, 1); // Remove the item if it exists
                } else {
                  console.log(`NFT: ${NFT} not found in addScale list`);
                }
              }

              if (parsedMessage.addTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const nfts = parsedMessage.addTopicChatNFT.split(',').map(nft => nft.trim());
                nfts.forEach(nft => {
                  if (!loadedNFTsForTopicChat.includes(nft)) {
                    loadedNFTsForTopicChat.push(nft);
                  }
                });
              }

              if (parsedMessage.removeTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const nft = parsedMessage.removeTopicChatNFT.trim();
                const index = loadedNFTsForTopicChat.indexOf(nft);
                if (index !== -1) {
                  loadedNFTsForTopicChat.splice(index, 1);
                }
              }
            }
            catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          if (loadedNFTsForModel.length === 0 && loadedNFTScaleForModel.length === 0 && loadedNFTsForTopicChat.length === 0) {
            formattedRules = '<span style="user-select: text;">No rules for this topic.</span>';
          }

          if (loadedNFTsForModel.length > 0) {
            formattedRules += `<span style="user-select: text;">NFTs for model: ${loadedNFTsForModel.join(', ')}</span><br>`;
            hasRules = true;
          }
          if (loadedNFTScaleForModel.length > 0) {
            formattedRules += `<span style="user-select: text;">Scales for model: ${loadedNFTScaleForModel.map(item => `${item.NFT} = ${item.scale}`).join(', ')}</span><br>`;
            hasRules = true;
          }
          if (loadedNFTsForTopicChat.length > 0) {
            formattedRules += `<span style="user-select: text;">NFTs for topic chat: ${loadedNFTsForTopicChat.join(', ')}</span><br>`;
            hasRules = true;
          }

          // Check if messages exist and is an array
          if (hasRules === false) {
            const utilityRulesMessage = `<span>No rules for this topic.</span>`;
            messagesContainer.innerHTML = utilityRulesMessage;
            adjustTextareaHeight(messagesContainer);
            return;
          }

          // Log the formatted rules onto the textarea
          messagesContainer.innerHTML = formattedRules;
          adjustTextareaHeight(messagesContainer);

        } catch (error) {
          console.error("Error creating topic:", error);
          const messagesContainer = document.getElementById('loaded-topic-rules-for-utility');
          const invalidTopicIdMessage = `<span style="padding-top: 1vh;">Invalid Topic ID</span>`;
          messagesContainer.innerHTML = invalidTopicIdMessage;
          adjustTextareaHeight(messagesContainer);
        }
      });



      document
        .getElementById("button5")
        .addEventListener("click", async () => {
          try {
            const topicId = '0.0.9606779';
            const topic = document.getElementById("Edit_Profile-topic-id").value;
            const domain = document.getElementById("toolbar-input").value.toLowerCase();


            const meesageobject = {
              topic: topic,
              domain: domain
            };

            const meesage = JSON.stringify(meesageobject);

            const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
            console.log("Reciept is", reciept);

          } catch (error) {
            console.error("Error setting rules:", error);
          }
        });



      document
        .getElementById("submit-button-add-scale-for-model")
        .addEventListener("click", async () => {
          try {
            let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
            let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
            let topicId;

            if (domainEntry && domainEntry.lastMessage) {
              topicId = domainEntry.lastMessage.topic;
            } else {
              topicId = userInput;
            }
            const stackTopicAddTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;
            const stackTopicAddScale = document.getElementById("input-field-add-remove-scale-for-model").value;


            const meesageobject = {
              addScale: {
                NFT: stackTopicAddTopicNFT,
                scale: stackTopicAddScale
              }
            };

            const meesage = JSON.stringify(meesageobject);

            const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
            console.log("Reciept is", reciept);

          } catch (error) {
            console.error("Error setting rules:", error);
          }
        });

      document
        .getElementById("submit-button-remove-scale-for-model")
        .addEventListener("click", async () => {
          try {
            let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
            let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
            let topicId;

            if (domainEntry && domainEntry.lastMessage) {
              topicId = domainEntry.lastMessage.topic;
            } else {
              topicId = userInput;
            }
            const stackTopicRemoveTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;

            const meesageobject = {
              removeScale: {
                NFT: stackTopicRemoveTopicNFT
              }
            };

            const meesage = JSON.stringify(meesageobject);

            const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
            console.log("Reciept is", reciept);

          } catch (error) {
            console.error("Error setting rules:", error);
          }
        });

      document
        .getElementById("submit-button-add-NFT-for-model")
        .addEventListener("click", async () => {
          try {
            let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
            let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
            let topicId;

            if (domainEntry && domainEntry.lastMessage) {
              topicId = domainEntry.lastMessage.topic;
            } else {
              topicId = userInput;
            }
            const stackTopicAddTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;


            const meesageobject = {
              addTopicNFT: stackTopicAddTopicNFT
            };

            const meesage = JSON.stringify(meesageobject);

            const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
            console.log("Reciept is", reciept);

          } catch (error) {
            console.error("Error setting rules:", error);
          }
        });
      loader.updateProgress();
      document
        .getElementById("submit-button-remove-NFT-for-model")
        .addEventListener("click", async () => {
          try {
            let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
            let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
            let topicId;

            if (domainEntry && domainEntry.lastMessage) {
              topicId = domainEntry.lastMessage.topic;
            } else {
              topicId = userInput;
            }
            const stackTopicRemoveTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;


            const meesageobject = {
              removeTopicNFT: stackTopicRemoveTopicNFT
            };

            const meesage = JSON.stringify(meesageobject);

            const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
            console.log("Reciept is", reciept);

          } catch (error) {
            console.error("Error setting rules:", error);
          }
        });

      document
        .getElementById("submit-button-add-topic-chat")
        .addEventListener("click", async () => {
          try {
            let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
            let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
            let topicId;

            if (domainEntry && domainEntry.lastMessage) {
              topicId = domainEntry.lastMessage.topic;
            } else {
              topicId = userInput;
            }
            const stackTopicAddTopicNFT = document.getElementById("input-field-add-remove-topic-chat").value;


            const meesageobject = {
              addTopicChatNFT: stackTopicAddTopicNFT
            };

            const meesage = JSON.stringify(meesageobject);

            const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
            console.log("Reciept is", reciept);

          } catch (error) {
            console.error("Error setting rules:", error);
          }
        });

      document
        .getElementById("submit-button-remove-topic-chat")
        .addEventListener("click", async () => {
          try {
            let userInput = document.getElementById("input-field-topic-id-for-utility").value.toLowerCase();
            let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
            let topicId;

            if (domainEntry && domainEntry.lastMessage) {
              topicId = domainEntry.lastMessage.topic;
            } else {
              topicId = userInput;
            }
            const stackTopicRemoveTopicNFT = document.getElementById("input-field-add-remove-topic-chat").value;


            const meesageobject = {
              removeTopicChatNFT: stackTopicRemoveTopicNFT
            };

            const meesage = JSON.stringify(meesageobject);

            const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
            console.log("Reciept is", reciept);

          } catch (error) {
            console.error("Error setting rules:", error);
          }
        });



      document
        .getElementById("add-topic-id")
        .addEventListener("click", async () => {
          try {
            let userInput = document.getElementById("stack-topic-ids-topic").value.toLowerCase();
            let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
            let topicId;

            if (domainEntry && domainEntry.lastMessage) {
              topicId = domainEntry.lastMessage.topic;
            } else {
              topicId = userInput;
            }
            const stackTopicAddTopic = document.getElementById("stack-topic-add-topic").value;


            const meesageobject = {
              addTopic: {
                addTopic: stackTopicAddTopic
              },
            };

            const meesage = JSON.stringify(meesageobject);

            const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
            console.log("Reciept is", reciept);

          } catch (error) {
            console.error("Error setting rules:", error);
          }
        });

      document
        .getElementById("remove-topic-id")
        .addEventListener("click", async () => {
          try {
            let userInput = document.getElementById("stack-topic-ids-topic").value.toLowerCase();
            let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
            let topicId;

            if (domainEntry && domainEntry.lastMessage) {
              topicId = domainEntry.lastMessage.topic;
            } else {
              topicId = userInput;
            }
            const stackTopicRemoveTopic = document.getElementById("stack-topic-remove-topic").value;


            const meesageobject = {
              removeTopic: {
                removeTopic: stackTopicRemoveTopic
              }
            };

            const meesage = JSON.stringify(meesageobject);

            const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
            console.log("Reciept is", reciept);

          } catch (error) {
            console.error("Error setting rules:", error);
          }
        });



      document
        .getElementById("submit-button-Create_Marker")
        .addEventListener("click", async () => {
          try {
            let userInput = document.getElementById("input-field-2-0").value.toLowerCase();
            let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
            let topicId;

            if (domainEntry && domainEntry.lastMessage) {
              topicId = domainEntry.lastMessage.topic;
            } else {
              topicId = userInput;
            }
            const title = document.getElementById("input-field-2-1").value;
            const imageurl = document.getElementById("input-field-image-marker").value;
            const coverimage = document.getElementById("input-field-coverimage-marker").value;
            const cleanUrl = imageurl.replace(/\?network=mainnet$/, "");
            const cleanCoverimage = coverimage.replace(/\?network=mainnet$/, "");
            const msg = document.getElementById("input-field-2-2").value;
            const cord = document.getElementById("input-field-2-3").value;
            const numberOfMarker = document.getElementById("input-field-number-of-marker").value;

            if (numberOfMarker === "" || !Number.isInteger(Number(numberOfMarker))) {
              alert("Please enter a valid whole number for the Number of Marker.");
              return;
            }

            if (!numberOfMarker || !topicId || !cord) {
              alert("Please fill in all required fields: Number of Marker, Topic ID, and Coordinates.");
              return;
            }

            const messageObj = { marker: { data: { title: title, image: [cleanUrl], coverimage: [cleanCoverimage], msg: msg, cord: cord, numberOfMarker: numberOfMarker } } };
            const message = JSON.stringify(messageObj);

            const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
              topicId,
              message
            );
            console.log('Receipt:', receipt);
          } catch (error) {
            console.error('Error submitting message:', error);
          }
        });

      document.getElementById("delete-marker-number").addEventListener("click", async () => {
        try {

          let userInput = document.getElementById("input-field-2-0").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput;
          }
          const oldMarkerNumber = document.getElementById("input-field-delete-marker-number").value;

          if (oldMarkerNumber === "" || !Number.isInteger(Number(oldMarkerNumber))) {
            alert("Please enter a valid whole number for the Number of Marker.");
            return;
          }

          if (!oldMarkerNumber || !topicId) {
            alert("Please fill in all required fields: Number of Marker, Topic ID");
            return;
          }

          const messageObj = { marker: { data: { deleteMarkerNumber: oldMarkerNumber } } };
          const message = JSON.stringify(messageObj);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log('Receipt:', receipt);


        } catch (error) {
          console.error('Error submitting message:', error);
        }
      });


      document
        .getElementById("submit-button-Create_Polygon")
        .addEventListener("click", async () => {
          try {
            let userInput = document.getElementById("input-field-3-0").value.toLowerCase();
            let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
            let topicId;

            if (domainEntry && domainEntry.lastMessage) {
              topicId = domainEntry.lastMessage.topic;
            } else {
              topicId = userInput;
            }
            const title = document.getElementById("input-field-3-1").value;
            const msg = document.getElementById("input-field-3-2").value;
            const imageurl = document.getElementById("input-field-image-polygon").value;
            const coverimage = document.getElementById("input-field-coverimage-polygon").value;
            const cord1 = document.getElementById("input-field-3-3").value; // TOP LEFT
            const cord3 = document.getElementById("input-field-3-5").value; // BOTTOM RIGHT
            const numberOfPolygon = document.getElementById("input-field-number-of-polygon").value;
            const cleanUrl = imageurl.replace(/\?network=mainnet$/, "");
            const cleanCoverimage = coverimage.replace(/\?network=mainnet$/, "");

            if (numberOfPolygon === "" || !Number.isInteger(Number(numberOfPolygon))) {
              alert("Please enter a valid whole number for the Number of Polygon.");
              return;
            }

            if (!numberOfPolygon || !topicId || !cord1 || !cord3) {
              alert("Please fill in all required fields: Number of Polygon, Topic ID, and Coordinates.");
              return; // Stop the submission if any field is empty
            }

            // Validate and format the coordinates input
            const Cords = {
              cord1: cord1.split(',').map(Number), // Convert to array of numbers
              cord3: cord3.split(',').map(Number),
            };

            const formattedCord = [
              Cords.cord1,
              [Cords.cord1[0], Cords.cord3[1]],
              Cords.cord3,
              [Cords.cord3[0], Cords.cord1[1]]
            ];

            // Ensure all coordinates are valid numbers
            const isValid = formattedCord.every(cord =>
              Array.isArray(cord) &&
              cord.length === 2 &&
              cord.every(num => !isNaN(num) && isFinite(num))
            );

            if (!isValid) {
              throw new Error('Please enter valid coordinates in the format number,number for all four corners.');
            }

            // Create the desired coordinate string without additional array wrapping
            const cordString = formattedCord.map(cord => `[${cord.join(',')}]`).join(', '); // Join the valid coordinates

            const messageObj = {
              polygon: {
                data: {
                  title: title,
                  image: [cleanUrl],
                  coverimage: [cleanCoverimage],
                  msg: msg,
                  cord: cordString,
                  numberOfPolygon: numberOfPolygon
                }
              }
            };
            const message = JSON.stringify(messageObj);

            const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
              topicId,
              message
            );
            console.log('Receipt:', receipt);

          } catch (error) {
            console.error('Error submitting message:', error);
          }
        });

      document.getElementById("delete-polygon-number").addEventListener("click", async () => {
        try {
          let userInput = document.getElementById("input-field-3-0").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput;
          }
          const oldPolygonNumber = document.getElementById("input-field-delete-polygon-number").value;

          if (oldPolygonNumber === "" || !Number.isInteger(Number(oldPolygonNumber))) {
            alert("Please enter a valid whole number for the Number of Polygon.");
            return;
          }

          if (!oldPolygonNumber || !topicId) {
            alert("Please fill in all required fields: Number of Polygon, Topic ID");
            return;
          }

          const messageObj = { polygon: { data: { deletePolygonNumber: oldPolygonNumber } } };
          const message = JSON.stringify(messageObj);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log('Receipt:', receipt);


        } catch (error) {
          console.error('Error submitting message:', error);
        }
      });


      function adjustButtonSize() {
        const coordinatesDisplay = document.getElementById('coordinates-display');
        const copyCoordinatesButton = document.getElementById('copy-coordinates');

        // Get the computed styles of the input field
        const computedStyle = window.getComputedStyle(coordinatesDisplay);

        // Parse the width and height to numbers (removing 'px')
        const width = parseFloat(computedStyle.width);
        const height = parseFloat(computedStyle.height);

        // Add a bit extra (e.g., 10px) and set back as strings with 'px'
        copyCoordinatesButton.style.width = `${width + 30}px`;
        copyCoordinatesButton.style.height = `${height + 10}px`;
      }

      // Call the function initially to set the size
      adjustButtonSize();

      // Optionally, add an event listener to adjust size on window resize
      window.addEventListener('resize', adjustButtonSize);



      let targetRotationX = 0;
      let targetRotationY = 0;
      let prevLng = 0;
      let prevLat = 0;
      const lerpFactor = 0.05; // Controls smoothness

      function animate() {
        requestAnimationFrame(animate);
        handleMovement();

        const zoomLevel = map.getZoom().toFixed(1);
        const pitchAngle = Math.round(map.getPitch());
        const center = map.getCenter();
        const lat = center.lat.toFixed(5);
        const lng = center.lng.toFixed(5);

        // Update coordinates display only if changed
        const coordinatesDisplay = document.getElementById("coordinates-display");
        const newCoords = `lng,lat = ${lng},${lat}`;
        if (coordinatesDisplay.value !== newCoords) {
          coordinatesDisplay.value = newCoords;

          const tempSpan = document.createElement("span");
          tempSpan.style.visibility = "hidden";
          tempSpan.style.position = "absolute";
          tempSpan.style.whiteSpace = "nowrap";
          tempSpan.style.font = window.getComputedStyle(coordinatesDisplay).font;
          tempSpan.textContent = newCoords;
          document.body.appendChild(tempSpan);

          coordinatesDisplay.style.width = `${tempSpan.offsetWidth}px`;
          document.body.removeChild(tempSpan);
        }

        // Smooth longitude transition
        let deltaLng = lng - prevLng;
        if (deltaLng > 180) deltaLng -= 360;
        else if (deltaLng < -180) deltaLng += 360;
        prevLng = lng;

        // Smooth latitude transition
        let deltaLat = lat - prevLat;
        if (deltaLat > 90) deltaLat -= 180;
        else if (deltaLat < -90) deltaLat += 180;
        prevLat = lat;

        // Update target rotations (removed 0.5 factor)
        targetRotationY -= (deltaLng * Math.PI) / 180; // Full rotation mapping
        targetRotationX += (deltaLat * Math.PI) / 180;

        // Apply lerp for smooth rotation
        stars.rotation.y += (targetRotationY - stars.rotation.y) * lerpFactor;
        stars.rotation.x += (targetRotationX - stars.rotation.x) * lerpFactor;

        renderer.render(scene, camera);
      }

      // Initialize with starting longitude and latitude
      function initializeRotation(initialLng, initialLat) {
        cumulativeLng = initialLng;
        prevLng = initialLng;
        cumulativeLat = initialLat;
        prevLat = initialLat;
      }

      // Example: Call this when your map or scene is initialized
      // initializeRotation(map.getCenter().lng, map.getCenter().lat);

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        map.resize();
      });

      animate();

      const index = new Supercluster({
        radius: 60,
        maxZoom: 11,
      });

      // Only load features if there are any
      if (geojson.features.length > 0) {
        index.load(geojson.features);
      }

      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), wait);
        };
      }

      let existingMarkers = [];

      function createLowQualityImage(imageUrl, size = 32) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "Anonymous";
          img.onload = () => {
            // Create a small canvas for the low quality version
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Draw image at lower resolution
            ctx.drawImage(img, 0, 0, size, size);

            // Convert to low quality JPEG-like format
            resolve(canvas.toDataURL('image/jpeg', 0.5));
          };
          img.onerror = reject;
          img.src = imageUrl;
        });
      }

      let lastBounds = null;

      const activeMarkerPopups = [];

      let currentMarkerSize = 5;

      function animateMapTo(map, targetLngLat, targetZoom = null, duration = 1000) {
        const start = map.getCenter(); // Current map center
        let startLng = start.lng;
        let startLat = start.lat;
        let targetLng = targetLngLat[0];
        const targetLat = targetLngLat[1];
        const startZoom = map.getZoom(); // Current zoom level
        const finalZoom = targetZoom !== null ? targetZoom : startZoom; // Use current zoom if targetZoom is null
        const startTime = performance.now();

        // Normalize longitude difference for shortest path
        let lngDiff = targetLng - startLng;
        if (lngDiff > 180) {
          lngDiff -= 360; // Go left across antimeridian
        } else if (lngDiff < -180) {
          lngDiff += 360; // Go right across antimeridian
        }

        function animate(currentTime) {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1); // Normalize to 0-1

          // Linear interpolation for smooth movement and zoom
          const currentLng = startLng + lngDiff * progress;
          const currentLat = startLat + (targetLat - startLat) * progress;
          const currentZoom = targetZoom !== null ? startZoom + (finalZoom - startZoom) * progress : startZoom;

          // Update map center and zoom separately
          map.setCenter([currentLng, currentLat]);
          if (targetZoom !== null) {
            map.setZoom(currentZoom);
          }

          // Continue animation until complete
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Ensure final position and zoom are exact
            map.setCenter([targetLng, targetLat]);
            if (targetZoom !== null) {
              map.setZoom(finalZoom);
            }
          }
        }

        requestAnimationFrame(animate);
      }

      function updateClusters() {
        if (geojson.features.length === 0) {
          console.log("No features to update clusters.");
          return;
        }

        const currentBounds = map.getBounds().toArray().flat();
        lastBounds = currentBounds;
        const zoom = map.getZoom();
        const clusters = index.getClusters(currentBounds, Math.floor(zoom));

        // Remove existing markers
        existingMarkers.forEach((marker) => marker.remove());
        existingMarkers = [];

        clusters.forEach(async (cluster) => {
          const el = document.createElement("div");
          el.className = cluster.properties.cluster ? "cluster-marker" : "marker";
          const iconSize = [`${currentMarkerSize}vh`, `${currentMarkerSize}vh`];
          el.style.width = iconSize[0];
          el.style.height = iconSize[1];
          el.style.cursor = "pointer";
          el.style.borderRadius = "50%";

          if (cluster.properties.cluster) {
            el.textContent = cluster.properties.point_count_abbreviated;
            el.style.color = "black";
            el.style.textAlign = "center";
            el.style.lineHeight = iconSize[0];
            el.style.backgroundColor = "rgba(255, 255, 255, 0.8)";

            el.addEventListener("click", async (e) => {
              e.stopPropagation();
              const expansionZoom = await index.getClusterExpansionZoom(cluster.id) + 0.1;
              animateMapTo(map, cluster.geometry.coordinates, expansionZoom);
              activePolygonPopups.forEach((popup) => popup.remove());
              activeMarkerPopups.forEach((popup) => popup.remove());
            });
          } else {
            try {
              const lowQualityUrl = await createLowQualityImage(cluster.properties.imageUrl);
              el.style.backgroundImage = `url(${lowQualityUrl})`;
              el.style.backgroundSize = "cover";

              const img = new Image();
              img.onload = () => {
                el.style.backgroundImage = `url(${cluster.properties.imageUrl})`;
              };
              img.src = cluster.properties.imageUrl;
            } catch (error) {
              console.error("Error loading marker image:", error);
              el.style.backgroundColor = "rgba(255, 255, 255, 0.8)";
            }
          }

          const marker = new maplibregl.Marker({ element: el })
            .setLngLat(cluster.geometry.coordinates)
            .addTo(map);

          if (!cluster.properties.cluster) {
            const popup = new maplibregl.Popup().setHTML(cluster.properties.message);
            activeMarkerPopups.push(popup);

            popup.on("close", () => {
              popIsOpen = false;
              if (currentUfoModel) {
                scene.add(currentUfoModel);
                crosshair.style.display = "block";
              }
            });

            el.addEventListener("click", (e) => {
              e.stopPropagation();
              activePolygonPopups.forEach((popup) => popup.remove());
              activeMarkerPopups.forEach((popup) => popup.remove());
              CloseALL();
              animateMapTo(map, cluster.geometry.coordinates, null);
              popup.setLngLat(cluster.geometry.coordinates).addTo(map);
              applyAllStyles();
              if (currentUfoModel) {
                scene.remove(currentUfoModel);
                crosshair.style.display = "none";
              }
            });
          }
          existingMarkers.push(marker);
        });
      }


      const debouncedUpdateClusters = debounce(() => {
        updateClusters(); // Run updateClusters
      }, 1000);
      // map.on("moveend", debouncedUpdateClusters);

      window.addEventListener("beforeunload", () => {
        map.remove();
        scene.clear();
        renderer.dispose();
      });

      async function createResizedImage(imageUrl, maxWidth = 256, maxHeight = 256) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "Anonymous";

          img.onload = () => {
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;

            // Calculate new dimensions while maintaining aspect ratio
            if (width > height) {
              if (width > maxWidth) {
                height = Math.round(height * (maxWidth / width));
                width = maxWidth;
              }
            } else {
              if (height > maxHeight) {
                width = Math.round(width * (maxHeight / height));
                height = maxHeight;
              }
            }

            canvas.width = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            // Use better image smoothing
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            ctx.drawImage(img, 0, 0, width, height);
            resolve(canvas.toDataURL('image/jpeg', 1)); // Adjust quality here (0-1)
          };

          img.onerror = reject;
          img.src = imageUrl;
        });
      }

      // Track added layers to avoid duplicates
      const addedLayers = new Set();
      const activePolygonPopups = [];

      async function addPolygonWithImageFill(map, polygon) {
        const sourceId = `${polygon.id}-source`;
        const layerId = `${polygon.id}-image-layer`;
        const maskLayerId = `${polygon.id}-mask-layer`;

        // Check if the source already exists
        if (map.getSource(sourceId)) {
          return; // Skip adding this polygon if the source already exists
        }

        // Wait for the map style to load if not already loaded
        if (!map.isStyleLoaded()) {
          await new Promise((resolve) => {
            map.once('load', () => resolve());
          });
        }

        try {
          // Calculate the bounding box of the polygon
          const coordinates = polygon.coordinates[0];
          const bounds = coordinates.reduce((bounds, coord) => {
            return {
              minLng: Math.min(bounds.minLng, coord[0]),
              maxLng: Math.max(bounds.maxLng, coord[0]),
              minLat: Math.min(bounds.minLat, coord[1]),
              maxLat: Math.max(bounds.maxLat, coord[1])
            };
          }, {
            minLng: Infinity,
            maxLng: -Infinity,
            minLat: Infinity,
            maxLat: -Infinity
          });

          // Create and add the resized image (now awaited)
          const resizedImageUrl = await createResizedImage(polygon.imageUrl, 512, 512);

          // Now safe to add source and layers since style is loaded
          map.addSource(sourceId, {
            type: 'image',
            url: resizedImageUrl,
            coordinates: [
              [bounds.minLng, bounds.maxLat],
              [bounds.maxLng, bounds.maxLat],
              [bounds.maxLng, bounds.minLat],
              [bounds.minLng, bounds.minLat]
            ]
          });

          map.addLayer({
            id: layerId,
            type: 'raster',
            source: sourceId,
            paint: {
              'raster-opacity': 1,
              'raster-fade-duration': 0,
              'raster-resampling': 'linear',
              'raster-brightness-min': 0,
              'raster-brightness-max': 1,
              'raster-contrast': 0,
              'raster-saturation': 0
            },
            layout: {
              'visibility': 'visible'
            },
            interactive: false // Disable click interactions
          });

          // Opacity slider listener (only add once per layer, but since it's per-layer, it's fine here)
          document.getElementById("raster-opacity-slider").addEventListener("input", (event) => {
            const opacityValue = event.target.value; // Get the current value of the slider
            if (map.getLayer(layerId)) { // Safety check
              map.setPaintProperty(layerId, 'raster-opacity', parseFloat(opacityValue)); // Update the layer's opacity
            }
          });

          // Add mask for the polygon
          const maskSourceId = `${polygon.id}-mask-source`;

          map.addSource(maskSourceId, {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'Polygon',
                coordinates: polygon.coordinates
              }
            }
          });

          map.addLayer({
            id: maskLayerId,
            type: 'fill',
            source: maskSourceId,
            paint: {
              'fill-opacity': 0, // Set back to 0 for invisibility after debugging
              'fill-outline-color': '#000'
            }
          }, layerId); // Ensure mask layer is above raster layer

          // Add interactivity (only if not already added)
          if (!addedLayers.has(maskLayerId)) {
            const popup = new maplibregl.Popup();

            map.on('click', maskLayerId, (e) => {
              if (polygon.description) {
                popup
                  .setLngLat(e.lngLat)
                  .setHTML(polygon.description)
                  .addTo(map);
                animateMapTo(map, e.lngLat, null);
                activePolygonPopups.forEach((p) => p.remove());
                activeMarkerPopups.forEach((p) => p.remove());
                CloseALL();
                activePolygonPopups.push(popup);
                applyAllStyles();
              }
              popIsOpen = false;
              if (currentUfoModel) {
                scene.remove(currentUfoModel);
                crosshair.style.display = "none";
              }
            });

            // Add a listener for the popup's close event
            popup.on('close', () => {
              if (currentUfoModel) {
                scene.add(currentUfoModel);
                crosshair.style.display = "block";
                // Remove popup from tracking array when closed
                const index = activePolygonPopups.indexOf(popup);
                if (index > -1) {
                  activePolygonPopups.splice(index, 1);
                }
              }
            });

            map.on('mouseenter', maskLayerId, () => {
              map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', maskLayerId, () => {
              map.getCanvas().style.cursor = '';
            });

            // Mark this layer as added
            addedLayers.add(maskLayerId);
          }
        } catch (error) {
          console.error('Error loading or resizing image:', error);
        }
      }

      const leftUpButton = document.getElementById("left-up");
      const leftLeftButton = document.getElementById("left-left");
      const leftRightButton = document.getElementById("left-right");
      const leftDownButton = document.getElementById("left-down");

      const rightUpButton = document.getElementById("right-up");
      const rightLeftButton = document.getElementById("right-left");
      const rightRightButton = document.getElementById("right-right");
      const rightDownButton = document.getElementById("right-down");

      const activeIntervals = new Set();

      function setupButton(buttonElement, action) {
        let intervalId;

        const startAction = (event) => {
          event.preventDefault();
          if (!intervalId) {
            intervalId = setInterval(action, 16); // 60fps timing
            activeIntervals.add(intervalId);
          }
        };

        const stopAction = () => {
          if (intervalId) {
            clearInterval(intervalId);
            activeIntervals.delete(intervalId);
            intervalId = null;
          }
        };

        buttonElement.addEventListener("mousedown", startAction);
        buttonElement.addEventListener("mouseup", stopAction);
        buttonElement.addEventListener("mouseleave", stopAction);

        buttonElement.addEventListener("touchstart", startAction);
        buttonElement.addEventListener("touchend", stopAction);
        buttonElement.addEventListener("touchcancel", stopAction);
      }

      setupButton(leftUpButton, () => map.panBy([0, -BUTTON_PAN_SPEED * getSpeedMultiplier()], { animate: false }));
      setupButton(leftDownButton, () => map.panBy([0, BUTTON_PAN_SPEED * getSpeedMultiplier()], { animate: false }));
      setupButton(leftLeftButton, () => map.panBy([-BUTTON_PAN_SPEED * getSpeedMultiplier(), 0], { animate: false }));
      setupButton(leftRightButton, () => map.panBy([BUTTON_PAN_SPEED * getSpeedMultiplier(), 0], { animate: false }));

      setupButton(rightUpButton, () => map.setZoom(map.getZoom() + BUTTON_ZOOM_SPEED * getSpeedMultiplier()));
      setupButton(rightDownButton, () => map.setZoom(map.getZoom() - BUTTON_ZOOM_SPEED * getSpeedMultiplier()));

      setupButton(rightLeftButton, () => map.setBearing(map.getBearing() - MOVE_SPEED * getSpeedMultiplier()));
      setupButton(rightRightButton, () => map.setBearing(map.getBearing() + MOVE_SPEED * getSpeedMultiplier()));

      setupButton(document.getElementById("zoom-in"), () => map.setPitch(map.getPitch() + 1 * getSpeedMultiplier()));
      setupButton(document.getElementById("zoom-out"), () => map.setPitch(map.getPitch() - 1 * getSpeedMultiplier()));

      window.addEventListener("beforeunload", () => {
        activeIntervals.forEach(interval => clearInterval(interval));
        activeIntervals.clear();
      });

      // Add event listeners for the new buttons
      document.getElementById("button1").addEventListener("click", async (event) => {
        event.stopPropagation();
        const inputValue = document.getElementById("toolbar-input").value;

        try {
          const topicId = "0.0.9609881";
          const cleanUrl = inputValue.replace(/\?network=mainnet$/, "");

          const messageData = {
            data: {
              urls: [cleanUrl],
            },
          };
          const message = JSON.stringify(messageData);

          const receipt = await sdk.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile picture updated successfully:", receipt);

          document.getElementById("toolbar-input").value = "";

        } catch (error) {
          console.error("Error updating profile picture:", error);
          // Removed alert
        }
      });

      document.getElementById("button2").addEventListener("click", async (event) => {
        event.stopPropagation();
        const inputValue = document.getElementById("toolbar-input").value;

        // Check if inputValue has less than 20 characters
        if (inputValue.length >= 20) {
          console.error("Input must be less than 20 characters");
          return; // Exit the function if the input is too long
        }

        try {
          const topicId = "0.0.9609904";

          const messageData = {
            data: {
              username: inputValue,
            },
          };
          const message = JSON.stringify(messageData);

          const receipt = await sdk.submitMessageToTopic(topicId, message);
          console.log("Username updated successfully:", receipt);

          document.getElementById("toolbar-input").value = "";
        } catch (error) {
          console.error("Error updating username:", error);
        }
      });

      // Add event listeners for the new buttons
      document.getElementById("button_for_click_url").addEventListener("click", async (event) => {
        event.stopPropagation();
        const inputValue = document.getElementById("toolbar-input").value;

        try {
          const topicId = "0.0.9752486";
          const cleanUrl = inputValue.replace(/\?network=mainnet$/, "");

          const messageData = {
            data: {
              click2url: [cleanUrl],
            },
          };
          const message = JSON.stringify(messageData);

          const receipt = await sdk.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile CLICK2URL updated successfully:", receipt);

          document.getElementById("toolbar-input").value = "";

        } catch (error) {
          console.error("Error updating profile CLICK2URL:", error);
          // Removed alert
        }
      });

      document.getElementById("button_for_topic2pic").addEventListener("click", async (event) => {
        event.stopPropagation();
        const inputValue = document.getElementById("Edit_Profile-topic-id").value;
        if (inputValue.length >= 20) {
          console.error("Input must be less than 20 characters");
          return;
        }
        try {
          const topicId = "0.0.9759201";
          const messageData = {
            data: {
              topic2pic: [inputValue],
            },
          };
          const message = JSON.stringify(messageData);
          const receipt = await sdk.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile TOPIC2PIC updated successfully:", receipt);
          document.getElementById("Edit_Profile-topic-id").value = "";
        } catch (error) {
          console.error("Error updating profile TOPIC2PIC:", error);
        }
      });



      // Add these variables to manage visibility states
      let markersVisible = false;
      let polygonsVisible = true;

      // Function to toggle markers visibility
      function toggleMarkers() {
        markersVisible = !markersVisible;
        existingMarkers.forEach(marker => {
          // Check if the marker element exists and toggle its visibility
          if (marker.getElement()) {
            if (markersVisible) {
              marker.getElement().style.display = 'block'; // Show marker
              marker.addTo(map); // Add marker back to the map
            } else {
              marker.getElement().style.display = 'none'; // Hide marker
              marker.remove(); // Remove marker from the map
            }
          }
        });
        // Update the button state text
        document.getElementById("marker-visibility-value").textContent = markersVisible ? "On" : "Off";
        document.getElementById("marker-visibility-value2").textContent = markersVisible ? "On" : "Off";

        // Prevent updating clusters if markers are not visible
        if (!markersVisible) {
          map.off("moveend", debouncedUpdateClusters); // Unsubscribe from moveend event
        } else {
          map.on("moveend", debouncedUpdateClusters); // Subscribe back to moveend event
        }
      }

      toggleMarkers();

      // Function to toggle polygons visibility
      function togglePolygons() {
        polygonsVisible = !polygonsVisible; // Toggle state

        polygons.forEach(polygon => {
          const layerId = `${polygon.id}-image-layer`;
          const maskLayerId = `${polygon.id}-mask-layer`; // Define the mask layer ID

          if (map.getLayer(layerId)) {
            const visibility = polygonsVisible ? 'visible' : 'none'; // Set visibility based on the current state
            map.setLayoutProperty(layerId, 'visibility', visibility);
            map.setLayoutProperty(maskLayerId, 'visibility', visibility); // Also toggle the mask layer visibility
          }
        });

        document.getElementById("polygon-visibility-value").textContent = polygonsVisible ? "On" : "Off"; // Update button state
        document.getElementById("polygon-visibility-value2").textContent = polygonsVisible ? "On" : "Off"; // Update button state
      }

      document.getElementById("toggle-polygon-visibility").addEventListener("click", togglePolygons);

      document.getElementById("toggle-marker-visibility").addEventListener("click", () => {
        toggleMarkers(); // Call the toggle function directly
      });

      document.getElementById("buttonforobject").addEventListener("click", async (event) => {
        event.stopPropagation();
        const inputValue = document.getElementById("object-input").value;

        try {
          const topicId = "0.0.9609898";
          const cleanUrl = inputValue.replace(/\?network=mainnet$/, "");

          const messageData = {
            data: {
              settings: [],
              urls: [cleanUrl],
            },
          };
          const message = JSON.stringify(messageData);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile picture updated successfully:", receipt);

          document.getElementById("object-input").value = "";

        } catch (error) {
          console.error("Error updating profile picture:", error);
          // Removed alert
        }
      });

      async function loadProfileObject() {

        const topicId = "0.0.9609898";
        const accountObjectUrl = []; // Initialize an empty array to store account URLs
        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            console.log("No profile object found, using defaults");
            return accountObjectUrl; // Return empty array if no messages
          }

          // Filter messages to find those from the current user
          const userMessages = result.messages.filter(message => message.payer === globalAccountId);

          // Get the last message from the filtered user messages
          const lastMessage = userMessages[userMessages.length - 1];

          // Check if the last message has valid data
          if (lastMessage && lastMessage.data && lastMessage.data.urls && lastMessage.data.urls.length > 0) {
            // Store the URL for this account
            accountObjectUrl.push(lastMessage.data.urls[0]); // Accessing the first URL
          }

          return accountObjectUrl; // Return the populated array

        } catch (error) {
          console.log("Error in loadProfileObject:", error);
          return []; // Return empty array instead of throwing error
        }
      }


      document.getElementById("savesettings").addEventListener("click", async (event) => {
        event.stopPropagation();

        try {
          const topicId = "0.0.9609898";
          const profileObjectUrl = await loadProfileObject();
          const cleanUrl = (profileObjectUrl.length > 0 ? profileObjectUrl[0].replace(/\?network=mainnet$/, "") : defaultModelUrl);

          const rotationX = document.getElementById("rotation-x").value;
          const rotationY = document.getElementById("rotation-y").value;
          const rotationZ = document.getElementById("rotation-z").value;

          const positionX = document.getElementById("position-x").value;
          const positionY = document.getElementById("position-y").value;
          const positionZ = document.getElementById("position-z").value;

          const scaleFactor = document.getElementById("scale-factor").value;

          // Construct the message data
          const messageData = {
            data: {
              settings: {
                rotation: {
                  x: rotationX,
                  y: rotationY,
                  z: rotationZ
                },
                position: {
                  x: positionX,
                  y: positionY,
                  z: positionZ
                },
                scale: {
                  scaleFactor
                },
              },
              urls: [cleanUrl],
            },
          };

          const message = JSON.stringify(messageData);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile settings updated successfully:", receipt);

        } catch (error) {
          console.error("Error updating settings picture:", error);
          // Removed alert
        }
      });



      async function loadProfileSettings() {
        const topicId = "0.0.9609898";
        const accountObjectSettings = []; // Initialize an empty array to store account Settings
        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            return accountObjectSettings; // Return empty array if no messages
          }

          // Filter messages to find those from the current user
          const userMessages = result.messages.filter(message => message.payer === globalAccountId);

          // Get the last message from the filtered user messages
          const lastMessage = userMessages[userMessages.length - 1];

          // Check if the last message has valid data
          if (lastMessage && lastMessage.data) {

            // Check if settings are empty
            if (Array.isArray(lastMessage.data.settings) && lastMessage.data.settings.length === 0) {
              const urls = lastMessage.data.urls; // This will give you the entire array
              // Store the settings in accountObjectSettings
              accountObjectSettings.push({ urls });
            } else {
              // Extract relevant data
              const { rotation, position, scale } = lastMessage.data.settings;
              const urls = lastMessage.data.urls; // This will give you the entire array

              // Store the settings in accountObjectSettings
              accountObjectSettings.push({ rotation, position, scale, urls });

              // Update input fields with the extracted data
              document.getElementById("rotation-x").value = rotation.x; // Set rotation X
              document.getElementById("rotation-x-value").value = rotation.x; // Set rotation X value
              document.getElementById("rotation-y").value = rotation.y; // Set rotation Y
              document.getElementById("rotation-y-value").value = rotation.y; // Set rotation Y value
              document.getElementById("rotation-z").value = rotation.z; // Set rotation Z
              document.getElementById("rotation-z-value").value = rotation.z; // Set rotation Z value

              document.getElementById("position-x").value = position.x; // Set position X
              document.getElementById("position-x-value").value = position.x; // Set position X value
              document.getElementById("position-y").value = position.y; // Set position Y
              document.getElementById("position-y-value").value = position.y; // Set position Y value
              document.getElementById("position-z").value = position.z; // Set position Z
              document.getElementById("position-z-value").value = position.z; // Set position Z value

              // Add scale factor input update
              document.getElementById("scale-factor").value = scale.scaleFactor; // Update scale factor input
              document.getElementById("scale-factor-value").value = scale.scaleFactor; // Update scale factor value

              // Update the object's position and rotation
              const ufoModel = scene.getObjectByName('gltfModel'); // Assuming the UFO model is named 'ufo'
              if (ufoModel) {
                ufoModel.rotation.x = THREE.MathUtils.degToRad(rotation.x);
                ufoModel.rotation.y = THREE.MathUtils.degToRad(rotation.y);
                ufoModel.rotation.z = THREE.MathUtils.degToRad(rotation.z);
                ufoModel.position.set(position.x, position.y, position.z);
                ufoModel.scale.set(scale.scaleFactor, scale.scaleFactor, scale.scaleFactor); // Scale the model
              }
            }
          } else {
            console.log("Last message does not have valid data."); // Log invalid data
          }

          // Check if accountObjectSettings is empty and set default model URL
          if (accountObjectSettings.length === 0) {
            await loadUfoModel(defaultModelUrl); // Load the default model
          }

          return accountObjectSettings; // Return the populated array
        } catch (error) {
          console.log("Error in loadProfileSettings:", error);
          return []; // Return empty array instead of throwing error
        }
      }


      // Add event listeners for the new buttons
      document.getElementById("savecrosshair").addEventListener("click", async (event) => {
        event.stopPropagation();

        try {
          const topicId = "0.0.9609927";

          const colorCrosshair = document.getElementById("crosshair-color").value;

          const crosshairBeforeWidth = document.getElementById("crosshair-before-after").value;
          const crosshairAfterHeight = document.getElementById("crosshair-after-before").value;

          // Construct the message data
          const messageData = {
            data: {
              color: {
                colorCrosshair: colorCrosshair
              },
              crosshair: {
                beforeWidth: crosshairBeforeWidth,
                afterHeight: crosshairAfterHeight
              }
            },
          };

          const message = JSON.stringify(messageData);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile settings updated successfully:", receipt);

        } catch (error) {
          console.error("Error updating settings picture:", error);
          // Removed alert
        }
      });



      async function loadProfileCrosshair() {
        const topicId = "0.0.9609927";
        const accountObjectSettings = []; // Initialize an empty array to store account Settings
        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            return accountObjectSettings; // Return empty array if no messages
          }

          // Filter messages to find those from the current user
          const userMessages = result.messages.filter(message => message.payer === globalAccountId);

          // Get the last message from the filtered user messages
          const lastMessage = userMessages[userMessages.length - 1];

          // Check if the last message has valid data
          if (lastMessage && lastMessage.data) {

            // Extract relevant data
            const { color, crosshair } = lastMessage.data;

            // Store the settings in accountObjectSettings
            accountObjectSettings.push({
              color,
              crosshair
            });

            document.getElementById("crosshair-color").value = color.colorCrosshair; // Set color crosshair

            document.getElementById("crosshair-before-after").value = crosshair.beforeWidth; // Set crosshair before width
            document.getElementById("crosshair-before-after-value").value = crosshair.beforeWidth; // Set crosshair before width value
            document.getElementById("crosshair-after-before").value = crosshair.afterHeight; // Set crosshair after height
            document.getElementById("crosshair-after-before-value").value = crosshair.afterHeight; // Set crosshair after height value

            // Call update functions to apply the loaded values
            updateColorCrosshair(); // Update crosshair color
            updateCrosshairBeforeAfter(crosshair.beforeWidth); // Update crosshair before width
            updateCrosshairAfterBefore(crosshair.afterHeight); // Update crosshair after height

          } else {
            console.log("Last message does not have valid data."); // Log invalid data
          }

          return accountObjectSettings; // Return the populated array

        } catch (error) {
          console.log("Error in loadProfileCrosshair:", error);
          return []; // Return empty array instead of throwing error
        }
      }

      function updateCrosshairBeforeAfter(value) {
        const crosshair = document.getElementById("crosshair");
        crosshair.style.setProperty('--crosshair-before-width', `${value}px`); // Width of ::before
        crosshair.style.setProperty('--crosshair-after-height', `${value}px`); // Height of ::after
      }

      function updateCrosshairAfterBefore(value) {
        const crosshair = document.getElementById("crosshair");
        crosshair.style.setProperty('--crosshair-after-width', `${value}px`); // Width of ::after
        crosshair.style.setProperty('--crosshair-before-height', `${value}px`); // Height of ::before
      }

      // Add event listeners for crosshair size sliders
      document.getElementById("crosshair-before-after").addEventListener("input", (event) => {
        const value = event.target.value;
        document.getElementById("crosshair-before-after-value").textContent = value;
        updateCrosshairBeforeAfter(value);
        document.getElementById("crosshair-before-after-value").value = value; // Update number input
      });

      document.getElementById("crosshair-after-before").addEventListener("input", (event) => {
        const value = event.target.value;
        document.getElementById("crosshair-after-before-value").textContent = value;
        updateCrosshairAfterBefore(value);
        document.getElementById("crosshair-after-before-value").value = value; // Update number input
      });

      // Add event listeners for number inputs to update sliders
      document.getElementById("crosshair-before-after-value").addEventListener("input", (event) => {
        const value = event.target.value;
        document.getElementById("crosshair-before-after").value = value; // Update range input
        updateCrosshairBeforeAfter(value);
      });

      document.getElementById("crosshair-after-before-value").addEventListener("input", (event) => {
        const value = event.target.value;
        document.getElementById("crosshair-after-before").value = value; // Update range input
        updateCrosshairAfterBefore(value);
      });

      function updateColorCrosshair() {
        const color = document.getElementById("crosshair-color").value;
        const crosshair = document.getElementById("crosshair");
        crosshair.style.setProperty('--crosshair-color', color);
      }
      document.getElementById("crosshair-color").addEventListener("input", (event) => { updateColorCrosshair(); });



      document.getElementById("savepopup3").addEventListener("click", async (event) => {
        event.stopPropagation();

        try {
          const topicId = "0.0.9771374";

          const hexColorBorder = document.getElementById('color-picker-popup-border').value;
          const hexColorNumber = document.getElementById('color-picker-popup-number').value;
          const hexColorClose = document.getElementById('color-picker-popup-close').value;
          const hexColorAccid = document.getElementById('color-picker-popup-accid').value;
          const hexColorUsername = document.getElementById('color-picker-popup-username').value;
          const hexColorTitles = document.getElementById('color-picker-popup-titles').value;
          const hexColorText = document.getElementById('color-picker-popup-text').value;
          const popupFontSize = Math.min(parseInt(document.getElementById("popup-font-size3").value) || 0.5, 10);

          const messageData = {
            data: {
              colorBorder: hexColorBorder,
              colorNumber: hexColorNumber,
              colorClose: hexColorClose,
              colorUsername: hexColorUsername,
              colorAccid: hexColorAccid,
              colorText: hexColorText,
              colorTitles: hexColorTitles,
              popupFontSize: popupFontSize
            },
          };

          const message = JSON.stringify(messageData);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile settings updated successfully:", receipt);

        } catch (error) {
          console.error("Error updating settings picture:", error);
          // Removed alert
        }
      });

      async function loadProfilePopup() {
        const topicId = "0.0.9771374";
        const accountObjectSettings = []; // Initialize an empty array to store account Settings
        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            return accountObjectSettings; // Return empty array if no messages
          }

          // Filter messages to find those from the current user
          const userMessages = result.messages.filter(message => message.payer === globalAccountId);

          // Get the last message from the filtered user messages
          const lastMessage = userMessages[userMessages.length - 1];

          // Check if the last message has valid data
          if (lastMessage && lastMessage.data) {
            console.log(lastMessage.data);
            // Extract relevant data and clamp to max 255
            const { colorBorder, colorNumber, colorClose, colorUsername, colorAccid, colorText, colorTitles, popupFontSize } = lastMessage.data;

            accountObjectSettings.push({
              colorBorder: colorBorder,
              colorNumber: colorNumber,
              colorClose: colorClose,
              colorUsername: colorUsername,
              colorAccid: colorAccid,
              colorText: colorText,
              colorTitles: colorTitles,
              popupFontSize: popupFontSize
            });

            document.getElementById("color-picker-popup-border").value = colorBorder;
            document.getElementById("color-picker-popup-number").value = colorNumber;
            document.getElementById("color-picker-popup-close").value = colorClose;
            document.getElementById("color-picker-popup-accid").value = colorAccid;
            document.getElementById("color-picker-popup-username").value = colorUsername;
            document.getElementById("color-picker-popup-titles").value = colorTitles;
            document.getElementById("color-picker-popup-text").value = colorText;
            document.getElementById("popup-font-size").value = popupFontSize;

            updatePopupBorder();
            updatePopupNumber();
            updatePopupClose();
            updatePopupAccid();
            updatePopupUsername();
            updatePopupTitles();
            updatePopupText();
            updatePopupFontSize();

          } else {
            console.log("Last message does not have valid data.");
          }

          return accountObjectSettings;

        } catch (error) {
          console.log("Error in loadProfilePopup:", error);
          return [];
        }
      }

      function applyAllStyles() {
        updatePopupBorder();
        updatePopupNumber();
        updatePopupClose();
        updatePopupAccid();
        updatePopupUsername();
        updatePopupTitles();
        updatePopupText();
        updatePopupFontSize();
      }

      function updatePopupBorder() {
        const color = document.getElementById('color-picker-popup-border').value;
        const popupContents = document.querySelectorAll('.maplibregl-popup');
        popupContents.forEach(popup => {
          popup.style.borderColor = color;
        });
      }
      document.getElementById('color-picker-popup-border').addEventListener('input', (event) => { updatePopupBorder(); });

      function updatePopupNumber() {
        const color = document.getElementById('color-picker-popup-number').value;
        const popupNumbers = document.querySelectorAll('.maplibregl-popup .number');
        popupNumbers.forEach(number => {
          number.style.color = color;
        });
      }
      document.getElementById('color-picker-popup-number').addEventListener('input', (event) => { updatePopupNumber(); });

      function updatePopupClose() {
        const color = document.getElementById('color-picker-popup-close').value;
        const popupCloses = document.querySelectorAll('.maplibregl-popup-close-button');
        popupCloses.forEach(close => {
          close.style.color = color;
        });
      }
      document.getElementById('color-picker-popup-close').addEventListener('input', (event) => { updatePopupClose(); });

      function updatePopupAccid() {
        const color = document.getElementById('color-picker-popup-accid').value;
        const popupAccids = document.querySelectorAll('.maplibregl-popup .payer-info');
        popupAccids.forEach(accid => {
          accid.style.color = color;
        });
      }
      document.getElementById('color-picker-popup-accid').addEventListener('input', (event) => { updatePopupAccid(); });

      function updatePopupUsername() {
        const color = document.getElementById('color-picker-popup-username').value;
        const popupUsernames = document.querySelectorAll('.maplibregl-popup .username');
        popupUsernames.forEach(username => {
          username.style.color = color;
        });
      }
      document.getElementById('color-picker-popup-username').addEventListener('input', (event) => { updatePopupUsername(); });

      function updatePopupTitles() {
        const color = document.getElementById('color-picker-popup-titles').value;
        const popupTitles = document.querySelectorAll('.maplibregl-popup .title_color');
        popupTitles.forEach(title => {
          title.style.color = color;
        });
      }
      document.getElementById('color-picker-popup-titles').addEventListener('input', (event) => { updatePopupTitles(); });

      function updatePopupText() {
        const color = document.getElementById('color-picker-popup-text').value;
        const popupTexts = document.querySelectorAll('.maplibregl-popup-content');
        popupTexts.forEach(text => {
          text.style.color = color;
        });
      }
      document.getElementById('color-picker-popup-text').addEventListener('input', (event) => { updatePopupText(); });

      function updatePopupFontSize() {
        const popupFontSize = document.getElementById("popup-font-size").value;
        const popupFontSizeValue = Math.min(parseInt(popupFontSize) || 0.5, 10);
        const popupTexts = document.querySelectorAll('.maplibregl-popup-content');
        popupTexts.forEach(text => {
          text.style.fontSize = `${popupFontSizeValue}vh`;
        });
      }
      document.getElementById('popup-font-size').addEventListener('input', (event) => { updatePopupFontSize(); });


      document.getElementById("save-main-button").addEventListener("click", async (event) => {
        event.stopPropagation();

        try {
          const topicId = "0.0.9797981";

          const colorDisconnect = document.getElementById("disconnect-button-color").value;
          const colorMainButton = document.getElementById("main-button-color").value;
          const messageData = {
            data: {
              colorDisconnect: colorDisconnect,
              colorMainButton: colorMainButton
            }
          };

          const message = JSON.stringify(messageData);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile settings updated successfully:", receipt);

        } catch (error) {
          console.error("Error updating settings picture:", error);
        }
      });

      async function loadMainButtonSettings() {
        const topicId = "0.0.9797981";
        const accountObjectSettings = []; // Initialize an empty array to store account Settings
        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            return accountObjectSettings; // Return empty array if no messages
          }

          // Filter messages to find those from the current user
          const userMessages = result.messages.filter(message => message.payer === globalAccountId);

          // Get the last message from the filtered user messages
          const lastMessage = userMessages[userMessages.length - 1];

          // Check if the last message has valid data
          if (lastMessage && lastMessage.data) {
            // Extract relevant data and clamp to max 255
            const { colorDisconnect, colorMainButton } = lastMessage.data;

            accountObjectSettings.push({
              colorDisconnect: colorDisconnect,
              colorMainButton: colorMainButton
            });

            document.getElementById("disconnect-button-color").value = colorDisconnect;
            document.getElementById("main-button-color").value = colorMainButton;

            updateMainButtonSettings();

          }

          return accountObjectSettings;

        } catch (error) {
          console.log("Error in loadMainButtonSettings:", error);
          return [];
        }
      }

      function updateMainButtonSettings() {
        const colorDisconnect = document.getElementById("disconnect-button-color").value;
        const colorMainButton = document.getElementById("main-button-color").value;

        const disconnectButton = document.querySelectorAll('#disconnect-wallet-btn');
        const connectButton = document.querySelectorAll('#connect-wallet-btn');
        const menuButtons = document.querySelectorAll('.menu_buttons');
        const optionsButtons = document.querySelectorAll('.options-and-topic');



        disconnectButton.forEach(button => {
          button.style.backgroundColor = colorDisconnect;
        });

        connectButton.forEach(button => {
          button.style.backgroundColor = colorDisconnect;
        });

        menuButtons.forEach(button => {
          button.style.backgroundColor = colorMainButton;
        });

        optionsButtons.forEach(button => {
          button.style.backgroundColor = colorMainButton;
        });
      }

      document.getElementById("disconnect-button-color").addEventListener("input", (event) => { updateMainButtonSettings(); });
      document.getElementById("main-button-color").addEventListener("input", (event) => { updateMainButtonSettings(); });

      document.getElementById("save-marker-settings").addEventListener("click", async (event) => {
        event.stopPropagation();
        try {
          const topicId = "0.0.9796116";

          const sizeMarker = Math.min(parseInt(document.getElementById("Marker-Sizer").value) || 0, 255);
          const messageData = {
            data: {
              sizeMarker: sizeMarker
            }
          };

          const message = JSON.stringify(messageData);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile settings updated successfully:", receipt);

        } catch (error) {
          console.error("Error updating settings picture:", error);
        }

      });

      async function loadMarkerSettings() {
        const topicId = "0.0.9796116";
        const accountObjectSettings = []; // Initialize an empty array to store account Settings
        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            return accountObjectSettings; // Return empty array if no messages
          }

          // Filter messages to find those from the current user
          const userMessages = result.messages.filter(message => message.payer === globalAccountId);

          // Get the last message from the filtered user messages
          const lastMessage = userMessages[userMessages.length - 1];

          // Check if the last message has valid data
          if (lastMessage && lastMessage.data) {
            // Extract relevant data and clamp to max 255
            const { sizeMarker } = lastMessage.data;

            const clampedSizeMarker = Math.min(parseInt(sizeMarker) || 0, 10);

            accountObjectSettings.push({
              sizeMarker: clampedSizeMarker
            });

            document.getElementById("Marker-Size").value = clampedSizeMarker;

            updateMarkerSettings();
          }

          return accountObjectSettings;

        } catch (error) {
          console.log("Error in loadMarkerSettings:", error);
          return [];
        }
      }

      function updateMarkerSettings() {
        const MarkerSize = document.getElementById("Marker-Size").value;
        currentMarkerSize = Math.min(parseInt(MarkerSize) || 5, 10);
        updateClusters();
      }

      document.getElementById("Marker-Size").addEventListener("input", (event) => { updateMarkerSettings(); });

      document.getElementById("save-button-button-input").addEventListener("click", async (event) => {
        event.stopPropagation();

        try {
          const topicId = "0.0.9798047";

          const InputBorderColor = document.getElementById("input-border-color").value;
          const InputFontColor = document.getElementById("input-font-color").value;
          const ButtonBorderColor = document.getElementById("button-border-color").value;
          const ButtonFontColor = document.getElementById("button-font-color").value;
          const OnhoverButtonColor = document.getElementById("onhover-button-color").value;
          const FontForButtonInput = Math.min(parseInt(document.getElementById("font-for-button-input").value) || 1.5, 10);
          const TransparencyButtonInput = Math.min(parseInt(document.getElementById("transparency-button-input").value) || 0.5, 1);

          const messageData = {
            data: {
              InputBorderColor: InputBorderColor,
              InputFontColor: InputFontColor,
              ButtonBorderColor: ButtonBorderColor,
              ButtonFontColor: ButtonFontColor,
              OnhoverButtonColor: OnhoverButtonColor,
              FontForButtonInput: FontForButtonInput,
              TransparencyButtonInput: TransparencyButtonInput,
            }
          };

          const message = JSON.stringify(messageData);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile settings updated successfully:", receipt);

        } catch (error) {
          console.error("Error updating settings picture:", error);
        }

      });

      async function loadButtonInputSettings() {
        const topicId = "0.0.9798047";
        const accountObjectSettings = []; // Initialize an empty array to store account Settings
        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            return accountObjectSettings; // Return empty array if no messages
          }

          // Filter messages to find those from the current user
          const userMessages = result.messages.filter(message => message.payer === globalAccountId);

          // Get the last message from the filtered user messages
          const lastMessage = userMessages[userMessages.length - 1];

          // Check if the last message has valid data
          if (lastMessage && lastMessage.data) {
            // Extract relevant data and clamp to max 255
            const { InputBorderColor, InputFontColor, ButtonBorderColor, ButtonFontColor, OnhoverButtonColor, FontForButtonInput, TransparencyButtonInput } = lastMessage.data;

            accountObjectSettings.push({
              InputBorderColor,
              InputFontColor,
              ButtonBorderColor,
              ButtonFontColor,
              OnhoverButtonColor,
              FontForButtonInput,
              TransparencyButtonInput,
            });


            document.getElementById("input-border-color").value = InputBorderColor;
            document.getElementById("input-font-color").value = InputFontColor;
            document.getElementById("button-border-color").value = ButtonBorderColor;
            document.getElementById("button-font-color").value = ButtonFontColor;
            document.getElementById("onhover-button-color").value = OnhoverButtonColor;
            document.getElementById("font-for-button-input").value = FontForButtonInput;
            document.getElementById("transparency-button-input").value = TransparencyButtonInput;
            updateButtonInputSettings();
          }

          return accountObjectSettings;

        } catch (error) {
          console.log("Error in loadButtonInputSettings:", error);
          return [];
        }
      }

      function updateButtonInputSettings() {
        const inputFontColor = document.getElementById("input-font-color").value;
        const inputBorderColor = document.getElementById("input-border-color").value;
        const buttonFontColor = document.getElementById("button-font-color").value;
        const onhoverButtonColor = document.getElementById("onhover-button-color").value;
        const buttonBorderColor = document.getElementById("button-border-color").value;
        const fontForButtonInput = Math.min(parseInt(document.getElementById("font-for-button-input").value) || 1.5, 10);
        const transparencyButtonInput = Math.min(parseInt(document.getElementById("transparency-button-input").value) || 0.5, 1);

        const inputButtons = document.querySelectorAll('.toolbar-column, .yourfov');
        inputButtons.forEach(button => {
          button.style.borderColor = inputBorderColor;
          button.style.opacity = transparencyButtonInput;
          button.style.fontSize = fontForButtonInput + "vh";
          button.style.color = inputFontColor;
        });

        const ButtonInputButtons = document.querySelectorAll('.toolbar-column-btns');
        ButtonInputButtons.forEach(button => {
          button.style.borderColor = buttonBorderColor;
          button.style.opacity = transparencyButtonInput;
          button.style.fontSize = fontForButtonInput + "vh";
          button.style.color = buttonFontColor;
          button.addEventListener('mouseover', () => {
            button.style.backgroundColor = onhoverButtonColor;
          });
          button.addEventListener('mouseout', () => {
            button.style.backgroundColor = 'transparent';
            button.style.color = buttonFontColor;
          });
        });
      }

      const everythingInsdieButtonInput = [
        document.getElementById("input-border-color"),
        document.getElementById("input-font-color"),
        document.getElementById("button-border-color"),
        document.getElementById("button-font-color"),
        document.getElementById("onhover-button-color"),
        document.getElementById("font-for-button-input"),
        document.getElementById("transparency-button-input"),
      ]

      everythingInsdieButtonInput.forEach(element => {
        element.addEventListener("input", (event) => { updateButtonInputSettings(); });
      });


      document.getElementById("save-topic-chat-settings").addEventListener("click", async (event) => {
        event.stopPropagation();

        try {
          const topicId = "0.0.9798064";
          const accidTopicChatColor = document.getElementById("accid-topic-chat-color").value;
          const usernameTopicChatColor = document.getElementById("username-topic-chat-color").value;
          const textTopicChatColor = document.getElementById("text-topic-chat-color").value;
          const textContainerTopicChatColor = document.getElementById("text-container-topic-chat-color").value;

          const messageData = {
            data: {
              accidTopicChatColor: accidTopicChatColor,
              usernameTopicChatColor: usernameTopicChatColor,
              textTopicChatColor: textTopicChatColor,
              textContainerTopicChatColor: textContainerTopicChatColor,
            }
          };

          const message = JSON.stringify(messageData);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile settings updated successfully:", receipt);

        } catch (error) {
          console.error("Error updating settings picture:", error);
        }

      });


      async function loadTopicChatSettings() {
        const topicId = "0.0.9798078";
        const accountObjectSettings = []; // Initialize an empty array to store account Settings
        try {
          const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
          // Check if result exists and has messages
          if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
            return accountObjectSettings; // Return empty array if no messages
          }

          // Filter messages to find those from the current user
          const userMessages = result.messages.filter(message => message.payer === globalAccountId);

          // Get the last message from the filtered user messages
          const lastMessage = userMessages[userMessages.length - 1];

          // Check if the last message has valid data
          if (lastMessage && lastMessage.data) {
            // Extract relevant data and clamp to max 255
            const { accidTopicChatColor, usernameTopicChatColor, textTopicChatColor, textContainerTopicChatColor } = lastMessage.data;


            accountObjectSettings.push({
              accidTopicChatColor: accidTopicChatColor,
              usernameTopicChatColor: usernameTopicChatColor,
              textTopicChatColor: textTopicChatColor,
              textContainerTopicChatColor: textContainerTopicChatColor,
            });

            document.getElementById("accid-topic-chat-color").value = accidTopicChatColor;
            document.getElementById("username-topic-chat-color").value = usernameTopicChatColor;
            document.getElementById("text-topic-chat-color").value = textTopicChatColor;
            document.getElementById("text-container-topic-chat-color").value = textContainerTopicChatColor;

            updateTopicChatSettings();
          }

          return accountObjectSettings;

        } catch (error) {
          console.log("Error in loadTopicChatSettings:", error);
          return [];
        }
      }

      function updateTopicChatSettings() {
        const newAccidTopicChatColor = document.getElementById("accid-topic-chat-color").value;
        const newUsernameTopicChatColor = document.getElementById("username-topic-chat-color").value;
        const newTextTopicChatColor = document.getElementById("text-topic-chat-color").value;
        const newTextContainerTopicChatColor = document.getElementById("text-container-topic-chat-color").value;

        accidTopicChatColor = newAccidTopicChatColor;
        usernameTopicChatColor = newUsernameTopicChatColor;
        textTopicChatColor = newTextTopicChatColor;
        textContainerTopicChatColor = newTextContainerTopicChatColor;

        const topicChatSettings = document.querySelectorAll('.chat-container');
        topicChatSettings.forEach(topicChat => {
          topicChat.style.borderColor = textContainerTopicChatColor;
        });

        return { accidTopicChatColor, usernameTopicChatColor, textTopicChatColor };

      }

      document.getElementById("accid-topic-chat-color").addEventListener("input", (event) => { updateTopicChatSettings(); });
      document.getElementById("username-topic-chat-color").addEventListener("input", (event) => { updateTopicChatSettings(); });
      document.getElementById("text-topic-chat-color").addEventListener("input", (event) => { updateTopicChatSettings(); });
      document.getElementById("text-container-topic-chat-color").addEventListener("input", (event) => { updateTopicChatSettings(); });


      async function loadUfoModel(modelUrl) {

        // Check if the model URL is defined and valid
        if (!modelUrl || typeof modelUrl !== 'string' || modelUrl.trim() === '') {
          modelUrl = defaultModelUrl; // Use the default model URL
          console.log('Using default model URL:', modelUrl);

        }

        // Load the GLTF model
        try {
          // Remove the previous model if it exists
          if (currentUfoModel) {
            scene.remove(currentUfoModel);
            currentUfoModel = null; // Clear the reference to the removed model
          }

          const gltf = await new Promise((resolve, reject) => {
            ufoLoader.load(modelUrl, resolve, undefined, (error) => {
              console.error("Error loading GLTF model:", error);
              reject(error);
            });
          });

          currentUfoModel = gltf.scene; // Get the loaded model

          // Step 1: Calculate the model's bounding box
          const box = new THREE.Box3().setFromObject(currentUfoModel);
          const modelSize = new THREE.Vector3();
          box.getSize(modelSize); // Get the size of the model

          // Step 2: Define the bounding box dimensions
          const boundingBoxSize = new THREE.Vector3(10, 10, 10); // Width, Height, Depth

          // Step 3: Calculate the scale factor
          const scaleFactor = Math.min(
            boundingBoxSize.x / modelSize.x,
            boundingBoxSize.y / modelSize.y,
            boundingBoxSize.z / modelSize.z
          );

          // Step 4: Apply the scale to the model
          currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Scale the model uniformly

          const isNewUser = modelUrl === defaultModelUrl; // Set to true if no URLs are found

          // Check if the user has loaded their profile object
          if (modelUrl !== defaultModelUrl) {
            // Load user-specific settings if available
            const profileSettings = await loadProfileSettings(); // Load profile settings
            if (profileSettings.length === 0 || !profileSettings[0].position) {
              // If no settings loaded, use bounding box for position
              currentUfoModel.position.set(box.min.x, box.min.y, box.min.z); // Use bounding box min for position
              currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Use calculated scale factor
              // Step 5: Position the model within the bounding box
              currentUfoModel.position.set(0, -5, -30); // Adjust as needed
            } else {
              // Apply user-specific settings
              currentUfoModel.position.set(
                parseFloat(document.getElementById("position-x").value),
                parseFloat(document.getElementById("position-y").value),
                parseFloat(document.getElementById("position-z").value)
              );
              currentUfoModel.rotation.set(
                THREE.MathUtils.degToRad(document.getElementById("rotation-x").value),
                THREE.MathUtils.degToRad(document.getElementById("rotation-y").value),
                THREE.MathUtils.degToRad(document.getElementById("rotation-z").value)
              );
              const userScaleFactor = parseFloat(document.getElementById("scale-factor").value);
              currentUfoModel.scale.set(userScaleFactor, userScaleFactor, userScaleFactor); // Scale the model uniformly
            }
          } else {
            // Default settings for new users
            currentUfoModel.position.set(0, -3, -8); // Default position
            currentUfoModel.rotation.set(
              THREE.MathUtils.degToRad(0),
              THREE.MathUtils.degToRad(0),
              THREE.MathUtils.degToRad(0)
            ); // Default rotation
            const defaultScaleFactor = 1; // Default scale factor
            currentUfoModel.scale.set(defaultScaleFactor, defaultScaleFactor, defaultScaleFactor); // Scale the model uniformly
          }

          // Add the model to the scene
          scene.add(currentUfoModel);

          // Existing event listeners for rotation and position sliders
          document.getElementById("rotation-x").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-x-value").value = value; // Update number input
            currentUfoModel.rotation.x = THREE.MathUtils.degToRad(value); // Convert degrees to radians
          });

          document.getElementById("rotation-y").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-y-value").value = value; // Update number input
            currentUfoModel.rotation.y = THREE.MathUtils.degToRad(value); // Convert degrees to radians
          });

          document.getElementById("rotation-z").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-z-value").value = value; // Update number input
            currentUfoModel.rotation.z = THREE.MathUtils.degToRad(value); // Convert degrees to radians
          });

          // Add event listeners for position sliders
          document.getElementById("position-x").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-x-value").value = value; // Update number input
            currentUfoModel.position.x = parseFloat(value); // Update the x position of the model
          });

          document.getElementById("position-y").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-y-value").value = value; // Update number input
            currentUfoModel.position.y = parseFloat(value); // Update the y position of the model
          });

          // Add Z position slider
          document.getElementById("position-z").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-z-value").value = value; // Update number input
            currentUfoModel.position.z = parseFloat(value); // Update the z position of the model
          });

          // Add scale factor slider
          document.getElementById("scale-factor").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("scale-factor-value").value = value; // Update number input
            const scaleFactor = parseFloat(value); // Get the scale factor
            currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Scale the model uniformly
          });

          // Add event listeners for number inputs to update sliders
          document.getElementById("rotation-x-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-x").value = value; // Update range input
            currentUfoModel.rotation.x = THREE.MathUtils.degToRad(value); // Convert degrees to radians
          });

          document.getElementById("rotation-y-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-y").value = value; // Update range input
            currentUfoModel.rotation.y = THREE.MathUtils.degToRad(value); // Convert degrees to radians
          });

          document.getElementById("rotation-z-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-z").value = value; // Update range input
            currentUfoModel.rotation.z = THREE.MathUtils.degToRad(value); // Convert degrees to radians
          });

          document.getElementById("position-x-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-x").value = value; // Update range input
            currentUfoModel.position.x = parseFloat(value); // Update the x position of the model
          });

          document.getElementById("position-y-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-y").value = value; // Update range input
            currentUfoModel.position.y = parseFloat(value); // Update the y position of the model
          });

          document.getElementById("position-z-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-z").value = value; // Update range input
            currentUfoModel.position.z = parseFloat(value); // Update the z position of the model
          });

          document.getElementById("scale-factor-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("scale-factor").value = value; // Update range input
            const scaleFactor = parseFloat(value); // Get the scale factor
            currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Scale the model uniformly
          });

          // Load current values into input fields after model is loaded
          document.getElementById("position-x").value = currentUfoModel.position.x;
          document.getElementById("position-y").value = currentUfoModel.position.y;
          document.getElementById("position-z").value = currentUfoModel.position.z;
          document.getElementById("scale-factor").value = currentUfoModel.scale.x; // Assuming uniform scaling
          document.getElementById("position-x-value").value = currentUfoModel.position.x;
          document.getElementById("position-y-value").value = currentUfoModel.position.y;
          document.getElementById("position-z-value").value = currentUfoModel.position.z;

          // Convert radians to degrees for display
          const rotationXInDegrees = THREE.MathUtils.radToDeg(currentUfoModel.rotation.x);
          const rotationYInDegrees = THREE.MathUtils.radToDeg(currentUfoModel.rotation.y);
          const rotationZInDegrees = THREE.MathUtils.radToDeg(currentUfoModel.rotation.z);

          document.getElementById("rotation-x").value = Math.round(rotationXInDegrees); // Round to nearest integer
          document.getElementById("rotation-y").value = Math.round(rotationYInDegrees); // Round to nearest integer
          document.getElementById("rotation-z").value = Math.round(rotationZInDegrees); // Round to nearest integer

          document.getElementById("rotation-x-value").value = Math.round(rotationXInDegrees);
          document.getElementById("rotation-y-value").value = Math.round(rotationYInDegrees);
          document.getElementById("rotation-z-value").value = Math.round(rotationZInDegrees);
          document.getElementById("scale-factor-value").value = currentUfoModel.scale.x;

        } catch (error) {
          console.error('An error occurred while loading the GLTF model:', error);
        }
      }
      loader.updateProgress();
      const toolbarColumns = document.querySelectorAll('.toolbar-column');

      toolbarColumns.forEach(column => {
        column.addEventListener('touchstart', () => {
          column.classList.add('active'); // Add active class on touch
        });

        column.addEventListener('touchend', () => {
          column.classList.remove('active'); // Remove active class on touch end
        });
      });

      document.getElementById("load-topic-rules-for-marker").addEventListener("click", async () => {
        try {
          let userInput = document.getElementById("input-field-2-0").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput;
          }

          const messagesContainer = document.getElementById('loaded-topic-rules-for-marker');
          messagesContainer.innerHTML = '';
          const topicSpinnerChat = `
        <div style="display: flex; justify-content: left; align-items: left; padding-top: 1vh; padding-bottom: 1vh;">
          <div id="topicspinnerchat"></div>
          <span style="margin-left: 1vw;">loading messages from ${topicId}</span>
          </div>`;
          messagesContainer.innerHTML = topicSpinnerChat;
          adjustTextareaHeight(messagesContainer);


          const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);
          const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          let hasRules = false;
          const memo = topicInfo.memo;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
              hasRules = true;
            }
          });

          const messages = response.messages; // Extract messages

          const loadedTopicRulesForMarker = [];

          // Read rules from messages
          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
              if (parsedMessage.rules && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                loadedTopicRulesForMarker.push(parsedMessage.rules.formarker);
                hasRules = true;
                break; // Exit the loop after finding the last message with rules
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          if (hasRules === false) {
            const utilityRulesMessage = `<span>No rules for this topic.</span>`;
            messagesContainer.innerHTML = utilityRulesMessage;
            adjustTextareaHeight(messagesContainer);
            return;
          }



          const markerRulesMessage = `<span style="user-select: text;">To post markers, you must own NFT.<br>
    NFT = ${loadedTopicRulesForMarker[0].markerTopicId}.<br>
    Each NFT allows posting ${loadedTopicRulesForMarker[0].markerMessagesPerNft} markers.</span>`;
          messagesContainer.innerHTML = markerRulesMessage;
          adjustTextareaHeight(messagesContainer);



        } catch (error) {
          const messagesContainer = document.getElementById('loaded-topic-rules-for-marker');
          const invalidTopicIdMessage = `<span style="padding-top: 1vh;">Invalid Topic ID</span>`;
          messagesContainer.innerHTML = invalidTopicIdMessage;
          adjustTextareaHeight(messagesContainer);
        }
      });




      document.getElementById("load-topic-rules-for-polygon").addEventListener("click", async () => {
        try {
          let userInput = document.getElementById("input-field-3-0").value.toLowerCase();
          let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
          let topicId;

          if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
          } else {
            topicId = userInput;
          }

          const messagesContainer = document.getElementById('loaded-topic-rules-for-polygon');
          messagesContainer.innerHTML = '';
          const topicSpinnerChat = `
        <div style="display: flex; justify-content: left; align-items: left; padding-top: 1vh; padding-bottom: 1vh;">
          <div id="topicspinnerchat"></div>
          <span style="margin-left: 1vw;">loading messages from ${topicId}</span>
          </div>`;
          messagesContainer.innerHTML = topicSpinnerChat;
          adjustTextareaHeight(messagesContainer);


          const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);
          const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          let hasRules = false;
          const memo = topicInfo.memo;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
              hasRules = true;
            }
          });
          const messages = response.messages; // Extract messages

          const loadedTopicRulesForPolygon = [];

          // Read rules from messages
          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
              if (parsedMessage.rules && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                loadedTopicRulesForPolygon.push(parsedMessage.rules.forpolygon);
                hasRules = true;
                break; // Exit the loop after finding the last message with rules
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          if (hasRules === false) {
            const utilityRulesMessage = `<span>No rules for this topic.</span>`;
            messagesContainer.innerHTML = utilityRulesMessage;
            adjustTextareaHeight(messagesContainer);
            return;
          }



          const polygonRulesMessage = `<span style="user-select: text;">To post polygons, you must own NFT.<br>
  NFT = ${loadedTopicRulesForPolygon[0].polygonTopicId}.<br>
  Each NFT allows posting ${loadedTopicRulesForPolygon[0].polygonMessagesPerNft} polygons.<br></span>`;

          const polygonSize = loadedTopicRulesForPolygon[0].polygonSize;
          const maxLongitudeSize = 360 / polygonSize;
          const maxLatitudeSize = 180 / polygonSize;

          const polygonRulesMessages = `<span style="user-select: text;">Maximum distance between points is:<br>
   ${maxLongitudeSize} for longitude<br>
   ${maxLatitudeSize} for latitude.<br>
   If not = wont load.</span>`;

          messagesContainer.innerHTML = polygonRulesMessage + polygonRulesMessages;
          adjustTextareaHeight(messagesContainer);



        } catch (error) {
          const messagesContainer = document.getElementById('loaded-topic-rules-for-polygon');
          const invalidTopicIdMessage = `<span style="padding-top: 1vh;">Invalid Topic ID</span>`;
          messagesContainer.innerHTML = invalidTopicIdMessage;
          adjustTextareaHeight(messagesContainer);
        }
      });




      function isValidUrl(url) {
        try {
          new URL(url);
          return true;
        } catch {
          return false;
        }
      }




      async function processTopicMessages(topicId) {
        const topicGeojsonFeatures = []; // Store geojson features for this topic
        const topicPolygons = []; // Store polygons for this topic
        let loadedTopicName = ''; // Initialize loadedTopicName
        const profilePics = await loadProfilePicture();
        const usernames = await loadUsername();
        const click2url = await loadCLICK2URL();

        try {
          const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          let hasRulesForMarker = false;
          let hasRulesForPolygon = false;
          const memo = topicInfo.memo;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
            }
          });



          // Check if messages exist and is an array
          if (!response.messages || !Array.isArray(response.messages)) {
            console.error(`No messages found for topic ${topicId}.`, response);
            return { topicGeojsonFeatures, topicPolygons }; // Return empty arrays
          }

          const messages = response.messages; // Extract messages

          const loadedTopicRulesForMarker = [];
          const loadedTopicRulesForPolygon = [];



          // Read rules from messages
          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }

              if (parsedMessage.rules && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                if (parsedMessage.rules.formarker.markerTopicId.startsWith('0.0.') && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                  loadedTopicRulesForMarker.push(parsedMessage.rules.formarker);
                  hasRulesForMarker = true;

                }
                if (parsedMessage.rules.forpolygon.polygonTopicId.startsWith('0.0.') && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                  loadedTopicRulesForPolygon.push(parsedMessage.rules.forpolygon);
                  hasRulesForPolygon = true;

                }
                break; // Exit the loop after finding the last message with rules
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
              // Check if changeName exists and either topicAdmin is empty or includes the payer
              if (parsedMessage.changeName && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                loadedTopicName = parsedMessage.changeName;
                break; // Stop after finding the first valid message
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }
          const uniquePayerIdsForMarker = new Set();
          const uniquePayerIdsForPolygon = new Set();

          // Extract payer IDs from messages
          for (const message of messages) {
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }

              // Add payer IDs for markers
              if (parsedMessage.marker && parsedMessage.marker.data) {
                uniquePayerIdsForMarker.add(parsedMessage.payer);
              }

              // Add payer IDs for polygons
              if (parsedMessage.polygon && parsedMessage.polygon.data) {
                uniquePayerIdsForPolygon.add(parsedMessage.payer);
              }

              if (parsedMessage.addTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const nfts = parsedMessage.addTopicNFT.split(',').map(nft => nft.trim());
                nfts.forEach(nft => {
                  if (!loadedNFTsForModel.includes(nft)) {
                    loadedNFTsForModel.push(nft);
                  }
                });
              }

              if (parsedMessage.removeTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const nft = parsedMessage.removeTopicNFT.trim();
                const index = loadedNFTsForModel.indexOf(nft);
                if (index !== -1) {
                  loadedNFTsForModel.splice(index, 1);
                }
              }

              if (parsedMessage.addScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const { NFT, scale } = parsedMessage.addScale;
                loadedNFTScaleForModel.push({ NFT, scale });
              }

              if (parsedMessage.removeScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                const { NFT } = parsedMessage.removeScale;
                const index = loadedNFTScaleForModel.findIndex(item => item.NFT === NFT);
                if (index !== -1) {
                  loadedNFTScaleForModel.splice(index, 1); // Remove the item if it exists
                } else {
                  console.log(`NFT: ${NFT} not found in addScale list`);
                }
              }

              updateRulesForModelNFTState();

            } catch (error) {
              console.error("Error extracting payer ID:", error);
            }
          }

          // Ownership logic
          const markerOwnershipArray = [];
          const polygonOwnershipArray = [];


          if (hasRulesForMarker) {
            // Iterate over each unique payer ID for markers
            for (const payerId of uniquePayerIdsForMarker) {
              const tokenIdForMarker = loadedTopicRulesForMarker[0].markerTopicId;
              const filteredNftsForMarker = await sdk.getAccountNFTs(payerId, tokenIdForMarker);

              // Check if the user owns NFTs and push to an array
              if (filteredNftsForMarker.length > 0) {
                const numberOfMessages = filteredNftsForMarker.length * loadedTopicRulesForMarker[0].markerMessagesPerNft;
                const numberOfMarker = [];
                markerOwnershipArray.push({ payerId, numberOfMessages, numberOfMarker });
              }
            }
          }

          if (hasRulesForPolygon) {

            // Iterate over each unique payer ID for polygons
            for (const payerId of uniquePayerIdsForPolygon) {
              const tokenIdForPoly = loadedTopicRulesForPolygon[0].polygonTopicId;
              const filteredNftsForPoly = await sdk.getAccountNFTs(payerId, tokenIdForPoly);

              // Check if the user owns NFTs and push to an array
              if (filteredNftsForPoly.length > 0) {
                const numberOfMessages = filteredNftsForPoly.length * loadedTopicRulesForPolygon[0].polygonMessagesPerNft;
                const numberOfPolygon = [];
                polygonOwnershipArray.push({ payerId, numberOfMessages, numberOfPolygon });
              }
            }
          }

          if (!hasRulesForMarker) {
            for (const payerId of uniquePayerIdsForMarker) {
              const numberOfMarker = [];
              markerOwnershipArray.push({ payerId, numberOfMarker });
            }
          }
          if (!hasRulesForPolygon) {
            for (const payerId of uniquePayerIdsForPolygon) {
              const numberOfPolygon = [];
              polygonOwnershipArray.push({ payerId, numberOfPolygon });
            }
          }
          // Process each message
          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }

              const timestamp = new Date(parsedMessage.created)
                .toLocaleString('en-US', {
                  hour12: false,
                  year: 'numeric',
                  month: '2-digit',
                  day: '2-digit',
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit'
                })


              const defaultProfilePic = "https://kiloscribe.com/api/inscription-cdn/0.0.4819119";
              const profileUrl = isValidUrl(message.payer && profilePics[message.payer] ?
                profilePics[message.payer].url :
                defaultProfilePic) ?
                (message.payer && profilePics[message.payer] ? profilePics[message.payer].url : defaultProfilePic) :
                defaultProfilePic;

              const payerInfo = message.payer ? `${message.payer}` : 'Anonymous';
              const username = message.payer && usernames[message.payer] ?
                ` ${usernames[message.payer].username}` :
                '';
              const click2link = message.payer && click2url[message.payer] ?
                ` ${click2url[message.payer].click2url}` :
                '';

              const displayHeader = `
              <h2>
                <a href="https://explore.hashpack.app/${payerInfo}" target="_blank" class="payer-info" style="color: #800080; text-decoration: none;">${payerInfo}</a>
                <br>
                ${click2link ? `<a href="${click2link}" target="_blank" class="username" style="color: #FFFFFF; text-decoration: none;">${username}</a>` : `${username}`}
              </h2>`;

              if (parsedMessage.marker && parsedMessage.marker.data) {
                const markernumber = parsedMessage.marker.data.numberOfMarker;
                const markerOwner = markerOwnershipArray.find(owner => owner.payerId === message.payer);

                if (parsedMessage.marker.data.deleteMarkerNumber) {
                  const deleteMarkerNumber = parsedMessage.marker.data.deleteMarkerNumber;
                  markerOwner.numberOfMarker.push(deleteMarkerNumber);
                }

                if (markernumber === undefined || markernumber === null || !Number.isInteger(Number(markernumber))) {
                  continue;
                }

                if (!markerOwner.numberOfMarker.includes(markernumber)) {
                  markerOwner.numberOfMarker.push(markernumber);

                  if (!hasRulesForMarker || (markerOwner && markerOwner.numberOfMessages > 0)) {

                    if (hasRulesForMarker) {
                      markerOwner.numberOfMessages -= 1;
                    }

                    let coords;
                    try {
                      const cordData = parsedMessage.marker.data.cord;

                      if (typeof cordData === 'string') {
                        coords = cordData.split(',').map(num => parseFloat(num.trim()));
                      } else if (Array.isArray(cordData)) {
                        coords = cordData;
                      } else {
                        throw new Error('Unsupported coordinate format');
                      }

                      if (!Array.isArray(coords) || coords.length !== 2 || coords.some(isNaN)) {
                        throw new Error('Invalid coordinate format');
                      }

                      topicGeojsonFeatures.push({
                        type: "Feature",
                        payer: message.payer,
                        properties: {
                          message:
                            `
      <div style="position: absolute; top: -0.1em; left: 0.1em; font-weight: bold;" class="number">${markernumber}</div>
      <div style="display: flex; align-items: center;">
      <img src="${profileUrl}" alt="Profile photo"
      style="width: 7vh; height: 7vh; margin-right: 1em; border-radius: 50%; cursor: pointer;"
      onclick="loadTOPIC4PIC('${message.payer}');">
        <div>${displayHeader}</div>
      </div>
      <div style="text-align: center;">
        <div style='margin-bottom: 1vh;'>
            <strong class="title_color">${parsedMessage.marker.data.title}</strong>
        </div>
        <div>
          ${isValidUrl(parsedMessage.marker.data.image) ? `<img src="${parsedMessage.marker.data.image}" style="width: 20vh; height: 20vh; display: block; margin: 0 auto;" />` : ''} 
        </div>
        <div>
          <p class="text_color">${parsedMessage.marker.data.msg}</p>
        </div>
      </div>
      <div style="position: absolute; bottom: 0em; right: 1vh; font-size: 1vh; color: gray;">${timestamp}</div>
      <span style="position: absolute; bottom: 0em; left: 1vh; font-size: 1.5vh; color: gray; cursor: pointer;"
      onclick="openPopupSettings();">&#9881;</span>

    `,
                          imageUrl: isValidUrl(parsedMessage.marker.data.coverimage) ? parsedMessage.marker.data.coverimage : profileUrl
                        },
                        geometry: {
                          type: "Point",
                          coordinates: coords
                        }
                      });
                    } catch (coordError) {
                      console.error("Error parsing marker coordinates:", coordError, "Raw coords:", parsedMessage.marker.data.cord);
                    }
                  }
                }
              }

              // Handle polygon type messages
              if (parsedMessage.polygon && parsedMessage.polygon.data) {
                const polygonOwner = polygonOwnershipArray.find(owner => owner.payerId === message.payer);
                const polygonnumber = parsedMessage.polygon.data.numberOfPolygon;

                if (parsedMessage.polygon.data.deletePolygonNumber) {
                  const deletePolygonNumber = parsedMessage.polygon.data.deletePolygonNumber;
                  polygonOwner.numberOfPolygon.push(deletePolygonNumber);
                }

                if (polygonnumber === undefined || polygonnumber === null || !Number.isInteger(Number(polygonnumber))) {
                  continue;
                }

                if (!polygonOwner.numberOfPolygon.includes(polygonnumber)) {
                  polygonOwner.numberOfPolygon.push(polygonnumber);


                  if (!hasRulesForPolygon || (polygonOwner && polygonOwner.numberOfMessages > 0)) {
                    if (hasRulesForPolygon) {
                      polygonOwner.numberOfMessages -= 1;
                    }

                    try {
                      const cordStr = parsedMessage.polygon.data.cord;

                      // Validate the coordinate string format
                      const validCoordPattern = /^\[-?\d+\.?\d*,\s*-?\d+\.?\d*\](,\s*\[-?\d+\.?\d*,\s*-?\d+\.?\d*\])*$/;
                      if (!validCoordPattern.test(cordStr)) {
                        continue; // Skip processing this message
                      }

                      // Parse the coordinates
                      const coordinates = JSON.parse(`[${cordStr}]`); // Wrap in brackets for valid JSON

                      if (Array.isArray(coordinates) && coordinates.length > 2) {
                        const polygonSize = hasRulesForPolygon ? loadedTopicRulesForPolygon[0].polygonSize : 1;




                        topicPolygons.push({
                          id: `
                          polygon-${index}`,
                          payer: message.payer,
                          coordinates: [coordinates],
                          description: `
          <div style="position: absolute; top: -0.1em; left: 0.1em; font-weight: bold;" class="number">${parsedMessage.polygon.data.numberOfPolygon}</div>
          <div style="display: flex; align-items: center;">
<img src="${profileUrl}" alt="Profile photo"
      style="width: 7vh; height: 7vh; margin-right: 1em; border-radius: 50%; cursor: pointer;"
      onclick="loadTOPIC4PIC('${message.payer}');">
            <div>${displayHeader}</div>
          </div>
          <div style="text-align: center;">
            <div style='margin-bottom: 1vh;'>
                <strong class="title_color">${parsedMessage.polygon.data.title}</strong>
            </div>
            <div>
              ${isValidUrl(parsedMessage.polygon.data.image) ? `<img src="${parsedMessage.polygon.data.image}" 
              style="width: 20vh; height: 20vh; display: block; margin: 0 auto;" />` : ''}
            </div>
            <div>
              <p class="text_color">${parsedMessage.polygon.data.msg}</p>
            </div>
          </div>
          <div style="position: absolute; bottom: 0em; right: 1vh; font-size: 1vh; color: gray;">${timestamp}</div>
          <span style="position: absolute; bottom: 0em; left: 1vh; font-size: 1.5vh; color: gray; cursor: pointer;"
          onclick="openPopupSettings();">&#9881;</span>

                          `,
                          imageUrl: isValidUrl(parsedMessage.polygon.data.coverimage) ? parsedMessage.polygon.data.coverimage : profileUrl
                        });


                      }
                    } catch (polygonError) {
                      console.error("Error parsing polygon data:", polygonError);
                    }
                  }
                }
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }


          // At the end of the function, push the collected features to the parent arrays
          geojson.features.push(...topicGeojsonFeatures); // Push topic features to parent geojson array
          polygons.push(...topicPolygons); // Push topic polygons to parent polygons array
          return { topicGeojsonFeatures, topicPolygons, loadedTopicName };


        } catch (error) {
          console.error(`Error loading messages for topic ${topicId}:`, error);
          return { topicGeojsonFeatures: [], topicPolygons: [] }; // Return empty arrays on error
        }
      }


      // Array of models with their respective URLs, origins, and altitudes
      const models = [];

      async function load3dModels() {
        const customLayer = {
          id: "3d-model",
          type: "custom",
          renderingMode: "3d",
          onAdd(map, gl) {
            this.camera = new THREE.Camera();
            this.scene = new THREE.Scene();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            this.scene.add(ambientLight);

            const directions = [
              [1, 1, 1],
              [-1, 1, 1],
              [1, -1, 1],
              [-1, -1, 1],
              [1, 1, -1],
              [-1, 1, -1],
              [1, -1, -1],
              [-1, -1, -1],
            ];

            directions.forEach((dir) => {
              const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
              directionalLight.position.set(...dir).normalize();
              this.scene.add(directionalLight);
            });

            this.map = map;

            this.renderer = new THREE.WebGLRenderer({
              canvas: map.getCanvas(),
              context: gl,
              antialias: true,
            });

            this.renderer.autoClear = false;


            const loader = new THREE.GLTFLoader();
            loader.setDRACOLoader(dracoLoader);


            models.forEach(({ url, origin, altitude, scaleFactorNFT }) => {
              loader.load(url, (gltf) => {
                const model = gltf.scene;
                this.scene.add(model);

                // Calculate the model's bounding box
                const box = new THREE.Box3().setFromObject(model);
                const modelSize = new THREE.Vector3();
                box.getSize(modelSize);

                // Define the desired bounding box dimensions
                const boundingBoxSize = new THREE.Vector3(10000, 10000, 10000); // Width, Height, Depth

                // Calculate the scale factor to fit the model within the bounding box
                const scaleFactor = Math.min(
                  boundingBoxSize.x / modelSize.x,
                  boundingBoxSize.y / modelSize.y,
                  boundingBoxSize.z / modelSize.z
                );

                // Apply the scale to the model
                model.scale.set(scaleFactor * scaleFactorNFT, scaleFactor * scaleFactorNFT, scaleFactor * scaleFactorNFT);

                // Calculate the transformation matrix for each model's location and altitude
                const modelMatrix = this.map.transform.getMatrixForModel(origin, altitude);

                // Apply the transformation matrix to the model
                const modelTransformMatrix = new THREE.Matrix4()
                  .fromArray(modelMatrix)
                  .scale(new THREE.Vector3(10, 10, 10)); // Example scaling

                // Adjust the model's position to the bottom of the bounding box
                const modelHeight = modelSize.y * scaleFactor;
                const boundingBoxHeight = boundingBoxSize.y;
                const yOffset = (boundingBoxHeight - modelHeight) / 2;
                model.position.set(0, -yOffset, 0);

                model.applyMatrix4(modelTransformMatrix);
              });
            });
          },
          render(gl, args) {
            const mapProjectionMatrix = new THREE.Matrix4().fromArray(
              args.defaultProjectionData.mainMatrix
            );

            this.camera.projectionMatrix = mapProjectionMatrix;

            this.renderer.resetState();
            this.renderer.render(this.scene, this.camera);
            this.map.triggerRepaint();
          },
        }
        return customLayer;
      };

      map.on("style.load", async () => {
        map.setProjection({
          type: "globe",
        });

        const layers = map.getStyle().layers;
        const roadShieldLayer = layers.find(
          (layer) =>
            layer.id.toLowerCase().includes("road_shield") ||
            layer.id.toLowerCase().includes("shield")
        );

        if (roadShieldLayer) {
          map.setLayoutProperty(roadShieldLayer.id, "visibility", "none");
        }

        // Add the custom 3D model layer here
        map.addLayer(await load3dModels());
      });

      async function updateMapLayer() {
        // Remove the existing layer if it exists
        if (map.getLayer('3d-model')) {
          map.removeLayer('3d-model');
        }

        // Add the updated custom 3D model layer
        map.addLayer(await load3dModels());
      }

      let updateMapLayerIntervalId = null; // Initialize the interval ID

      let updateInterval = 5000; // Default interval time in milliseconds

      document.getElementById("update-loop").addEventListener("click", () => {
        const newInterval = parseInt(document.getElementById("time-input").value, 10);
        const updatesValue = document.getElementById("updates-value");
        const visibilityValue = document.getElementById("3d-model-visibility-value");
        const toggle3DModelButton = document.getElementById("toggle-3d-model-visibility");

        if (!isNaN(newInterval) && newInterval > 0) {
          updateInterval = newInterval;
          stopUpdateMapLayerLoop(); // Stop the current loop
          startUpdateMapLayerLoop(); // Start a new loop with the updated interval
          console.log(`Update interval set to ${updateInterval} milliseconds.`);
          updatesValue.textContent = "On"; // Ensure updates are "On"

          // Ensure 3D models are visible
          if (visibilityValue.textContent === "Off") {
            toggle3DModelButton.click(); // Simulate a click to turn on 3D models
          }
        } else {
          console.error("Invalid interval value. Please enter a positive number.");
        }
      });

      document.getElementById("toggle-updates").addEventListener("click", () => {
        const updatesValue = document.getElementById("updates-value");
        const updatesValue2 = document.getElementById("updates-value2");
        const visibilityValue = document.getElementById("3d-model-visibility-value");
        const toggle3DModelButton = document.getElementById("toggle-3d-model-visibility");

        if (updatesValue.textContent === "On") {
          stopUpdateMapLayerLoop(); // Stop the update loop
          updatesValue.textContent = "Off";
          updatesValue2.textContent = "Off";
        } else {
          startUpdateMapLayerLoop(); // Start the update loop
          updatesValue.textContent = "On";
          updatesValue2.textContent = "On";
          // Ensure 3D models are visible
          if (visibilityValue.textContent === "Off") {
            toggle3DModelButton.click(); // Simulate a click to turn on 3D models
          }
        }
      });

      function startUpdateMapLayerLoop() {
        if (updateMapLayerIntervalId === null) { // Only start if not already running
          updateMapLayerIntervalId = setInterval(() => {
            updateMapLayer();
          }, updateInterval); // Use the updated interval time
        }
      }

      function stopUpdateMapLayerLoop() {
        if (updateMapLayerIntervalId !== null) {
          clearInterval(updateMapLayerIntervalId);
          updateMapLayerIntervalId = null; // Reset the interval ID
        }
      }
      // Call this function to start the loop
      startUpdateMapLayerLoop();

      document.getElementById("update-map-layer-btn").addEventListener("click", async function () {
        await updateMapLayer();
      });

      document.getElementById("toggle-3d-model-visibility").addEventListener("click", async function () {
        const button = this;
        const visibilityValue = document.getElementById("3d-model-visibility-value");
        const visibilityValue2 = document.getElementById("3d-model-visibility-value2");
        const updatesValue = document.getElementById("updates-value");

        if (visibilityValue.textContent === "Off") {
          await updateMapLayer(); // Show 3D models
          startUpdateMapLayerLoop(); // Start the update loop
          visibilityValue.textContent = "On";
          visibilityValue2.textContent = "On";
          button.textContent = "Hide 3D models";
          updatesValue.textContent = "On"; // Ensure updates are "On"
        } else {
          if (map.getLayer('3d-model')) {
            map.removeLayer('3d-model'); // Hide 3D models
          }
          stopUpdateMapLayerLoop(); // Stop the update loop
          visibilityValue.textContent = "Off";
          visibilityValue2.textContent = "Off";
          button.textContent = "Show 3D models";
          updatesValue.textContent = "Off"; // Turn updates "Off" when 3D models are hidden
        }
      });

      function requestPeerList() {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ action: 'request_peer_list', peer_id: peerId }));
        }
      }



      let ws = null;
      let peerId = null;
      let knownPeers = new Map();
      let dataChannels = new Map();
      let receivedCoords = new Map();
      let retryAttempts = new Map();
      const maxRetries = 3;
      let seenMessages = new Set();
      let coordinates = null;
      let heartbeatInterval = null;
      let gossipInterval = null;
      let peerListRequestInterval = null; // Interval for requesting peer list

      async function someFunction(accountId, topicId) {
        // Clean up any existing connections
        await cleanup();

        peerId = topicId + '-' + accountId;

        connectToBootstrapServer();

        function generateMessageId() {
          return Math.random().toString(36).substr(2, 9) + '-' + Date.now();
        }

        function updateCoordinates() {
          let longitude = map.getCenter().lng; // Get current longitude from the map
          let latitude = map.getCenter().lat;   // Get current latitude from the map
          const zoomLevel = map.getZoom(); // Get the current zoom level
          let height;

          if (zoomLevel >= 10 && zoomLevel <= 19) {
            height = 50000;
          } else if (zoomLevel <= 9) {
            height = 50000 + (200000 * (10 - zoomLevel)); // Scale from 50000 at zoom 10 to 250000 at zoom 9
          } else if (zoomLevel <= 7) {
            height = 250000 + (450000 * (7 - zoomLevel)); // Scale down from 500000 to 5000000
          } else if (zoomLevel <= 3.5) {
            height = 5000000 + (65000000 * (3.5 - zoomLevel)); // Scale down from 5000000 to 70000000
          } else {
            height = 70000000; // Set height for zoom level 0
          }

          const xInput = longitude; // Set x from current longitude
          const yInput = latitude;  // Set y from current latitude
          const zInput = height;

          const x = parseFloat(xInput);
          const y = parseFloat(yInput);
          const z = parseFloat(zInput);

          // Validate input
          if (isNaN(x) || isNaN(y) || isNaN(z)) {
            console.error('Invalid coordinates: X, Y, Z must be numbers');
            alert('Please enter valid numbers for X, Y, Z');
            return;
          }

          coordinates = { x, y, z };
        }
        // Add this code to set up the interval for updating coordinates
        setInterval(() => {
          updateCoordinates(); // Call the function to update coordinates
        }, 5000); // 500 milliseconds interval



        function startHeartbeat() {
          setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ action: 'heartbeat', peer_id: peerId }));
            }
          }, 10000); // Send every 10 seconds
        }


        let globalPeers = [];

        function cleanUpModels() {

          for (let i = models.length - 1; i >= 0; i--) {
            if (!globalPeers.includes(models[i].peer_id)) {
              models.splice(i, 1);
            }
          }
        }


        function connectToBootstrapServer() {
          ws = new WebSocket('wss://serverws-9avk.onrender.com');
          ws.onopen = () => {
            console.log('Connected to bootstrap server');
            ws.send(JSON.stringify({ action: 'register', peer_id: peerId }));
            startHeartbeat(); // Start sending heartbeats
          };

          ws.onmessage = async (event) => {
            const message = JSON.parse(event.data);
            if (message.action === 'peer_list') {
              const peers = message.peers;
              globalPeers = peers; // Store the peers in the global array
              await setupWebRTCConnections(peers);
              startGossip();
            } else if (message.action === 'offer') {
              await handleOffer(message.peer_id, message.data);
            } else if (message.action === 'answer') {
              await handleAnswer(message.peer_id, message.data);
            } else if (message.action === 'candidate') {
              await handleCandidate(message.peer_id, message.data);
            }
          };
        }

        // Add peer list request interval (every 300 seconds)
        peerListRequestInterval = setInterval(() => {
          requestPeerList();
          cleanUpModels();
        }, 300000); // Request every 300 seconds

        async function setupWebRTCConnections(peerIds) {
          for (let remotePeerId of peerIds) {
            if (remotePeerId === peerId || knownPeers.has(remotePeerId)) continue;

            const pc = new RTCPeerConnection({
              iceServers: [
                {
                  urls: "stun:stun.relay.metered.ca:80",
                },
                {
                  urls: "turn:standard.relay.metered.ca:80",
                  username: "5b426285a4417f1bf0415241",
                  credential: "XNy5QEYS53JUYA5P",
                },
                {
                  urls: "turn:standard.relay.metered.ca:80?transport=tcp",
                  username: "5b426285a4417f1bf0415241",
                  credential: "XNy5QEYS53JUYA5P",
                },
                {
                  urls: "turn:standard.relay.metered.ca:443",
                  username: "5b426285a4417f1bf0415241",
                  credential: "XNy5QEYS53JUYA5P",
                },
                {
                  urls: "turns:standard.relay.metered.ca:443?transport=tcp",
                  username: "5b426285a4417f1bf0415241",
                  credential: "XNy5QEYS53JUYA5P",
                },
              ],
            });
            knownPeers.set(remotePeerId, pc);
            monitorWebRTCConnection(remotePeerId, pc);

            const dc = pc.createDataChannel('gossip');
            dataChannels.set(remotePeerId, dc);
            dc.onopen = () => {
              setTimeout(() => sendGossipMessage(remotePeerId), 1000);
            };
            dc.onmessage = (event) => handleGossipMessage(remotePeerId, event.data);
            dc.onclose = () => {
              console.log(`Data channel closed with ${remotePeerId}`);
              dataChannels.delete(remotePeerId);
            };

            pc.ondatachannel = (event) => {
              const incomingDc = event.channel;
              dataChannels.set(remotePeerId, incomingDc);
              incomingDc.onmessage = (event) => handleGossipMessage(remotePeerId, event.data);
              incomingDc.onclose = () => {
                dataChannels.delete(remotePeerId);
              };
            };

            pc.onicecandidate = (event) => {
              if (event.candidate) {
                ws.send(JSON.stringify({
                  action: 'candidate',
                  peer_id: peerId,
                  target_peer_id: remotePeerId,
                  data: event.candidate
                }));
              }
            };

            try {
              const offer = await pc.createOffer();
              await pc.setLocalDescription(offer);
              ws.send(JSON.stringify({
                action: 'offer',
                peer_id: peerId,
                target_peer_id: remotePeerId,
                data: pc.localDescription
              }));
            } catch (error) {
              console.error(`Failed to create offer for ${remotePeerId}:`, error);
            }
          }
        }

        function sendGossipMessage(peerId) {
          const dc = dataChannels.get(peerId);
          if (dc && dc.readyState === 'open') {
            const message = { /* your message data */ };
            dc.send(JSON.stringify(message));
          } else {
            console.log(`Cannot send to ${peerId}: Data channel not open`);
          }
        }

        // Store pending ICE candidates
        const pendingCandidates = new Map();

        async function handleOffer(senderPeerId, offer) {
          if (knownPeers.has(senderPeerId)) return;

          const pc = new RTCPeerConnection({
            iceServers: [
              {
                urls: "stun:stun.relay.metered.ca:80",
              },
              {
                urls: "turn:global.relay.metered.ca:80",
                username: "5b426285a4417f1bf0415241",
                credential: "XNy5QEYS53JUYA5P",
              },
              {
                urls: "turn:global.relay.metered.ca:80?transport=tcp",
                username: "5b426285a4417f1bf0415241",
                credential: "XNy5QEYS53JUYA5P",
              },
              {
                urls: "turn:global.relay.metered.ca:443",
                username: "5b426285a4417f1bf0415241",
                credential: "XNy5QEYS53JUYA5P",
              },
              {
                urls: "turns:global.relay.metered.ca:443?transport=tcp",
                username: "5b426285a4417f1bf0415241",
                credential: "XNy5QEYS53JUYA5P",
              },
            ],
          });
          knownPeers.set(senderPeerId, pc);
          monitorWebRTCConnection(senderPeerId, pc);

          pc.onicecandidate = (event) => {
            if (event.candidate) {
              ws.send(JSON.stringify({
                action: 'candidate',
                peer_id: peerId,
                target_peer_id: senderPeerId,
                data: event.candidate
              }));
            }
          };

          pc.ondatachannel = (event) => {
            const dc = event.channel;
            dataChannels.set(senderPeerId, dc);
            dc.onmessage = (event) => handleGossipMessage(senderPeerId, event.data);
            dc.onclose = () => {
              dataChannels.delete(senderPeerId);
            };
          };

          try {
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            ws.send(JSON.stringify({
              action: 'answer',
              peer_id: peerId,
              target_peer_id: senderPeerId,
              data: pc.localDescription
            }));

            // Process any queued ICE candidates
            if (pendingCandidates.has(senderPeerId)) {
              const candidates = pendingCandidates.get(senderPeerId);
              candidates.forEach(candidate => pc.addIceCandidate(candidate));
              pendingCandidates.delete(peerId);
            }
          } catch (error) {
            console.error(`Failed to handle offer from ${senderPeerId}:`, error);
          }
        }

        async function handleAnswer(senderPeerId, answer) {
          const pc = knownPeers.get(senderPeerId);
          if (!pc) return;

          try {
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
          } catch (error) {
            console.error(`Failed to handle answer from ${senderPeerId}:`, error);
          }
        }


        async function handleCandidate(peerId, candidate) {
          const pc = knownPeers.get(peerId);
          if (!pc) return;

          try {
            if (pc.remoteDescription && pc.remoteDescription.type) {
              await pc.addIceCandidate(new RTCIceCandidate(candidate));
            } else {
              // Queue the candidate if the remote description is not set
              if (!pendingCandidates.has(peerId)) {
                pendingCandidates.set(peerId, []);
              }
              pendingCandidates.get(peerId).push(candidate);
            }
          } catch (error) {
            console.error(`Failed to handle candidate from ${peerId}:`, error);
          }
        }

        function monitorWebRTCConnection(peerId, pc) {
          pc.oniceconnectionstatechange = () => {
            if (pc.iceConnectionState === 'connected') {
            } else if (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed') {
              retryWebRTCConnection(peerId);
            }
          };
        }

        function retryWebRTCConnection(peerId) {
          const attempts = retryAttempts.get(peerId) || 0;
          if (attempts >= maxRetries) {
            knownPeers.delete(peerId);
            dataChannels.delete(peerId);
            retryAttempts.delete(peerId);
            return;
          }

          retryAttempts.set(peerId, attempts + 1);
          knownPeers.delete(peerId);
          dataChannels.delete(peerId);
          setupWebRTCConnections([peerId]);
        }

        async function handleGossipMessage(senderPeerId, data) {
          const message = JSON.parse(data);
          const { peer_id, coordinates, ttl, timestamp, messageId, metadata, scaleFactorNFT } = message;

          // Check for duplicates
          if (seenMessages.has(messageId)) {
            return;
          }
          seenMessages.add(messageId);


          const existing = receivedCoords.get(peer_id);
          if (!existing || new Date(timestamp) > new Date(existing.timestamp)) {
            receivedCoords.set(peer_id, { ...coordinates, timestamp });
          }

          // Load URL using the peer ID
          const url = await loadProfileObjectUrl(peer_id);

          // Check if a model from this peer_id already exists
          const modelIndex = models.findIndex(model => model.peer_id === peer_id);

          if (modelIndex !== -1) {
            // Update the existing model
            models[modelIndex] = {
              peer_id: peer_id,
              url: url || 'https://kiloscribe.com/api/inscription-cdn/0.0.8392276',
              origin: [coordinates.x, coordinates.y],
              altitude: coordinates.z,
              scaleFactorNFT: scaleFactorNFT
            };
          } else {
            // Append new message to models array
            models.push({
              peer_id: peer_id,
              url: url || 'https://kiloscribe.com/api/inscription-cdn/0.0.8392276',
              origin: [coordinates.x, coordinates.y],
              altitude: coordinates.z,
              scaleFactorNFT: scaleFactorNFT
            });
          }
          if (ttl > 0) {
            message.ttl -= 1;
            message.metadata.hopCount += 1; // Increment hop count
            forwardGossipMessage(message);
          }
        }
        function startGossip() {
          setTimeout(() => {
            setInterval(() => {
              if (knownPeers.size === 0) {
                return;
              }
              const message = {
                peer_id: peerId,
                coordinates: coordinates,
                scaleFactorNFT: finalScaleForModel,
                ttl: 3,
                timestamp: new Date().toISOString(),
                messageId: generateMessageId(),
                metadata: {
                  hopCount: 0,
                  lastUpdated: new Date().toISOString()
                }
              };
              const fanout = Math.max(1, Math.floor(Math.sqrt(knownPeers.size))); // Dynamic fanout
              const targetPeers = Array.from(knownPeers.entries())
                .sort(() => Math.random() - 0.5)
                .slice(0, fanout);
              for (let [peerId, pc] of targetPeers) {
                const dc = dataChannels.get(peerId);
                if (dc && dc.readyState === 'open') {
                  dc.send(JSON.stringify(message));
                } else {
                  retryWebRTCConnection(peerId);
                }
              }
            }, 1000);
          }, 5000);
        }
        function forwardGossipMessage(message) {
          const fanout = Math.max(1, Math.floor(Math.sqrt(knownPeers.size))); // Dynamic fanout
          const targetPeers = Array.from(knownPeers.entries())
            .sort(() => Math.random() - 0.5)
            .slice(0, fanout);
          for (let [peerId, pc] of targetPeers) {
            const dc = dataChannels.get(peerId);
            if (dc && dc.readyState === 'open') {
              dc.send(JSON.stringify(message));
            } else {
              console.log(`Cannot forward to ${peerId}: Data channel not open`);
            }
          }
        }
        async function loadProfileObjectUrl(payerId) {
          if (!payerId) {
            console.error("payerId is undefined");
            return null;
          }
          // Remove 'peer-' prefix if present
          const cleanPayerId = payerId.split('-')[1];
          const topicId = "0.0.9609898";
          const accountUrl = []; // Initialize an empty array to store account URLs
          try {
            const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
            // Check if result exists and has messages
            if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
              console.log("No profile object found, using defaults");
              return null; // Return null if no messages
            }
            // Filter messages to find those from the current user
            const userMessages = result.messages.filter(message => message.payer === cleanPayerId);
            // Get the last message from the filtered user messages
            const lastMessage = userMessages[userMessages.length - 1];
            // Check if the last message has valid data
            if (lastMessage && lastMessage.data && lastMessage.data.urls && lastMessage.data.urls.length > 0) {
              return lastMessage.data.urls[0]; // Return the first URL
            }
            return null; // Return null if no valid URL found
          } catch (error) {
            console.log("Error in loadProfileObject:", error);
            return null; // Return null instead of throwing error
          }
        }
      }
      async function cleanup() {
        console.log('[Client] Cleaning up connections and state');
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.close();
          console.log('[Client] Closed WebSocket connection');
        }
        ws = null;
        if (heartbeatInterval) {
          clearInterval(heartbeatInterval);
          heartbeatInterval = null;
          console.log('[Client] Cleared heartbeat interval');
        }
        if (gossipInterval) {
          clearInterval(gossipInterval);
          gossipInterval = null;
          console.log('[Client] Cleared gossip interval');
        }
        if (peerListRequestInterval) {
          clearInterval(peerListRequestInterval);
          peerListRequestInterval = null;
          console.log('[Client] Cleared peer list request interval');
        }
        for (const [peerId, pc] of knownPeers.entries()) {
          pc.close();
          const dc = dataChannels.get(peerId);
          if (dc) {
            dc.close();
          }
          console.log(`[Client] Closed WebRTC connection with ${peerId}`);
        }
        knownPeers.clear();
        dataChannels.clear();
        receivedCoords.clear();
        retryAttempts.clear();
        seenMessages.clear();
        peerId = null;
        coordinates = null;
        models.length = 0;
        console.log('[Client] Cleared all state');
      }
      loader.updateProgress();
    }
  }
</script>
<script src="script.js"></script>
  </div> <!-- .app-container -->
</body>

</html>